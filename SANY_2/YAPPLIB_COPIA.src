#<AdxTL>@(#)0.0.0.0 $Revision$
####################################################################
#**
#* Sub que devuelve los clientes de la lista de preparción en curso
#*
#*!
Subprog GETLISTCLIENTE(PBPCORD, PBPCNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(10)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  If !clalev([YPBC]) Then : Local File BPCUSTOMER      [YPBC] : Endif

    Raz LREQSQL

    LREQSQL(0) = "Select BPCORD_0 "
    LREQSQL(1) = " From "+nomap + ".STOPREH "
    LREQSQL(2) = " Where DLVFLG_0 = 1  and  SHIDAT_0 >= '" + PDVLDATDESDE + "' and SHIDAT_0 <= '" + PDVLDATHASTA + "'"
    LREQSQL(3) = " GROUP BY BPCORD_0"
    LREQSQL(4) = " ORDER BY BPCORD_0 ASC"


  Infbox(LREQSQL)
  I=0
  For (Char BPCORD) From '5' Sql LREQSQL(0..9) As [YAPP]
    #Infbox (num$(I)+ " " +[F:YAPP]BPCORD)
    PBPCORD(I)=[F:YAPP]BPCORD
    #razón social del cliente
    Read [F:YPBC]BPC0=[F:YAPP]BPCORD
    If !fstat Then
      PBPCNAM(I) = [F:YPBC]BPCNAM
    Endif
    PRES = '200'
    PMESS = 'OK'
    I+=1
    If I>LISTMAX Then
      Break
    Endif

  Next



  Close Local File [YPBC]

End


####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*
#*!
Subprog GETLISTTRANS(PBPTNUM, PBPTNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPTNUM()()
  Variable Char PBPTNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(10)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0




  If !clalev([YBPT]) Then : Local File BPCARRIER      [YBPT] : Endif

    Raz LREQSQL

    LREQSQL(0) = "Select BPTNUM_0 "
    LREQSQL(1) = " From "+nomap + ".STOPREH "
    LREQSQL(2) = " Where DLVFLG_0 = 1  and  SHIDAT_0 >= '" + PDVLDATDESDE + "' and SHIDAT_0 <= '" + PDVLDATHASTA + "' and BPTNUM_0<>''"
    LREQSQL(3) = " GROUP BY BPTNUM_0"
    LREQSQL(4) = " ORDER BY BPTNUM_0 ASC"


 #Infbox(LREQSQL)
  I=0
  For (Char BPTNUM) From '5' Sql LREQSQL(0..9) As [YAPP]
    #Infbox (num$(I)+ " " +[F:YAPP]BPCORD)
    PBPTNUM(I)=[F:YAPP]BPTNUM
    #razón social del cliente
    Read [F:YBPT]BPT0=[F:YAPP]BPTNUM
    If !fstat Then
      PBPTNAM(I) = [F:YBPT]BPTNAM
    Endif
    PRES = '200'
    PMESS = 'OK'
    I+=1
    If I>LISTMAX Then
      Break
    Endif

  Next

  Close Local File [YBPT]

End



####################################################################
#**
#* Subprograma para controlar el acceso a la appmovil
#*
#* @param PUSR
#* @param PPASS
#* @param PACCESO
#* @param PMESS
#*!
Subprog GETACCESO(PUSR, PPASS, PACCESO, PMESS)
  Value Char PUSR
  Value Char PPASS
  Variable Char PACCESO, PMESS()


  If !clalev([YUSR]) Then : Local File AUTILIS [YUSR] : Endif

  Read [F:YUSR]CODUSR=PUSR
  If !fstat Then
    If [F:YUSR]YUSRAPP = 2 Then
      If [F:YUSR]YPASSAPP = PPASS Then
        PACCESO = "1" # acceso correcto
        PMESS = "Acceso correcto"
      Else
        PACCESO = "2" # pass incorrecta
        PMESS = "Password incorrecta"
      Endif
    Else
      PACCESO = "0" # usuario sin acceso a la app
      PMESS = "Usuario sin acceso a la App"
    Endif
 Else
  PACCESO = "3" # usuario no encontrado
  PMESS = "Usuario no encontrado"
 Endif

  Close Local File [YUSR]


End



####################################################################
#**
#* Sub que devuelve las listas de preparación en curso
#*
#*!
#Subprog GETLISTPREPARA(PPRHNUM , PPREUSR, PSTOFCY, PPRLNUM,  PBPCORD, PBPCNAM,  PBPTNUM, PBPTDES, PDLVDAT, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE)
#
#  Variable Char PPRHNUM()()
#  Variable Char PPREUSR()()
#  Variable Char PSTOFCY()()
#  Variable Char PPRLNUM()()
#  Variable Char PBPCORD()()
#  Variable Char PBPCNAM()()
#  Variable Char PBPTNUM()()
#  Variable Char PBPTDES()()
#  Variable Char PDLVDAT()()
#  Variable Char PRES
#  Variable Char PMESS
#  Variable Char PDVLDATDESDE()
#  Variable Char PDVLDATHASTA()
#  Variable Char PBPCORDDESDE()
#  Variable Char PBTNUMDESDE()
#
#  Local Char CRITERE(250)(19) : CRITERE(0) ="1=1"
#  Local    Char LFCY
#
#  If !clalev([YPRH]) Then : Local File STOPREH     [YPRH] : Endif
#  If !clalev([YPBC]) Then : Local File BPCUSTOMER      [YPBC] : Endif
#  If !clalev([YBPT]) Then : Local File BPCARRIER      [YBPT] : Endif
# # If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif
#
#
#
# CRITERE(0)="DLVFLG = 1"
#
#Local Char LREQSQL(250)(14)
# Raz LREQSQL
#
#  LREQSQL(0) =
#&
#& " SELECT P.SOHNUM_0, P.BPCORD_0, C.BPCNAM_0, MIN(D.SHIDAT_0) AS SHIDATMIN, P.ORDSTA_0, ISNULL(P.BPTNUM_0,'') As PBTNUM, ISNULL(CA.BPTNAM_0,'') As BPTNAM,'' As TCTRNUM,
# D.SHIDAT_0,P.PREUSR_0,P.STOF"
#&  + "CY_0"
#  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
#  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN  " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
#  LREQSQL(3) = " LEFT JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0"
#  LREQSQL(4) = " LEFT JOIN " + nomap + ".LPN L ON L.LPNNUM_0=D.YLPNNUM_0"
#  LREQSQL(5) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 AND D.ALLQTYSTU_0 > 0 AND ISNULL(L.PRTFLG_0,1)<>2 and DLVFLG = 1""
#  #fecha envío
#  If PDVLDATDESDE <> "" Then
#    LREQSQL(6) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
#  Endif
#  If PDVLDATHASTA <> "" Then
#    LREQSQL(7) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
#    Endif
#   #Cliente
#  If PBPCORDDESDE <> "" Then
#    LREQSQL(8) += " AND P.BPCORD_0='" + PBPCORDDESDE + "'"
#  Endif
#  #transportista
#  If PBTNUMDESDE <> "" Then
#    LREQSQL(9) += " AND P.BPTNUM_0='" + PBTNUMDESDE + "'"
#  Endif
#
#  LREQSQL(12) += " GROUP By  P.SOHNUM_0, P.BPCORD_0, C.BPCNAM_0, P.ORDSTA_0, ISNULL(P.BPTNUM_0,''),ISNULL(CA.BPTNAM_0,''),D.SHIDAT_0,P.PREUSR_0,STOFCY_0"
#
#
#  Local Integer LISTMAX : LISTMAX = 199
#  Local Integer I: I=0
#
##For I=0 To 11
##  Infbox(LREQSQL(I))
## Next
# I=0
#  For (Char SOHNUM, Char BPCORD, Char BPCNAM, Date SHIDATMIN, Integer ORDSTA, Char BPTNUM, Char BPTNAM, Char TCTRNUM, Date SHIDAT, Char PREUSR, Char STOFCY) From '5' Sql LREQSQL(0..14) As [YAPP]
#      Infbox (num$(I))
#      PPRHNUM(I)=[F:YAPP]PRHNUM
#      Infbox ("otra " + num$(I))
#      PPREUSR(I)=[F:YAPP]PREUSR
#      PSTOFCY(I)=[F:YAPP]STOFCY
#      PPRHNUM(I)=[F:YAPP]PRHNUM
#      PPRLNUM(I)=[F:YAPP]PRLNUM
#      PBPCORD(I)=[F:YAPP]BPCORD
#      PBPTNUM(I)=[F:YAPP]BPTNUM
#    # Char PBPCNAM()()
#      PDLVDAT(I)=num$([F:YPRH]SHIDAT)
#      #razón social del cliente
#      PBPCNAM(I) = [F:YAPP]BPCNAM
#      #Buscamos el transportista
#      PBPTDES(I) = [F:YAPP]BPTNAM
#      PRES = '200'
#      PMESS = 'OK'
#      I+=1
#      If I>LISTMAX Then
#        Break
#      Endif
#
#    Next
#
#  Close Local File [YPRH], [YPBC]
#
#End

Subprog GETLISTPREPARA(PPRHNUM , PPREUSR, PSTOFCY, PPRLNUM,  PBPCORD, PBPCNAM,  PBPTNUM, PBPTDES, PDLVDAT, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE)

  Variable Char PPRHNUM()()
  Variable Char PPREUSR()()
  Variable Char PSTOFCY()()
  Variable Char PPRLNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PBPTNUM()()
  Variable Char PBPTDES()()
  Variable Char PDLVDAT()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()
  Variable Char PBPCORDDESDE()
  Variable Char PBTNUMDESDE()

  Local Char CRITERE(250)(19) : CRITERE(0) ="1=1"
  Local    Char LFCY

  If !clalev([YPRH]) Then : Local File STOPREH     [YPRH] : Endif
  If !clalev([YPBC]) Then : Local File BPCUSTOMER      [YPBC] : Endif
  If !clalev([YBPT]) Then : Local File BPCARRIER      [YBPT] : Endif
 # If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif

 Raz CRITERE

 CRITERE(0)="DLVFLG = 1"

  #fecha envío
  If PDVLDATDESDE <> "" Then
    CRITERE(1) += "&SHIDAT>=[" + (PDVLDATDESDE) + "]"
  Endif
  If PDVLDATHASTA <> "" Then
    CRITERE(1) += "&SHIDAT<=[" + (PDVLDATHASTA) + "]"
  Endif
 #Cliente
  If PBPCORDDESDE <> "" Then
    CRITERE(2) += "&BPCORD='" + PBPCORDDESDE + "'"
  Endif
#transportista
  If PBTNUMDESDE <> "" Then
    CRITERE(3) += "&BPTNUM='" + PBTNUMDESDE + "'"
  Endif

   Infbox CRITERE



  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0


    PRES = '200'
    PMESS = 'No hay doc. preparación.'
    #Read [F:YSTO]STO4=LFCY;PUBICACION
    Filter [F:YPRH] Where evalue(CRITERE(0..9))

    For [F:YPRH]

      Infbox (num$(I))
      PPRHNUM(I)=[F:YPRH]PRHNUM
      Infbox ("otra " + num$(I))
      PPREUSR(I)=[F:YPRH]PREUSR
      PSTOFCY(I)=[F:YPRH]STOFCY
      PPRHNUM(I)=[F:YPRH]PRHNUM
      PPRLNUM(I)=[F:YPRH]PRLNUM
      PBPCORD(I)=[F:YPRH]BPCORD
      PBPTNUM(I)=[F:YPRH]BPTNUM
    # Char PBPCNAM()()
      PDLVDAT(I)=num$([F:YPRH]SHIDAT)
      #razón social del cliente
      Read [F:YPBC]BPC0=[F:YPRH]BPCORD
      If !fstat Then
        PBPCNAM(I) = [F:YPBC]BPCNAM
      Endif
      #Buscamos el transportista
      If [F:YPRH]BPTNUM<>""
        Read [YBPT]BPT0=[F:YPRH]BPTNUM
        If !fstat Then
          PBPTDES(I) = [YBPT]BPTNAM
        Endif
      Endif
      PRES = '200'
      PMESS = 'OK'
      I+=1
      If I>LISTMAX Then
        Break
      Endif

    Next

  Close Local File [YPRH], [YPBC]

End

####################################################################
#**
#* Sub que duplica la tabla STOPRED
#*
#*!
Subprog AP_DUPSTOP (PPRHNUM)
 Variable Char PPRHNUM()

  If !clalev([YPRE]) Then : Local File STOPRED     [YPRE] : Endif
  If !clalev([YYPRE]) Then : Local File YSTOPRED      [YYPRE] : Endif

  Filter [F:YPRE] Where PRHNUM=PPRHNUM

  For [F:YPRE]
  #Infbox([F:YPRE]PRHNUM+ " " +num$([F:YPRE]PRELIN))
    [F:YYPRE]PRHNUM=[F:YPRE]PRHNUM
    [F:YYPRE]PRELIN=[F:YPRE]PRELIN
    [F:YYPRE]ITMREF=[F:YPRE]ITMREF
    [F:YYPRE]ITMDES1=[F:YPRE]ITMDES1
    [F:YYPRE]ORINUM=[F:YPRE]ORINUM
    [F:YYPRE]ORILIN=[F:YPRE]ORILIN
    [F:YYPRE]ORISEQ=[F:YPRE]ORISEQ
    [F:YYPRE]QTYSTU=[F:YPRE]QTYSTU
    [F:YYPRE]ALLQTY=[F:YPRE]ALLQTY
    Write [F:YYPRE]
  Next

End



#**
#*
#* APP. comprueba si hay cambios en las líneas del documento de preparación
#* @param PPRHNUM: DOCUMENTO de preparación
#* @param PRES
#* @param PMESS
#*!
Subprog TESTYTOPRE (PPRHNUM,  PRES, PMESS)
 Variable Char PPRHNUM()
 Variable Char PRES
 Variable Char  PMESS

#infbox("TESTYTOPRE")

  If !clalev([YPRE]) Then : Local File STOPRED     [YPRE] : Endif
  If !clalev([YYPRE]) Then : Local File YSTOPRED      [YYPRE] : Endif

  PRES="200"
  PMESS="Lectura información OK"

  #Si no hay lineas no hacems ningún control
 Filter [F:YYPRE] Where PRHNUM=PPRHNUM
 If rowcount([F:YYPRE]) > 0 Then
        #infbox("Existe el detall"-num$(rowcount([F:YYPRE])))
        #recorremos las líneas de la copia del detalle
        Filter [F:YYPRE] Where PRHNUM=PPRHNUM
        For [F:YYPRE]
          #infbox("Dentro YYPRE: " -[F:YYPRE]PRHNUM - num$([F:YYPRE]PRELIN))
          Read [F:YPRE]PRE0=[F:YYPRE]PRHNUM;[F:YYPRE]PRELIN
          If !fstat Then
            #infbox("Ha encontrado: " - [F:YPRE]PRHNUM- num$([F:YPRE]PRELIN))
            If [F:YYPRE]ITMREF<> [F:YPRE]ITMREF or
&               [F:YYPRE]ORINUM<>[F:YPRE]ORINUM or
&               [F:YYPRE]ORILIN<>[F:YPRE]ORILIN or
&               [F:YYPRE]QTYSTU<>[F:YPRE]QTYSTU or
&               [F:YYPRE]ALLQTY<>[F:YPRE]ALLQTY Then
                PRES="110"
                PMESS="Línea cambiada doc. prep.:" -  num$([F:YYPRE]ITMREF)
                Break
            Endif
          Else
            #infbox("NO Ha encontrado: " - [F:YYPRE]PRHNUM- num$([F:YPRE]PRELIN))
            PRES="100"
            PMESS="Linea borrada en doc. prep.:" -num$([F:YYPRE]ITMREF)
            Break
          Endif
        Next

       #recorremos las líneas que hay en  X3 para ver si alguna no está en la copia
        Filter [F:YPRE] Where PRHNUM=PPRHNUM
        For [F:YPRE]
          Read [F:YYPRE]PRE0=[F:YPRE]PRHNUM;[F:YPRE]PRELIN
          If fstat Then
            PRES="120"
            PMESS="Línea nueva doc. prep.:" - [F:YYPRE]ITMRE
            Break
          Endif
        Next

  Endif

  #infbox("A DUPLICAR")

  #Duplicamos o actualizamos
  Filter [F:YYPRE]Where PRHNUM=PPRHNUM
  For [F:YYPRE]
    Read  [F:YPRE]PRE0=[F:YYPRE]PRHNUM;[F:YYPRE]PRELIN
    If fstat  Then # si no la encuentra, la borramos
      #infbox( "BORRA "-[F:YYPRE]PRHNUM-[F:YYPRE]PRELIN )
      Delete [F:YYPRE]
    Endif
  Next

  #Duplicamos o actualizamos
  #infbox("VOY A DUPLICAR")
  Filter [F:YPRE]Where PRHNUM=PPRHNUM
  For [F:YPRE]
    #infbox("dUPLOCANDO O ACTUALIZANDO" - num$([F:YPRE]PRELIN))
    Read [F:YYPRE]PRE0=[F:YPRE]PRHNUM;[F:YPRE]PRELIN
    Trbegin [F:YYPRE]
    If !fstat Then
      [F:YYPRE]ITMREF=[F:YPRE]ITMREF
      [F:YYPRE]ITMDES1=[F:YPRE]ITMDES1
      [F:YYPRE]ORINUM=[F:YPRE]ORINUM
      [F:YYPRE]ORILIN=[F:YPRE]ORILIN
      [F:YYPRE]ORISEQ=[F:YPRE]ORISEQ
      [F:YYPRE]QTYSTU=[F:YPRE]QTYSTU
      [F:YYPRE]ALLQTY=[F:YPRE]ALLQTY
      Rewrite [F:YYPRE]
      If !fstat Then
      ##infbox("BIEN")
        Commit
      Else
        ##infbox("ERROR")
        Rollback
      Endif
    Else
      [F:YYPRE]PRHNUM=[F:YPRE]PRHNUM
      [F:YYPRE]PRELIN=[F:YPRE]PRELIN
      [F:YYPRE]ITMREF=[F:YPRE]ITMREF
      [F:YYPRE]ITMDES1=[F:YPRE]ITMDES1
      [F:YYPRE]ORINUM=[F:YPRE]ORINUM
      [F:YYPRE]ORILIN=[F:YPRE]ORILIN
      [F:YYPRE]ORISEQ=[F:YPRE]ORISEQ
      [F:YYPRE]QTYSTU=[F:YPRE]QTYSTU
      [F:YYPRE]ALLQTY=[F:YPRE]ALLQTY
      Write [F:YYPRE]
      If !fstat Then
      ##infbox("BIEN")
        Commit
      Else
        ##infbox("ERROR")
        Rollback
      Endif
    Endif
  Next

Close Local File [YPRE]
Close Local File [YYPRE]

End


####################################################################
#**
#* Sub que devuelve el detalle de la lista de preparación, de la copia que hacemos previamente
#* También devuelve si hay algún bulto no terminado de la lista de preparación
#* Si no hay ninguno, lo crea
#*
#*!
Subprog GETYSTOPRED(PPRHNUM , PPRELIN, PORINUM, PORILIN,  PITMREF, PITMDES1,  PQTYSTU, PYQTYSTU,  PALLQTY, PPENDIENTE, PPACNUM, PRES, PMESS)

  Variable Char PPRHNUM()
  Variable Integer PPRELIN()
  Variable Char PORINUM()()
  Variable Integer PORILIN()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Decimal PQTYSTU()
  Variable Decimal PYQTYSTU()
  Variable Decimal PALLQTY()
  Variable Decimal PPENDIENTE()
  Variable Char PPACNUM()
  Variable Char PRES
  Variable Char PMESS
  Local    Char PACNUM(30)
  Local Char PRES1(10)
  Local Char PMESS1(60)
  Local Char PCK(10)

  #infbox ("entro_"- PPRHNUM)
  #Primero duplicamos, por si hay alguna linea nueva
  #Call AP_DUPSTOP(PPRHNUM)
  PRES="800"
  PMESS="No hay artículos"
  Call TESTYTOPRE (PPRHNUM,  PRES, PMESS)
  #infbox ("salgo"- PPRHNUM)

  If !clalev([YYPR2]) Then : Local File YSTOPRED      [YYPR2] : Endif
  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

    Filter [F:YYPR2]
    Filter [F:YYPR2] Where PRHNUM=PPRHNUM Order By PRELIN

    For [F:YYPR2]
      #infbox (num$(I))
      #PPRHNUM(I)=[F:YYPR2]PRHNUM
      Read [F:YSOH]SOH0=[F:YYPR2]ORINUM
      If !fstat Then
        If [F:YSOH]CDTSTA=1 and [F:YSOH]HLDSTA=1 Then
          PPRELIN(I)=[F:YYPR2]PRELIN
          PORINUM(I)=[F:YYPR2]ORINUM
          PORILIN(I)=[F:YYPR2]ORILIN
          PITMREF(I)=[F:YYPR2]ITMREF
          PITMDES1(I)=[F:YYPR2]ITMDES1
          PQTYSTU(I)=[F:YYPR2]QTYSTU
          PYQTYSTU(I)=[F:YYPR2]YQTYSTU
          PALLQTY(I)=[F:YYPR2]ALLQTY
          PPENDIENTE(I)=[F:YYPR2]QTYSTU-[F:YYPR2]YQTYSTU
          I+=1
          If I>LISTMAX Then
            Break
          Endif
        Endif
      Endif
    Next

    #BUSCAMOS SI ESTA LISTA DE PREPARACIÓN TIENE ALGÚN BULTO sin TERMINAR
    PACNUM=""
    Filter [F:YSPH] Where VCRNUM=PPRHNUM and YCERRADO<>2
    For [F:YSPH]
      PACNUM=[F:YSPH]PACNUM
    Next
    #Si no hay ninguno, lo damos de alta
    PCK=""
    If PACNUM="" Then
        Call PUTNEWYSPACK(  PPRHNUM, PCK, PACNUM, PRES1, PMESS1)
    Endif

    PPACNUM=PACNUM

  Close Local File [YYPR2]
  Close Local File [YSPH]
  Close Local File [YSOH]

End


####################################################################
#**
#* Sub que comprueba el código de barras que se le pasa,
#* Comprueba que es válido para la lista de preparación.
#*
#* 1º Número de serie
#* 2º EAN
#* 3º Contenedor, LPN, para el caso del prepiking
#* Si es válido, rellena YQTYPCU
#* Devuelve el nº de Bulto, si no existe, lo crea
#*
#* PRES: 200, OK
#*
#* PMES: Mensaje con lo que ha hecho
#*!
Subprog PUTCONSUMO(PPRHNUM, PCODIGOBARRAS, PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PCODIGOBARRAS()
  Variable Char PPACNUM()
  Variable Char PRES
  Variable Char PMESS

  Local  Integer CANTIDAD
  Local Char INFNAM
  Local Char DESTINO
  Local Char PRELPN

  If !clalev([YYPRE]) Then : Local File YSTOPRED      [YYPRE] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER      [YITM] : Endif
  If !clalev([YSTO]) Then : Local File STOCK      [YSTO] : Endif
  If !clalev([YSTA]) Then : Local File STOALL      [YSTA] : Endif
  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif

    #Read [F:YSTO]STO4=LFCY;PUBICACION


    Call PARAM_YSPACKD(INFNAM, DESTINO, PRELPN)

    PRES="100"
    PMESS="No se encuentra"

    CANTIDAD=1


    #Testeamos si es un LPN, para ello debe empezar por "PP"
    If left$(PCODIGOBARRAS,2)=PRELPN Then
      PRES="160"
      PMESS="No existe la caja o ya se ha escaneado"
      Filter [F:YYPRE] Where PRHNUM=PPRHNUM Order By PRELIN
      For [F:YYPRE]
        Infbox("ANTES FILTRO "- [F:YYPRE]ITMREF-PCODIGOBARRAS )
        Filter [F:YSTO] Where  LPNNUM=PCODIGOBARRAS and ITMREF=[F:YYPRE]ITMREF
        For [F:YSTO]
            #Infbox("ENCONTRADO")
            If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
              #Infbox("ENTRA")
              Trbegin [F:YYPRE]
              CANTIDAD=[F:YSTO]QTYSTU
              [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+[F:YSTO]QTYSTU
              Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM,"", PCODIGOBARRAS) From YAPPLIB
              Rewrite [F:YYPRE]
              If !fstat Then
                #Infbox("BIEN")
                Commit
              Else
                #Infbox("ERROR")
                Rollback
              Endif
              PRES="200"
              PMESS="Correcto"
            Else
             # Infbox("NO SUMA")
             # PRES="150"
             # PMESS="Artículo totalmente recogido."
            Endif
        Next
      Next
    Else
        Infbox("No prepicking")
        Filter [F:YYPRE] Where PRHNUM=PPRHNUM Order By PRELIN
        For [F:YYPRE]
           #Numero de serie
          Read [F:YSTO]STO5=[F:YYPRE]ITMREF;PCODIGOBARRAS
          If !fstat Then
              Infbox("Existe numero de serie en STOCK")
              #Si está en stock, buscamos que esté asignada a esta preparación STOALL
              Filter [F:YSTA] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and ITMREF= [F:YYPRE]ITMREF and STOCOU=[F:YSTO]STOCOU
              For [F:YSTA]
                Infbox("Está asignado")
                #Por último tenemos que ver si el número de serie está en un bulto YPACKD
                PRES="200"
                PMES="Número de serie correcto"
                Filter [F:YSPD] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and SERNUM=PCODIGOBARRAS
                #Si existe, incorrecto
                For [F:YSPD]
                  Infbox("exite el bulto")
                  PRES="101"
                  PMES="Ya está utilizado el número de serie: " + PCODIGOBARRAS
                Next
                If PRES="200" Then
                  Infbox("damos el alta")
                  Trbegin [F:YYPRE]
                  [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                  Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM, PCODIGOBARRAS,"") From YAPPLIB
                  Rewrite [F:YYPRE]
                  If !fstat Then
                    Commit
                  Else
                    Rollback
                  Endif
                  PRES="200"
                  PMESS="Correcto"
                  Break
                Endif
              Next
          Endif

          If PRES <>"200" Then
            #segundo si el código EAN  existe
            #Infbox("NO Existe numero de serie")
            Read [YITM]ITM0=[F:YYPRE]ITMREF
            If !fstat Then
              # ean
              If [F:YITM]EANCOD=PCODIGOBARRAS
                If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
                  Trbegin [F:YYPRE]
                  [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                  Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM,"","") From YAPPLIB
                  Rewrite [F:YYPRE]
                  If !fstat Then
                    Commit
                  Else
                    Rollback
                  Endif
                  PRES="200"
                  PMESS="Correcto"
                  Break
                Else
                 # Infbox("NO SUMA")
                  PRES="150"
                  PMESS="Artículo " + [F:YYPRE]ITMREF - "totalmente recogido."
                  Break
                Endif
              Endif
            Endif      #EXISTE artículo
          Endif   #PRES INCORRECTO
    Next
  Endif #prepicking

  Close Local File [YYPRE]
  Close Local File [YITM]
  Close Local File [YSTO]
  Close Local File [YSTA]
  Close Local File [YSPD]

End


#**
#* GETLSSPACK
#* APP: devuelve   todos los bultos de una preparación, y sus líneas
#*
#*
#* @param PPRHNUM, preparación
#*
#* @param CAMPO1: campo izquierdo: BULTO: No bulto, LINEA: ref. artículo
#* @param CAMPO2: campo descripción: BULTO: peso, largo, ancho, alto, LINEA: descrip. artículo
#* @param CAMPO3: campo de cola, numérico: BULTO: vacio, LINEA: unidadeas de producto
#* @param TIPOCAMPO: "B" si es bulto. "L" si es la línea del producto.
#* @param PPACNUM
#* @param PPACIND
#* @param PITMREF
#* @param PITMDES1
#* @param PSERNUM
#* @param PQTYPCU
#* @param PPESONETO
#* @param PRES
#* @param PMESS
#*!
Subprog GETLSSPACK(PPRHNUM, PCAMPO1, PCAMPO2, PCAMPO3,  PTIPOCAMPO, PPACNUM , PPACIND, PITMREF, PITMDES1, PSERNUM,  PQTYPCU,  PRES, PMESS)

  Value Char PPRHNUM()
  Variable Char PCAMPO1()()
  Variable Char PCAMPO2()()
  Variable Char PCAMPO3()()
  Variable Char PTIPOCAMPO()()
  Variable Char PPACNUM()()
  Variable Integer PPACIND()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PSERNUM()()
  Variable Decimal PQTYPCU()
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO


  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0




  PRES = '100'
  PMESS = 'Problemas'

  #Filtramos todos los bultos de la preparacion
  Filter [F:YSPH] Where VCRNUM=PPRHNUM
    For [F:YSPH]
      PRES = '200'
      PMESS = 'OK'
      PCAMPO1(I)=[F:YSPH]PACNUM
      PCAMPO2(I)="Peso: " + num$([F:YSPH]YBRWEI) + "kg" + " Largo: "+ num$([F:YSPH]YPCKLEN)+ "cm Ancho: "+ num$([F:YSPH]YPCKWID)+"cm Alto: "+ num$([F:YSPH]YPCKHEI) +"cm"
      PCAMPO3(I)=""
      If [F:YSPH]YCERRADO=2 Then
        PTIPOCAMPO(I)="C"
      Else
        PTIPOCAMPO(I)="B"
      Endif
      #Filtramos todos los componentes de los bultos
      I+=1
      Filter [YSPD] Where PACNUM=[F:YSPH]PACNUM  Order By PACIND
      For [F:YSPD]
        #Campos que se verán en la rejilla

        PCAMPO1(I)=[F:YSPD]ITMREF
        PCAMPO2(I)=[F:YSPD]ITMDES1
        If [F:YSPD]SERNUM<>"" Then : PCAMPO2(I)+=" s/n: "+[F:YSPD]SERNUM: Endif
        PCAMPO3(I)= num$([F:YSPD]QTYPCU)
        PTIPOCAMPO(I)="D"
        #Campos que no se ven, pero pueden ser interesantes
        PPACNUM(I)=[F:YSPH]PACNUM
        PPACIND(I)=[F:YSPD]PACIND
        PITMREF(I)=[F:YSPD]ITMREF
        PITMDES1(I)=[F:YSPD]ITMDES1
        PSERNUM(I)=[F:YSPD]SERNUM
        PQTYPCU(I)=[F:YSPD]QTYPCU
        I+=1
        If I>LISTMAX Then
          Break
        Endif
      Next # De la línea de bulto YPACKD
  Next #Del bulto, YPACK
PPESONETO=PESONETO

  Close Local File [YSPD]
  Close Local File [YSPH]
End



####################################################################
#**
#* APP: Sub que devuelve el detalle del bulto que vamos a cerrar
#*
#*!
Subprog GETLISTYSPACKD(PPACNUM , PPACIND, PITMREF, PITMDES1, PSERNUM,  PQTYPCU, PPESONETO, PRES, PMESS)

  Variable Char PPACNUM()
  Variable Integer PPACIND()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PSERNUM()()
  Variable Decimal PQTYPCU()
  Variable Decimal PPESONETO
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO


  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER      [YITM] : Endif
  If !clalev([YTPK]) Then : Local File YTMPYPCKD      [YTPK] : Endif
  If !clalev([YTPK2]) Then : Local File YTMPYPCKD      [YTPK2] : Endif# If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0





  ## iNFBOX(LREQSQL)

    # Sin numero de serie

    PRES = '100'
    PMESS = 'Problemas'
    PESONETO=0


    # borramos la tabla temporal
    # iNFBOX("ANTES BORRAR")
    Filter [F:YTPK] Where PACNUM=PPACNUM
    For [F:YTPK]
      Delete [F:YTPK]
    Next

    # iNFBOX("DESPUES  BORRAR")
    #
    # Rellenamos la tabla temporal para que se agrupe en pantalla por
    #   1- Si numero de serie->número de serie
    #   2- Si viene de un LPN: LPN+ITMREF
    #   3- Si viene del código ean, por artículo
    #
    Filter [YSPD] Where PACNUM=PPACNUM  Order By PACIND
    For [F:YSPD]
      # iNFBOX (num$(I)-[F:YSPD]ITMREF-[F:YSPD]YLPNNUM-[F:YSPD]SERNUM)
      #SI VIENE DEL CÓDIGO EAN, POR ARTÍCULO
      Read [F:YTPK]YTPK0=PPACNUM;[F:YSPD]ITMREF;[F:YSPD]YLPNNUM;[F:YSPD]SERNUM
      Trbegin [F:YTPK]
      [F:YTPK]PACNUM=PPACNUM
      [F:YTPK]ITMREF=[F:YSPD]ITMREF
      [F:YTPK]SERNUM=[F:YSPD]SERNUM
      [F:YTPK]LPNNUM=[F:YSPD]YLPNNUM
      If !fstat Then
        # iNFBOX("lO ENCUENTRA: "-[F:YSPD]ITMREF-'SERNUM:'- [F:YSPD]SERNUM-'YLPNNUM:'-[F:YSPD]YLPNNUM-num$([F:YTPK]QTYPCU)-num$([F:YSPD]QTYPCU))
        [F:YTPK]QTYPCU= [F:YTPK]QTYPCU+[F:YSPD]QTYPCU
        Rewrite  [F:YTPK]
      Else
        # iNFBOX("NO LO ENCUENTRA: "-[F:YSPD]ITMREF-'SERNUM:'- [F:YSPD]SERNUM-'YLPNNUM:'-[F:YSPD]YLPNNUM-num$([F:YTPK]QTYPCU)-num$([F:YSPD]QTYPCU))
        [F:YTPK]ITMDES=[F:YSPD]ITMDES1
        [F:YTPK]QTYPCU=[F:YSPD]QTYPCU
        Write  [F:YTPK]
      Endif
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
      Read [F:YITM]ITM0=[F:YSPD]ITMREF
      If !fstat Then
        PESONETO = PESONETO +([F:YITM]ITMWEI*[F:YSPD]QTYPCU)
#        PESONETO = PESONETO + [F:YTIM]
      Endif
      I+=1
    Next

    I=0
    Filter [F:YTPK2] Where PACNUM=PPACNUM
    For [F:YTPK2]
      # iNFBOX (num$(I))
      #PPRHNUM(I)=[F:YSPD]PRHNUM
      PPACIND(I)=I
      PITMREF(I)= [F:YTPK2]ITMREF
      PITMDES1(I)=[F:YTPK2]ITMDES
      If [F:YTPK2]SERNUM<>"" or [F:YTPK2]LPNNUM<>"" Then
        If [F:YTPK2]SERNUM="" Then
          PSERNUM(I)="Caja:" - [F:YTPK2]LPNNUM
        Else
          PSERNUM(I)="N.Ser.:" - [F:YTPK2]SERNUM
        Endif
      Endif
#      If [F:YTPK2]SERNUM="" and [F:YTPK2]LPNNUM="" Then
#        PITMDES1(I)=[F:YTPK2]ITMDES
#      Else
#        If [F:YTPK2]SERNUM="" Then
#          PITMDES1(I)="Caja:" - [F:YTPK2]LPNNUM -[F:YTPK2]ITMDES
#        Else
#          PITMDES1(I)="N.Ser.:" - [F:YTPK2]SERNUM -[F:YTPK2]ITMDES
#        Endif
#      Endif
      PQTYPCU(I)=[F:YTPK2]QTYPCU
      PRES = '200'
      PMESS = 'OK'
      I+=1
      If I>LISTMAX Then
        Break
      Endif

    Next

PPESONETO=PESONETO

  Close Local File [YSPD]
  Close Local File [YITM]
  Close Local File [F:YTPK]
  Close Local File [F:YTPK2]
End


Subprog GETYPREBULT(PPRHNUM , PPRELIN, PORINUM, PORILIN,  PITMREF, PITMDES1,  PQTYSTU, PYQTYSTU,  PALLQTY, PYPACQTYSTU, PPENDBULTO, PPESONETO, PRES, PMESS)

  Variable Char PPRHNUM()
  Variable Integer PPRELIN()
  Variable Char PORINUM()()
  Variable Integer PORILIN()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Decimal PQTYSTU()
  Variable Decimal PYQTYSTU()
  Variable Decimal PALLQTY()
  Variable Decimal PYPACQTYSTU()
  Variable Decimal PPENDBULTO()
  Variable Decimal PPESONETO
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO



  #Primero duplicamos, por si hay alguna linea nueva
  Call AP_DUPSTOP(PPRHNUM)

  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER      [YITM] : Endif
 # If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

    #Read [F:YSTO]STO4=LFCY;PUBICACION
    #Filtramos por las cantidades pendientes de poner en un bulto
    Filter [F:YYPRE] Where PRHNUM=PPRHNUM and YPACQTYSTU < YQTYSTU Order By PRELIN

    PRES = '200'
    PMESS = 'Problemas'
    PESONETO=0

    For [F:YYPRE]
      #Infbox (num$(I))
      #PPRHNUM(I)=[F:YYPRE]PRHNUM
      PPRELIN(I)=[F:YYPRE]PRELIN
      PORINUM(I)=[F:YYPRE]ORINUM
      PORILIN(I)=[F:YYPRE]ORILIN
      PITMREF(I)=[F:YYPRE]ITMREF
      Read [F:YITM]ITM0=[F:YYPRE]ITMREF
      If !fstat Then
        PESONETO = PESONETO +([F:YITM]ITMWEI)*([F:YYPRE]YQTYSTU-[F:YYPRE]YPACQTYSTU)
#        PESONETO = PESONETO + [F:YTIM]
      Endif

      PITMDES1(I)=[F:YYPRE]ITMDES1
      PQTYSTU(I)=[F:YYPRE]QTYSTU
      PYQTYSTU(I)=[F:YYPRE]YQTYSTU
      PYPACQTYSTU(I)=[F:YYPRE]YPACQTYSTU
      PALLQTY(I)=[F:YYPRE]ALLQTY
      PPENDBULTO(I)=[F:YYPRE]YQTYSTU-[F:YYPRE]YPACQTYSTU
      PRES = '200'
      PMESS = 'OK'
      I+=1
      If I>LISTMAX Then
        Break
      Endif

    Next
    PPESONETO=PESONETO
  Close Local File [YYPRE]

End


####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*
#*!
Subprog GETLISTPACKAGE(PPCK, PLANDESSHO, PLBLFMT, PPCKWEI, PPCKLEN, PPCKWID,PPCKHEI , PRES, PMESS)

  Variable Char PPCK()()
  Variable Char PLANDESSHO()()
  Variable Char PLBLFMT()()
  Variable Decimal   PPCKWEI()
  Variable Decimal   PPCKLEN()
  Variable Decimal   PPCKWID()
  Variable Decimal   PPCKHEI()
  Variable Char PRES
  Variable Char PMESS

  Local Char TEMP(40)
  Local Integer POS
  Local Integer POS2
  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  If !clalev([YTPA]) Then : Local File TABPACKAGE      [YTPA] : Endif

    #Read [F:YSTO]STO4=LFCY;PUBICACION
    Filter [F:YTPA] Order By PCK

    For [F:YTPA]
      #Infbox (num$(I))
      #PPRHNUM(I)=[F:YTPA]PRHNUM
      PPCK(I)=[F:YTPA]PCK
      #Infbox([F:YTPA]LANDESSHO )
      POS=instr(1,[F:YTPA]LANDESSHO,"~")
      POS2=instr(POS+1,[F:YTPA]LANDESSHO,"~")
      #Infbox(num$(POS))
      #Infbox(num$(POS2))
      TEMP=mid$([F:YTPA]LANDESSHO, POS+1,POS2-POS-1 )
      #Infbox(TEMP)
      PLANDESSHO(I)=TEMP
      PLBLFMT(I)=[F:YTPA]LBLFMT
      PPCKWID(I)=[F:YTPA]PCKWID
      PPCKLEN(I)=[F:YTPA]PCKLEN
      PPCKHEI(I)=[F:YTPA]PCKHEI
      PPCKWEI(I)=[F:YTPA]PCKWEI
      PRES="200"
      PMESS="OK"
      I+=1
      If I>LISTMAX Then
        Break
      Endif

    Next

  Close Local File [F:YTPA]

End


####################################################################
#**
#* Sub que crea los registros en las tablas YPACK y YPACKD
#*
#* Se le pasa el número del listado de preparación y los datos del bulto, tamaño, peso, etc.
#* Devuelve el número de bulto
#*!

Subprog PUTYSPACK(  PPRHNUM, PPCK,  PLBLFMT, PNETWEI, PYBRWEI, PVOL,  PPCKWEI, PPCKLEN, PPCKWID, PPCKHEI , PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PPCK()
  Variable Char PLBLFMT()
  Variable Decimal PNETWEI
  Variable Decimal  PYBRWEI
  Variable Decimal PPCKWEI
  Variable Decimal PVOL
  Variable Decimal  PPCKLEN
  Variable Decimal PPCKWID
  Variable Decimal PPCKHEI
  Variable Char PPACNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif
  If !clalev([YYSPD]) Then : Local File YSPACKD      [YYSPD] : Endif
  If !clalev([YYPRE]) Then : Local File YSTOPRED      [YYPRE] : Endif

  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer STAT
  Local Char LCONTADOR

  Call NUMERO("YPAAP","11",date$,"",LCONTADOR,STAT) From SUBANM

  Infbox(LCONTADOR)

  Trbegin [YYSPH]
  [YYSPH]STOFCY="11"
  [YYSPH]CPY="1"
  [YYSPH]PACSEQ=1
  [YYSPH]VCRTYP=3
  [YYSPH]VCRNUM=PPRHNUM
  [YYSPH]PACNUM=LCONTADOR
  [YYSPH]PCK=PPCK
  [YYSPH]PCKWEI=PPCKWEI
  [YYSPH]NETWEI=PNETWEI
  [YYSPH]YBRWEI=PYBRWEI
  #[YYSPH]VOL=PVOL
  [YYSPH]LBLFMT=PLBLFMT
  [YYSPH]PCKWEI=PPCKLEN
  [YYSPH]NETWEI=PPCKWID
  [YYSPH]YBRWEI=PPCKHEI
  Write [YYSPH]
#  Infbox(num$(fstat))
  If !fstat Then
    Commit
  Else
    Rollback
    Close Local File [YYSPH]
    End
  Endif

  Local Integer I
 # If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  #Filtramos por las cantidades pendientes de poner en un bulto
  I=0
  Filter [F:YYPRE] Where PRHNUM=PPRHNUM and YPACQTYSTU < YQTYSTU Order By PRELIN
  For [F:YYPRE]
    I=I+1
    Trbegin [YYSPD]
    [YYSPD]STOFCY="11"
    [YYSPD]CPY="1"
    [YYSPD]PACSEQ=I
    [YYSPD]PACNUM=LCONTADOR
    [YYSPD]PCK=PPCK
    [YYSPD]ITMREF=[F:YYPRE]ITMREF
    [YYSPD]ITMDES1=[F:YYPRE]ITMDES1
    [YYSPD]QTYPCU=[F:YYPRE]YQTYSTU-[F:YYPRE]YPACQTYSTU
    Write [YYSPD]
    If !fstat Then
      Commit
    Else
      Rollback
    Endif
 Next

PPACNUM=LCONTADOR


  Close Local File [YYSPH]
  Close Local File [YYSPD]
  Close Local File [YYPRE]

End


####################################################################
#**
#* Sub que crea un registro de un bulto
#*
#* Se le pasa el número del listado de preparación y el tipo de embalaje
#* Devuelve el número de bulto
#*!

Subprog PUTNEWYSPACK(  PPRHNUM, PPCK, PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PPCK()
  Variable Char PPACNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif

  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer STAT
  Local Char LCONTADOR

  Call NUMERO("YPAAP","11",date$,"",LCONTADOR,STAT) From SUBANM

  Infbox(LCONTADOR)

  Trbegin [YYSPH]
  [YYSPH]STOFCY="11"
  [YYSPH]CPY="1"
  [YYSPH]PACSEQ=1
  [YYSPH]VCRTYP=3
  [YYSPH]VCRNUM=PPRHNUM
  [YYSPH]PACNUM=LCONTADOR
  [YYSPH]PCK=PPCK
  Write [YYSPH]
  #Infbox(num$(fstat))
  If !fstat Then
    Commit
    PRES="200"
    PMESS="OK"
  Else
    Rollback
    PRES="100"
    PMESS="Problema dando de alta el bulto"
    End
  Endif


PPACNUM=LCONTADOR


  Close Local File [YYSPH]

End


#**
#* RMSPACKDET
#* APP: borra una línea del empaquetado
#*
#* @param PPACNUM
#* @param PPACIND
#* @param PRES
#* @param PMESS
#*!
Subprog RMSPACKDET(PPACNUM,  PPACIND, PRES, PMESS)
  Value Char PPACNUM()
  Value  Integer PPACIND
  Variable Char PRES()
  Variable Char PMESS()


  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YPRE]) Then : Local File YSTOPRED      [YPRE] : Endif



  Read [F:YSPD]YSPD0= PPACNUM;PPACIND
  If !fstat Then
    Read  [F:YPRE]PRE0=[F:YSPD]VCRNUM;[F:YSPD]VCRLIN
    If !fstat Then
      [F:YPRE]YQTYSTU=[F:YPRE]YQTYSTU-[F:YSPD]QTYPCU
      Rewrite [F:YPRE]
      Delete [F:YSPD]
      #Si no quedan lineas borramos el paquete
      Filter [F:YSPD] Where PACNUM=PPACNUM
      If rowcount([F:YSPD])=0 Then
        Read [F:YSPH]YSPH0=PPACNUM
        If !fstat Then
          Delete [F:YSPH]
        Endif
      Endif
      PRES="200"
      PMESS="Borrado correcto"
    Else
      PRES="110"
      PMESS="No existe el documento de prep.: " + [F:YSPD]VCRNUM + ", linea: "+ num$([F:YSPD]VCRLIN)
    Endif
  Else
    PRES="100"
    PMESS="No existe el bulto: " + PPACNUM + ", linea: "+ num$(PPACIND)
  Endif




  Close Local File [YSPD]
  Close Local File [YSPH]

End

####################################################################
#**
#* Sub que crea los registros en las tablas YPACKD
#*
#* Se le pasa el número del listado de preparación, linea, cantidad  y el número de bulto
#* la cantidad normalmente será  1
#*!

Subprog PUTYSPACKDET(PPRHNUM, PPRELIN ,PQTYPCU, PPACNUM, PSERNUM, PLPNNUM)
  Value Char PPRHNUM()
  Value  Integer PPRELIN
  Value Integer PQTYPCU
  Value Char PPACNUM()
  Value Char PSERNUM()
  Value Char PLPNNUM()

  Local Integer I
  Local Integer NUM_LINEA

  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YPRE]) Then : Local File YSTOPRED      [YPRE] : Endif
  If !clalev([YCONT]) Then : Local File YSPACKD      [YCONT] : Endif



  #Filtramos por las cantidades pendientes de poner en un bulto
  I=0
  Filter [YCONT] Where VCRNUM=PPRHNUM
    If !fstat Then
      NUM_LINEA=rowcount([YCONT])+1
    Else
      NUM_LINEA=1
    Endif
  Filter [F:YPRE] Where PRHNUM=PPRHNUM and PRELIN =PPRELIN
  For [F:YPRE]
    I=I+1
    #Trbegin [YSPD]
    [YSPD]VCRNUM=PPRHNUM
    [YSPD]VCRLIN=PPRELIN
    [YSPD]STOFCY="11"
    [YSPD]CPY="1"
    [YSPD]VCRTYP=3
    [YSPD]PACSEQ=I
    [YSPD]PACNUM=PPACNUM
    [YSPD]PACIND=NUM_LINEA
    [YSPD]PCK=""
    [YSPD]ITMREF=[F:YPRE]ITMREF
    [YSPD]ITMDES1=[F:YPRE]ITMDES1
    [YSPD]QTYPCU=PQTYPCU
    If PSERNUM<>"" Then
      [YSPD]SERNUM=PSERNUM
    Endif
    If PLPNNUM<>"" Then
      [YSPD]YLPNNUM=PLPNNUM
    Endif
    Write [YSPD]
    If !fstat Then
    #  Commit
    Else
    #  Rollback
    Endif
  Next



  Close Local File [YSPD]
  Close Local File [YPRE]
  Close Local File [YCONT]

End

####################################################################
#**
#* Sub rellena los datos del bulto que faltan
#* lo da por terminado
#* imprime la etiqueta
#*
#*!
Subprog ENDYSPACKD(PPACNUM , PPCK,  PLBLFMT, PNETWEI, PBRWEI, PVOL,  PPCKWEI, PPCKLEN, PPCKWID, PPCKHEI ,  PRES, PMESS)

  Variable Char PPACNUM()
  Variable Char PPCK()
  Variable Char PLBLFMT()
  Variable Decimal PNETWEI
  Variable Decimal  PBRWEI
  Variable Decimal PPCKWEI
  Variable Decimal PVOL
  Variable Decimal  PPCKLEN
  Variable Decimal PPCKWID
  Variable Decimal PPCKHEI
  Variable Char PRES
  Variable Char PMESS

  Local Char INFNAM
  Local Char DESTINO
  Local Decimal  PESONETO
  Local Char PRELPN


  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif

  #
  # Vamos a escribir los datos de la cabecera
  #

  PRES="100"
  PMESS="No se encuentra el bulto/paquete"
  Filter [F:YSPH] Where PACNUM=PPACNUM
  For [F:YSPH]
    [F:YSPH]PCK=PPCK
    [F:YSPH]NETWEI=PNETWEI
    [F:YSPH]YBRWEI=PBRWEI
    [F:YSPH]YPCKHEI=PPCKHEI
    [F:YSPH]YPCKLEN=PPCKLEN
    [F:YSPH]YPCKWID=PPCKWID
    [F:YSPH]YPCKHEI=PPCKHEI
    [F:YSPH]VOL=PVOL
    [F:YSPH]YCERRADO=2 #CERRAMOS EL BULTO
    Rewrite [F:YSPH]

    Call PARAM_YSPACKD(INFNAM, DESTINO, PRELPN)
    #Infbox("->" +INFNAM+" " +DESTINO)
    Call IMPETIQSPACK(PPACNUM, INFNAM,DESTINO)
    PRES="200"
    PMESS="OK"

  Next

  Close Local File [YSPH]


End


Subprog IMPETIQSPACK(PPACNUM, PINFNAM, PDESTINO)
Value     Char    PINFNAM
Value     Char    PPACNUM
Value     Char    PDESTINO


 Local Char    TBPAR(20)(1..20)
  Local Char    TBVAL(20)(1..20)
  Local Integer LIMPFAC # estado impresión factura



 Raz TBPAR, TBVAL, LIMPFAC



#
#    # solo se lanza cuando son facturas.. (no abonos)
#    Filter [F:YTSV0] Where [F:YTSV0]SIVTYP = [F:YSIV0]SIVTYP
#    Read [F:YTSV0]TSV1 First
#    If !fstat Then
#      # solo facturas..
#      If [F:YTSV0]INVTYP = 1 Then
        # tipo de impresión a aplicar al informe..



       # parámetros del informe
        TBPAR(1)  = "Bulto"         : TBVAL(1)  = PPACNUM
        #TBPAR(15) = "repfin"          : TBVAL(15) = [F:YSIV0]REP



       # lanza el informe..
        Call ETAT(PINFNAM, PDESTINO, "SPA", 0, "", TBPAR, TBVAL) From AIMP3
        # MAB.18022020.NEW
        #Call ECR_TRACE("Factura " + [F:YSIV0]NUM + " enviada por correo electrónico", 0) From GESECRAN
End

########################################################
#**
#* Funcion que devuelve el valor de los parámetros para el informe y para el destino
#*!

Subprog PARAM_YSPACKD(PINFNAM, PDESTINO, PPRELPN)
Variable Char    PINFNAM
Variable Char    PDESTINO
Variable Char    PPRELPN

If !clalev([YTAB]) Then : Local File ATABDIV [YTAB] : Endif



 Filter [F:YTAB] Where NUMTAB = 6001
 # Call OUVRE_TRACE("Ejecución automatica SCADA") From LECFIC
  For [F:YTAB]
    Case [F:YTAB]A1
      When "ETIQUETABULTO"   :    PINFNAM=[F:YTAB]A2
      When "DESTINOBULTO"  :   PDESTINO=[F:YTAB]A2
      When "PRELPN"  :   PPRELPN=[F:YTAB]A2
    Endcase
  Next



 Close Local File [YTAB]

End



####################################################################
#**
#* Sub que devuelve de una preparación la lista de bustos no terminados
#*
#* Se le pasa el número del listado de preparación
#*!

Subprog GETSPACKLST(  PPRHNUM,  PPACNUM,  PRES, PMESS)
  Value Char PPRHNUM()
  Variable Char PPACNUM()()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif

  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer I
  I=0
  Local Integer STAT
  Filter [F:YYSPH] Where VCRNUM=PPRHNUM and YCERRADO=1
   # Call OUVRE_TRACE("Ejecución automatica SCADA") From LECFIC
    For [F:YYSPH]
      I=I+1
      PPACNUM(I)=[F:YYSPH]PACNUM
    Next
  PRES="200"
  PMESS="OK"




  Close Local File [YYSPH]

End


#**
#*
#* cambia el estado de la dcoumento  de preparación a "entregable"
#*
#*
#* @param PPRHNUM, lista de distribución
#* @param PRES , resultado del web servicr
#* @param PMESS, mensaje
#*!

Subprog PUTDLVFLG(  PPRHNUM,  PRES, PMESS)
  Value Char PPRHNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YPRH]) Then : Local File STOPREH      [YPRH] : Endif

  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer I
  I=0
  Local Integer STAT
  Read [F:YPRH]PRH0=PPRHNUM

  If !fstat Then
    Trbegin [F:YPRH]
    [F:YPRH]DLVFLG=2
    Rewrite [F:YPRH]
    #Infbox(num$(fstat))
    If !fstat Then
      Commit
      PRES="200"
      PMESS="OK"
    Else
      Rollback
      PRES="100"
      PMESS="Problema modificando entregable en: " +PPRHNUM
      End
    Endif
  Else
    PRES="150"
    PMESS="No existe: "+PPRHNUM
  Endif


  PRES="200"
  PMESS="OK"



  Close Local File [F:YPRH]

End

#**
#* Devuelve PRES=200 si el documento de preraparación está totalmente terminado
#*
#*!

Subprog GETTERMDOCPREP(  PPRHNUM,  PRES, PMESS)
  Value Char PPRHNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([F:YPRD]) Then : Local File YSTOPRED      [F:YPRD] : Endif

  PRES="200"
  PMESS="OK"
  Filter [F:YPRD] Where PRHNUM=PPRHNUM and PRELIN =PPRELIN
  For [F:YPRD]
    If [F:YPRD]QTYSTU<>[F:YPRD]YQTYSTU Then
      PRES="100"
      PMESS="No está todo servido"
    Endif
  Next
End


#
# Prepicking
#






#**
#* APP Devuelve la lista de pedidos que cumplen una serie de condiciones:
#* -Entre sus componentes hay líneas de prepicking
#* #*
#* @param PSOHNUM
#* @param PBPCORD
#* @param PBPCNAM
#* @param PDLVDATMIN, ATENCIÓN CAMBIADO A SHIDAT, aunque el nombre se mantenga
#* @param PORDSTA
#* @param PBPTNUM
#* @param PBPTNAM
#* @param PTCTRNUM
#* @param PRES
#* @param PMESS
#* @param PDVLDATDESDE,FILTROS CAMBIADO A SHIDAT
#* @param PDVLDATHASTA
#* @param PBPCORDDESDE
#* @param PBTNUMDESDE
#* @param PTSICOD0 FAMILIA ESTADÍSTICA 1, (tabla varia 20) corresponde a Familia Superior
#* @param PTSICOD1 FAMILIA ESTADÍSTICA 2, (tabla varia 21)  corresponde a Familia
#*!
Subprog GETLISTPEDIDOS(PSOHNUM, PBPCORD,  PBPCNAM,  PDLVDATMIN, PORDSTA,  PBPTNUM , PBPTNAM,  PTCTRNUM, PSHIDAT, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE, PTSICOD0, PTSICOD1)

  Variable Char PSOHNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PDLVDATMIN()()
  Variable Integer PORDSTA()
  Variable Char PBPTNUM()()
  Variable Char PBPTNAM()()
  Variable Char PTCTRNUM()()
  Variable Char PSHIDAT()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()
  Variable Char PBPCORDDESDE()
  Variable Char PBTNUMDESDE()
  Variable Char PTSICOD0()
  Variable Char PTSICOD1()


  Local    Char ESTADO

#  Local Char CRITERE(250)(19) : CRITERE(0) ="1=1"
#
#  If !clalev([F:YAO]) Then : Local File YAPPORDER     [F:YAO] : Endif
#
#  CRITERE(0)="1 = 1"
#
#  #fecha envío
#  If PDVLDATDESDE <> "" Then
#    CRITERE(1) += "&SHIDATMIN>=[" + (PDVLDATDESDE) + "]"
#  Endif
#  If PDVLDATHASTA <> "" Then
#    CRITERE(1) += "&SHIDATMIN<=[" + (PDVLDATHASTA) + "]"
#  Endif
# #Cliente
#  If PBPCORDDESDE <> "" Then
#    CRITERE(2) += "&BPCORD='" + PBPCORDDESDE + "'"
#  Endif
##transportista
#  If PBTNUMDESDE <> "" Then
#    CRITERE(3) += "&BPTNUM='" + PBTNUMDESDE + "'"
#  Endif
##Familia estadística 1, Familia superior
#  If PTSICOD0 <> "" Then
#    CRITERE(4) += "&TSICOD='" + PTSICOD + "'"
#  Endif
##Familia estadística 2, Familia
#  If PTSICOD0 <> "" Then
#    CRITERE(5) += "&TSICOD='" + PTSICOD + "'"
#  Endif
#
#   Infbox CRITERE


 Local Char LREQSQL(250)(14)
 Raz LREQSQL

  LREQSQL(0) =
&
& " SELECT P.SOHNUM_0, P.BPCORD_0, C.BPCNAM_0, MIN(D.SHIDAT_0) AS SHIDATMIN, P.ORDSTA_0, ISNULL(P.BPTNUM_0,'') As PBTNUM, ISNULL(CA.BPTNAM_0,'') As BPTNAM,'' As TCTRNUM,  D.SHIDAT_0"
  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN  " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
  LREQSQL(3) = " LEFT JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0"
  LREQSQL(4) = " LEFT JOIN " + nomap + ".LPN L ON L.LPNNUM_0=D.YLPNNUM_0"
  LREQSQL(5) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 AND D.ALLQTYSTU_0 > 0 AND ISNULL(L.PRTFLG_0,1)<>2"
  #fecha envío
  If PDVLDATDESDE <> "" Then
    LREQSQL(6) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
  Endif
  If PDVLDATHASTA <> "" Then
    LREQSQL(7) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
    Endif
   #Cliente
  If PBPCORDDESDE <> "" Then
    LREQSQL(8) += " AND P.BPCORD_0='" + PBPCORDDESDE + "'"
  Endif
  #transportista
  If PBTNUMDESDE <> "" Then
    LREQSQL(9) += " AND P.BPTNUM_0='" + PBTNUMDESDE + "'"
  Endif
  #Familia estadística 1, Familia superior
  If PTSICOD0 <> "" Then
    LREQSQL(10) += " AND A.TSICOD_0='" + PTSICOD0 + "'"
  Endif
  #Familia estadística 2, Familia
  If PTSICOD1 <> "" Then
    LREQSQL(11) += " AND A.TSICOD_1='" + PTSICOD1 + "'"
  Endif

  LREQSQL(12) += " GROUP By P.SOHNUM_0, P.BPCORD_0, C.BPCNAM_0, P.ORDSTA_0, ISNULL(P.BPTNUM_0,''),ISNULL(CA.BPTNAM_0,''),D.SHIDAT_0"


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I: I=0

#For I=0 To 11
#  Infbox(LREQSQL(I))
# Next
 I=0
  For (Char SOHNUM, Char BPCORD, Char BPCNAM, Date SHIDATMIN, Integer ORDSTA, Char BPTNUM, Char BPTNAM, Char TCTRNUM, Date SHIDAT) From '5' Sql LREQSQL(0..14) As [YAPP]
      ESTADO=""
      Call TESTESTADOPEDIDO([F:YAPP]SOHNUM, ESTADO, PRES, PMESS)
      If ESTADO<>"T" Then
        Infbox ("ESTADO" -[F:YAPP]SOHNUM-[F:YAPP]BPCNAM)
        PSOHNUM(I)=[F:YAPP]SOHNUM
        PBPCORD(I)=[F:YAPP]BPCORD
        PBPCNAM(I)=[F:YAPP]BPCNAM
        PDLVDATMIN(I)=num$([F:YAPP]SHIDATMIN)
        PORDSTA(I)=[F:YAPP]ORDSTA
        PBPTNUM(I)=[F:YAPP]BPTNUM
        PBPTNAM(I)=[F:YAPP]BPTNAM
        PTCTRNUM(I)=[F:YAPP]TCTRNUM
        PSHIDAT(I)=num$([F:YAPP]SHIDAT)
        PRES = '200'
        PMESS = 'OK'
        I+=1
        If I>LISTMAX Then
          Break
        Endif
      Endif

    Next


End


#**
#* Testea el estado de un pedido
#*
#* @param SOHNUM
#* @param ESTADO
#* ESTADO="T": TERMINADO
#* ESTADO="P": CAJA EN PROCESO
#* ESTADO="C": TODAS LA CAJAS TERMINADAS
#*!
Subprog TESTESTADOPEDIDO(PSOHNUM, PESTADO, PRES, PMESS)
  Variable Char PSOHNUM()
  Variable Char PESTADO()
  Variable Char PRES
  Variable Char PMESS


  Local Decimal CANTIDAD_ASIGNADA
  Local Decimal CANTIDAD_EN_PROCESO
  Local Decimal CANTIDAD_TERMINADA


If !clalev([YSOQ]) Then : Local File SORDERQ     [YSOQ] : Endif
If !clalev([YSTO]) Then : Local File STOCK       [YSTO] : Endif
If !clalev([YLPN]) Then : Local File LPN         [YLPN] : Endif

CANTIDAD_ASIGNADA=0
CANTIDAD_EN_PROCESO=0
CANTIDAD_TERMINADA=0

Filter [F:YSOQ] Where SOHNUM=PSOHNUM and SOQSTA <>3 and ALLQTYSTU > 0


For [F:YSOQ]
    CANTIDAD_ASIGNADA=CANTIDAD_ASIGNADA+[F:YSOQ]ALLQTY
    Filter [F:YLPN] Where ZSOHNUM=PSOHNUM
    For [F:YLPN]
      Filter[F:YSTO] Where LPNNUM= [F:YLPN]LPNNUM and STOFCY = '11' and ITMREF=[F:YSOQ]ITMREF
        For [F:YSTO]
          If !fstat Then
            If [F:YLPN]PRTFLG= 2 Then
               CANTIDAD_TERMINADA=CANTIDAD_TERMINADA+[F:YSTO]QTYPCU
            Else
               CANTIDAD_EN_PROCESO=CANTIDAD_EN_PROCESO+[F:YSTO]QTYPCU
            Endif

          Endif
       Next
  Next
Next

If CANTIDAD_TERMINADA=CANTIDAD_ASIGNADA Then
  PESTADO="T"
Else If CANTIDAD_EN_PROCESO > 0 Then
    PESTADO="P"
  Else
    PESTADO="C"
  Endif
Endif

Close Local File [YSOQ]
Close Local File [YSTO]
Close Local File [YLPN]

End

####################################################################
#**
#* APP devuelve la lista de clientes de un intervalo de pedidos filtrado por fecha
#*
#*!
Subprog GETLSCLPED(PBPCORD, PBPCNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(14)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0


    Raz LREQSQL

#    LREQSQL(0) = "Select P.BPCORD_0 "
#    LREQSQL(1) = " From "+nomap + ".SORDER P INNER JOIN "+nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 "
#    LREQSQL(2) = " Where  P.ORDSTA_0=1  and  D.EXTDLVDAT_0 >= '" + PDVLDATDESDE + "' and D.EXTDLVDAT_0 <= '" + PDVLDATHASTA + "'"
#    LREQSQL(3) = " GROUP BY P.BPCORD_0"
#    LREQSQL(4) = " ORDER BY P.BPCORD_0 ASC"

  LREQSQL(0) = " SELECT P.BPCORD_0, C.BPCNAM_0 "
  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN  " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
  LREQSQL(3) = " LEFT JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0"
  LREQSQL(4) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 AND D.ALLQTYSTU_0 > 0 "
  #fecha envío
  If PDVLDATDESDE <> "" Then
    LREQSQL(5) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
  Endif
  If PDVLDATHASTA <> "" Then
    LREQSQL(6) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
    Endif

#  #Familia estadística 1, Familia superior
#  If PTSICOD0 <> "" Then
#    LREQSQL(9) += " AND A.TSICOD_0='" + PTSICOD0 + "'"
#  Endif
#  #Familia estadística 2, Familia
#  If PTSICOD1 <> "" Then
#    LREQSQL(10) += " AND A.TSICOD_1='" + PTSICOD1 + "'"
#  Endif

  LREQSQL(11) += " GROUP By P.BPCORD_0, C.BPCNAM_0 "
  LREQSQL(12) += " ORDER By C.BPCNAM_0 ASC"


  #Infbox(LREQSQL)
  I=0
  For (Char BPCORD, Char BPCNAM) From '5' Sql LREQSQL(0..12) As [YAPP]
    #Infbox (num$(I)+ " " +[F:YAPP]BPCORD)
    PBPCORD(I)=[F:YAPP]BPCORD
    #razón social del cliente
    Infbox([F:YAPP]BPCNAM)
    PBPCNAM(I) = [F:YAPP]BPCNAM
    PRES = '200'
    PMESS = 'OK'
    I+=1
    If I>LISTMAX Then
      Break
    Endif

  Next





End


####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*APP devuelve la lista de tranport. de un intervalo de pedidos filtrado por fecha
#*!
Subprog GETLSTRPED(PBPTNUM, PBPTNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPTNUM()()
  Variable Char PBPTNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(14)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0




    Raz LREQSQL

#    LREQSQL(0) = "Select P.BPTNUM_0 "
#    LREQSQL(1) = " From "+nomap + ".SORDER P INNER JOIN "+nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 "
#    LREQSQL(2) = " Where  P.ORDSTA_0=1  and  D.EXTDLVDAT_0 >= '" + PDVLDATDESDE + "' and D.EXTDLVDAT_0 <= '" + PDVLDATHASTA + "'"
#    LREQSQL(3) = " GROUP BY P.BPTNUM_0"
#    LREQSQL(4) = " ORDER BY P.BPTNUM_0 ASC"



  LREQSQL(0) = " SELECT P.BPTNUM_0, CA.BPTNAM_0"
  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN  " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
  LREQSQL(3) = " INNER JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0"
  LREQSQL(4) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 AND D.ALLQTYSTU_0 > 0 "
  #fecha envío
  If PDVLDATDESDE <> "" Then
    LREQSQL(5) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
  Endif
  If PDVLDATHASTA <> "" Then
    LREQSQL(6) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
    Endif

#  #Familia estadística 1, Familia superior
#  If PTSICOD0 <> "" Then
#    LREQSQL(9) += " AND A.TSICOD_0='" + PTSICOD0 + "'"
#  Endif
#  #Familia estadística 2, Familia
#  If PTSICOD1 <> "" Then
#    LREQSQL(10) += " AND A.TSICOD_1='" + PTSICOD1 + "'"
#  Endif

  LREQSQL(11) += " GROUP By P.BPTNUM_0, CA.BPTNAM_0   "
  LREQSQL(12) += " ORDER By CA.BPTNAM_0  ASC"

#For I=0 To 12
#  Infbox (LREQSQL(I))
#Next


 #Infbox(LREQSQL)
  I=0
  For (Char BPTNUM, Char BPTNAM) From '5' Sql LREQSQL(0..13) As [YAPP]
    #Infbox (num$(I)+ " " +[F:YAPP]BPTNUM)
    If [F:YAPP]BPTNUM <>"" Then
        PBPTNUM(I)=[F:YAPP]BPTNUM
        #razón social del cliente
        PBPTNAM(I) = [F:YAPP]BPTNAM
        PRES = '200'
        PMESS = 'OK'
        I+=1
        If I>LISTMAX Then
          Break
        Endif
    Endif
  Next



End



#**
#*
#* APP Devuelve las líneas de un pedido para prepicking
#*
#* @param PSOHNUM: pedido
#* @param PSOPLIN
#* @param PITMREF
#* @param PITMDES
#* @param PLPNNUM
#* @param PQTY
#* @param PQTYLPN
#* @param PRES : resultado
#* @param PMESS
#*!
Subprog GETLSLIPED (PSOHNUM, PSHIDAT, PTSICOD0, PTSICOD1, PSOPLIN, PITMREF, PITMDES, PLPNNUM, PPRTFLG ,PQTY, PQTYLPN, PLPNNUM_USADO,PRES, PMESS  )
Value Char PSOHNUM()
Value Char PSHIDAT()
Value Char PTSICOD0()
Value Char PTSICOD1()
Variable Integer  PSOPLIN()
Variable Char  PITMREF()()
Variable Char   PITMDES()()
Variable Char   PLPNNUM()()
Variable Char   PPRTFLG()()
Variable Decimal PQTY()
Variable Decimal  PQTYLPN()
Variable Char   PLPNNUM_USADO()
Variable Char   PRES
Variable Char   PMESS()

Local Char EXISTE_LPN(1)

If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif
If !clalev([YSOQ]) Then : Local File SORDERQ     [YSOQ] : Endif
If !clalev([YSTO]) Then : Local File STOCK       [YSTO] : Endif
If !clalev([YLPN]) Then : Local File LPN         [YLPN] : Endif
If !clalev([YITM]) Then : Local File ITMMASTER   [YITM] : Endif
If !clalev([YITT]) Then : Local File YITMTECNICO [YITT] : Endif

PLPNNUM_USADO=""


Read [F:YSOH]SOH0=PSOHNUM
If !fstat Then
  If [F:YSOH]CDTSTA<>1 Then
    PRES="101"
    PMESS="No hay crédito"
    End
  Endif
  If [F:YSOH]HLDSTA<>1 Then
    PRES="102"
    PMESS="Bloqueado manualmente"
    End
  Endif
  If [F:YSOH]ORDSTA <>1 Then
    PRES="101"
    PMESS="Línea saldada"
    End
  Endif
Else
  PRES="100"
  PMESS="No existe el pedido"
    End
Endif



#Read [F:YSTO]STO4=LFCY;PUBICACION
#Infbox(PSHIDAT)
#Infbox("--------")
#Infbox(left$(PSHIDAT,2)- mid$(PSHIDAT,4,2)- right$(PSHIDAT,7))
#Infbox("1-------")
#Infbox(num$( gdat$(left$(PSHIDAT,2), mid$(PSHIDAT,4,2), right$(PSHIDAT,7))))
#Infbox("2-------")
Local Date DDD
DDD=gdat$(val(left$(PSHIDAT,2)), val(mid$(PSHIDAT,4,2)), val(right$(PSHIDAT,7)))
Filter [F:YSOQ] Where SOHNUM=PSOHNUM and SOQSTA <>3 and ALLQTYSTU > 0 and SHIDAT= DDD
PRES="150"
PMESS="Error leyendo información"
I=0
EXISTE_LPN="N"
For [F:YSOQ]
  Read [YITT]YITT0=[F:YSOQ]ITMREF
  If !fstat Then
     #Infbox("existe ITMT")
     If   [YITT]PREPICKING= 2 Then
       #Infbox("eS PREPICKING")
       Read [F:YITM]ITM0=[F:YSOQ]ITMREF
       If !fstat Then
         #Testeamos las familias que pasamos, pasen bien
         If PTSICOD0 = "" or PTSICOD0=[F:YITM]TSICOD(0)
           If PTSICOD1 = "" or PTSICOD0=[F:YITM]TSICOD(1)
             #Infbox("existe ITM")
              PSOPLIN(I)=[F:YSOQ]SOPLIN
              PITMREF(I)=[F:YITM]ITMREF
              PITMDES(I)=[F:YITM]ITMDES1
              PQTY(I)=[F:YSOQ]ALLQTYSTU
              PLPNNUM(I)=""
              PQTYLPN(I)=0
              Filter [F:YLPN] Where LPNNUM=[F:YSOQ]YLPNNUM
              For [F:YLPN]
#                Filter[F:YSTO] Where LPNNUM= [F:YLPN]LPNNUM and STOFCY = '11' and ITMREF=[F:YITM]ITMREF
#                  For [F:YSTO]
#                    If !fstat Then
                      #Infbox("Lo ha encontrado")
                      PLPNNUM(I)=[F:YLPN]LPNNUM
                      If [F:YLPN]PRTFLG<>2 Then
                        PPRTFLG(I)=""
                      Else
                        PPRTFLG(I)=" TERMINADA"
                      Endif
                      PQTYLPN(I)= PQTYLPN(I)+[F:YSOQ]YLPNQTY
                      If [F:YLPN]PRTFLG<>2 Then
                        EXISTE_LPN="S"
                        PLPNNUM_USADO=[F:YLPN]LPNNUM
                      Endif
#                    Else
#                      #Infbox("No lo ha encontrado")
#                    Endif
#                 Next
              Next
              I=I+1 # para que no salgan vacios
           Endif #familia estadística 1
        Endif #familia estadística 0
       Endif    #YITM
     Endif # PREPICKING
   Endif # YITT
  PRES="200"
  PMESS="OK"
Next

#Si no hay caja, la creamos
Local Char LPNNUM(20)
Local Char RES(20)
Local Char MENSAJE(100)

If EXISTE_LPN="N" and rowcount([F:YSOQ]) > 0 and PRES="200" Then
      Call GETLPNNUM(LPNNUM, RES, MENSAJE)
      If RES = "200" Then
        PLPNNUM_USADO=LPNNUM
      Else
        PRES=RES
        PMESS=MENSAJE
      Endif
Endif

Close Local File [YSOQ]
Close Local File [YSTO]
Close Local File [YLPN]
Close Local File [YITM]
Close Local File [YITT]
End


#**
#* APP: devuelve el número suigueinte del contador del LPN
#*!
Subprog GETLPNNUM(LPNNUM, PRES, PMESS  )
Variable Char LPNNUM
Variable Char   PRES
Variable Char   PMESS()
Local Char CONTADOR
Local Integer STAT



  If !clalev([YTCTR]) Then : Local File TABCONTAINER  [YTCTR] : Endif

  Read [F:YTCTR]TCTR0="PREPICKING"
  If !fstat Then
    CONTADOR = [F:YTCTR]LPNREFCOU
    PRES="200"
    PMESS="OK"
  Else
    CONTADOR = ""
    PRES="100"
    PMESS="NO HAY CONTADOR"
  Endif

  Call NUMERO(CONTADOR,"11",date$,"",LPNNUM,STAT) From SUBANM
End LPNNUM


#**
#* APP: Devuelve los parámetros para el prepicking
#*
#* @param PUBICPREPICKING
#* @param PTIPOUBICPREPICKING
#* @param PALMIOPRE
#*!
Subprog GETPARPREP(PUBICPREPICKING, PTIPOUBICPREPICKING, PALMIOPRE, PCONTENEDOR, PRES, PMESS)
Variable Char    PUBICPREPICKING
Variable Char    PTIPOUBICPREPICKING
Variable Char    PALMIOPRE
Variable Char    PCONTENEDOR
Variable Char    PRES
Variable Char   PMESS

If !clalev([YTAB]) Then : Local File ATABDIV [YTAB] : Endif



 Filter [F:YTAB] Where NUMTAB = 6001
 # Call OUVRE_TRACE("Ejecución automatica SCADA") From LECFIC
  For [F:YTAB]
    Case [F:YTAB]A1
      When "UBICPREPICKING"   :    PUBICPREPICKING=[F:YTAB]A2
      When "TIPOUBICPREPICKING"  :   PTIPOUBICPREPICKING=[F:YTAB]A2
      When "ALMIOPRE"  :   PALMIOPRE=[F:YTAB]A2
      When "CONTENEDOR"  :   PCONTENEDOR=[F:YTAB]A2
     Endcase
  Next


 Close Local File [YTAB]

PRES="200"
PMESS="OK"


End

#**
#* APP: busca si existe el LPN
#*
#* @param PLPNNUM
#* @param PRES
#* @param PMESS
#*!
Subprog TESTEALPN(PLPNNUM, PRES, PMESS)
  Variable Char PLPNNUM
  Variable Char PRES
  Variable Char  PMESS

  If !clalev([F:YLPN]) Then : Local File LPN  [F:YLPN] : Endif

  Read[F:YLPN]LPN0=PLPNNUM
  If !fstat Then
    PRES="200"
    PMESS="OK"
  Else
    PRES="100"
    PMESS="No existe"
  Endif

Close Local File [F:YLPN]

End



#**
#*
#* APP: Testea el código de barras del artículo y la cantidad pendiente
#*
#* @param SOHNUM
#* @param ITMREF
#* @param PCODIGOBARRAS
#* @param PLPNNUM: caja que le pasamos
#* @param PQTY: cantidad a dar de alta
#* @param PLPNNUMCAJ: caja en la que se encuentra.
#* @param PQTYSTUCAJ: cantidad para el artículo que ya está en la caja
#*
#* @param PRES :
#*  200_ ok, se da de alta
#*
#* @param PMESS
#*
#*
#*!
Subprog TESTPPCBAR(PSOHNUM, PSHIDAT, PTSICOD0, PTSICOD1, PCODIGOBARRAS, PLPNNUM, PQTY, PITMREF, PLPNNUMCAJ, PQTYSTUCAJ, PPCU, PSTU,PSTUCOE,   PVCRDES, PRES, PMESS)
 Value Char PSOHNUM()
 Value Char PSHIDAT()
 Value Char PTSICOD0()
 Value Char PTSICOD1()
 Value Char PCODIGOBARRAS()
 Value Char PLPNNUM
 Value Decimal PQTY
 Variable Char PITMREF()
 Variable Char PLPNNUMCAJ()
 Variable Decimal  PQTYSTUCAJ
 Variable Char PPCU()
 Variable Char PSTU()
 Variable Decimal PSTUCOE
 Variable Char PVCRDES()
 Variable Char  PRES()
 Variable Char   PMESS()


 Local  Integer CANTIDAD

  If !clalev([YSOQ]) Then : Local File SORDERQ          [YSOQ] : Endif
  If !clalev([YSOP]) Then : Local File SORDERP          [YSOP] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER        [YITM] : Endif
  If !clalev([YLPN]) Then : Local File LPN              [YLPN] : Endif
  If !clalev([F:YASLS]) Then : Local File YAPPSUMLPNST  [F:YASLS] : Endif




  #Leemos las líneas de producto agrupdas



    PRES="100"
    PMESS="No se encuentra"

    Local Char LREQSQL(250)(14)

    Raz LREQSQL

    LREQSQL(0) = "Select SOHNUM_0, SOPLIN_0, ITMREF_0, ALLQTYSTU_0 "
    LREQSQL(1) = " From "+nomap + ".SORDERQ "
    LREQSQL(2) = " Where SOHNUM_0='" +PSOHNUM+"'"
    LREQSQL(3) = " GROUP BY SOHNUM_0, SOPLIN_0, ITMREF_0"
    LREQSQL(4) = " ORDER BY SOPLIN_0 ASC"


 #Infbox(LREQSQL)
  I=0
  CANTIDAD=1
  Local Date DDD
  DDD=gdat$(val(left$(PSHIDAT,2)), val(mid$(PSHIDAT,4,2)), val(right$(PSHIDAT,7)))
  Filter [F:YSOQ] Where SOHNUM=PSOHNUM and SOQSTA <>3 and ALLQTYSTU > 0 and SHIDAT= DDD
For [F:YSOQ]
    #segundo si el código EAN  existe")
    Read [YITM]ITM0=[F:YSOQ]ITMREF
    If !fstat Then
      # Si cumple el requisito de las familias, salimos
       If PTSICOD0 = "" or PTSICOD0=[F:YITM]TSICOD(0)
         If PTSICOD1 = "" or PTSICOD0=[F:YITM]TSICOD(1)
          # ean, lo encontramos
            Infbox(PCODIGOBARRAS-"artículo: "- [F:YITM]EANCOD)
            If [F:YITM]EANCOD=PCODIGOBARRAS Then
              # Valores den SORDERQ
              Read [F:YSOP]SOP3=[F:YSOQ]SOHNUM;[F:YSOQ]SOPLIN
              If !fstat Then
               PPCU=[F:YSOP]SAU
               PSTU=[F:YSOP]STU
               PSTUCOE=[F:YSOP]SAUSTUCOE
               PVCRDES=left$([F:YSOQ]SOHNUM + ' ' +[F:YSOP]ITMDES1,80)
              Else
                PRES="110"
                PMESS="Problemas con el pedido"
                Break
              Endif
              PITMREF=[F:YITM]ITMREF
              #BUSCAMOS LA CANTIDAD EN TODAS LAS CAJAS, SI ES LA MISMA, SALIMOS
#              Read [F:YASLS]YSALS0=PSOHNUM; PITMREF
#              PQTYSTUCAJ=0
#              If !fstat
#                Infbox("La misma cantidad")
#                PQTYSTUCAJ=[F:YASLS]QTYCAJAS
#              Endif
#              Infbox("PQTYSTUCAJ "+num$(PQTYSTUCAJ)-"PQTy: "-num$(PQTY)- "asignado: " +num$([F:YSOQ]ALLQTYSTU))
              Infbox("CANTIDAD LINEA "+num$([F:YSOQ]YLPNQTY)-"PQTy: "-num$(PQTY)- "asignado: " +num$([F:YSOQ]ALLQTYSTU))
              If ([F:YSOQ]YLPNQTY+PQTY)>[F:YSOQ]ALLQTYSTU Then
                PRES="100"
                PMESS="No se puede poner más de lo que hay asignado."
                #Seguimos por si hay otro
              Else
                #en la linea de pedido, ponemos el LPN y la candidad
                If PLPNNUM<>"" Then
                  Read [F:YLPN]LPN0 =PLPNNUM
                  If !fstat Then
                    Infbox("Existe: " + PLPNNUM)
                    Trbegin [F:YSOQ]
                    [F:YSOQ]YLPNNUM=PLPNNUM
                    [F:YSOQ]YLPNQTY=PQTY+[F:YSOQ]YLPNQTY
                    Rewrite [F:YSOQ]
                    If !fstat Then
                      Commit
                      PRES="200"
                      PMESS="Grabada correctamente"
                      Break
                    Else
                      Rollback
                      PRES="120"
                      PMESS="No se puede grabar la caja"

                    Endif
                  Else
                    PRES="130"
                    PMESS="No existe la caja"
                  Endif
                Else
                    PRES="200"
                    PMESS="Correcto"
                Endif
                Break
              Endif
              Endif
         Endif #TSICOD1
       Endif  #TSICOD0
    Endif      #EXISTE artículo
Next



Close Local File [F:YITM]
Close Local File [F:YASLS]
Close Local File [YSOP]
Close Local File [YSOQ]
Close Local File [YLPN]





End

#Subprog TESTPPCBAR(PSOHNUM, PCODIGOBARRAS, PLPNNUM, PQTY, PITMREF, PLPNNUMCAJ, PQTYSTUCAJ, PPCU, PSTU,PSTUCOE,   PVCRDES, PRES, PMESS)
# Value Char PSOHNUM()
# Value Char PCODIGOBARRAS()
# Value Char PLPNNUM
# Value Decimal PQTY
# Variable Char PITMREF()
# Variable Char PLPNNUMCAJ()
# Variable Decimal  PQTYSTUCAJ
# Variable Char PPCU()
# Variable Char PSTU()
# Variable Decimal PSTUCOE
# Variable Char PVCRDES()
# Variable Char  PRES()
# Variable Char   PMESS()
#
#
# Local  Integer CANTIDAD
#
#  If !clalev([YSOQ]) Then : Local File SORDERQ          [YSOQ] : Endif
#  If !clalev([YSOP]) Then : Local File SORDERP          [YSOP] : Endif
#  If !clalev([YITM]) Then : Local File ITMMASTER        [YITM] : Endif
#  If !clalev([YLPN]) Then : Local File LPN              [YLPN] : Endif
#  If !clalev([F:YASLS]) Then : Local File YAPPSUMLPNST  [F:YASLS] : Endif
#
#
#
#    #Read [F:YSTO]STO4=LFCY;PUBICACION
#
#
# #Leemos las líneas de producto agrupdas
#
#
#    PRES="100"
#    PMESS="No se encuentra"
#
#    CANTIDAD=1
##    For [F:YSQQ]
##       #Numero de serie
##      Read [F:YSTO]STO5=[F:YYPRE]F:YSQQ;PCODIGOBARRAS
##      If !fstat Then
##          Infbox("Existe numero de serie en STOCK")
##          #Si está en stock, buscamos que esté asignada a esta preparación STOALL
##          Filter [F:YSTA] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and ITMREF= [F:YYPRE]ITMREF and STOCOU=[F:YSTO]STOCOU
##          For [F:YSTA]
##            Infbox("Está asignado")
##            #Por último tenemos que ver si el número de serie está en un bulto YPACKD
##            PRES="200"
##            PMES="Número de serie correcto"
##            Filter [F:YSPD] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and SERNUM=PCODIGOBARRAS
##            #Si existe, incorrecto
##            For [F:YSPD]
##              Infbox("exite el bulto")
##              PRES="101"
##              PMES="Ya está utilizado el número de serie: " + PCODIGOBARRAS
##            Next
##            If PRES="200" Then
##              Infbox("damos el alta")
##              Trbegin [F:YYPRE]
##              [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+1
##              Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM, PCODIGOBARRAS) From YAPPLIB
##              Rewrite [F:YYPRE]
##              If !fstat Then
##                Commit
##              Else
##                Rollback
##              Endif
##              PRES="200"
##              PMESS="Correcto"
##              Break
##            Endif
##          Next
##      Endif
#    Filter [F:YSOQ] Where SOHNUM = PSOHNUM Order By SOPLIN
#      For [F:YSOQ]
#        #segundo si el código EAN  existe")
#        Read [YITM]ITM0=[F:YSOQ]ITMREF
#        If !fstat Then
#          # ean, lo encontramos
#          Infbox(PCODIGOBARRAS-"artículo: "- [F:YITM]EANCOD)
#          If [F:YITM]EANCOD=PCODIGOBARRAS Then
#            # Valores den SORDERQ
#            Read [F:YSOP]SOP3=[F:YSOQ]SOHNUM;[F:YSOQ]SOPLIN
#            If !fstat Then
#             PPCU=[F:YSOP]SAU
#             PSTU=[F:YSOP]STU
#             PSTUCOE=[F:YSOP]SAUSTUCOE
#             PVCRDES=left$([F:YSOQ]SOHNUM + ' ' +[F:YSOP]ITMDES1,80)
#            Else
#              PRES="110"
#              PMESS="Problemas con el pedido"
#              Break
#            Endif
#            PITMREF=[F:YITM]ITMREF
#            #BUSCAMOS LA CANTIDAD EN TODAS LAS CAJAS, SI ES LA MISMA, SALIMOS
#            Read [F:YASLS]YSALS0=PSOHNUM; PITMREF
#            PQTYSTUCAJ=0
#            If !fstat
#              Infbox("La misma cantidad")
#              PQTYSTUCAJ=[F:YASLS]QTYCAJAS
#            Endif
#            Infbox("PQTYSTUCAJ "+num$(PQTYSTUCAJ)-"PQTy: "-num$(PQTY)- "asignado: " +num$([F:YSOQ]ALLQTYSTU))
#            If (PQTYSTUCAJ+PQTY)>[F:YSOQ]ALLQTYSTU Then
#              PRES="100"
#              PMESS="No se puede poner más de lo que hay asignado"
#              Break
#              #Seguimos por si hay otro
#            Else
#              #en la caja ponemos el pedido
#              If PLPNNUM<>"" Then
#                Read [F:YLPN]LPN0 =PLPNNUM
#                If !fstat Then
#                  Infbox("Existe: " + PLPNNUM)
#                  Trbegin [F:YLPN]
#                  [F:YLPN]ZSOHNUM=PSOHNUM
#                 # [F:YLPN]ZSOPLIN=[F:YSOQ]SOPLIN
#                  Rewrite [F:YLPN]
#                  If !fstat Then
#                    Commit
#                    PRES="200"
#                    PMESS="Grabada correctamente"
#                    Break
#                  Else
#                    Rollback
#                    PRES="120"
#                    PMESS="No se puede grabar la caja"
#
#                  Endif
#                Else
#                  PRES="130"
#                  PMESS="No existe la caja"
#                Endif
#              Else
#                  PRES="200"
#                  PMESS="Correcto"
#              Endif
#              Break
#            Endif
#            Endif
#        Endif      #EXISTE artículo
#    Next
#
#
#
#Close Local File [F:YSOQ]
#Close Local File [F:YITM]
#Close Local File [F:YASLS]
#Close Local File [YSOP]
#Close Local File [YLPN]
#
#
#
#
#
#End


#**
#*
#* APP. Imprime la etiqueta del contenedot (LPN)y pone la marca de impreso
#*
#* @param PLPNNUM
#* @param PRES
#* @param PMESS
#*!
Subprog ENDLPN(  PLPNNUM,  PRES, PMESS)
  Value Char PLPNNUM()
  Variable Char PRES()
  Variable Char PMESS()


Local Char    INFNAM(30)
Local Char    PACNUM(30)
Local Char    DESTINO(30)
Local Char    TCTRNUM(30)
Local Char    TBVAL(20)(1..20)
Local Char    TBPAR(20)(1..20)
Local Integer LIMPFAC # estado impresión factura


  If !clalev([YLPN]) Then : Local File LPN      [YLPN] : Endif
  If !clalev([YTCTR]) Then : Local File TABCONTAINER      [YTCTR] : Endif
  #
  # Buscamos el contador para el nuevo bulto
  #


  Local Integer I
  I=0
  Local Integer STAT

  Read [F:YLPN]LPN0=PLPNNUM
  If !fstat Then
    Read [F:YTCTR]TCTR0=[F:YLPN]TCTRNUM
    If !fstat Then
        INFNAM=[F:YTCTR]LBEFMT
    Else
      PRES="100"
      PMESS="No está definida etiqueta"
      End
    Endif
  Else
      PRES="110"
      PMESS="No se encuentra la caja"
      End
  Endif


#imprimimos
 Raz TBPAR, TBVAL, LIMPFAC


        Infbox(PLPNNUM)
#        TBPAR(1)  = "usr"           : TBVAL(1)  = GUSER
#        TBPAR(2)  = "etat"          : TBVAL(2)  = INFNAM
        TBPAR(3)  = "numedt"        : TBVAL(3)  = PLPNNUM
        #TBPAR(15) = "repfin"          : TBVAL(15) = [F:YSIV0]REP



       # lanza el informe..
       DESTINO=""
        Call ETAT(INFNAM, DESTINO, "SPA", 0, "", TBPAR, TBVAL) From AIMP3
        # MAB.18022020.NEW
        #Call ECR_TRACE("Factura " + [F:YSIV0]NUM + " enviada por correo electrónico", 0) From GESECRAN


    Trbegin [F:YLPN]
    [F:YLPN]PRTFLG=2
    Rewrite [F:YLPN]
    #Infbox(num$(fstat))
    If !fstat Then
      Commit
      PRES="200"
      PMESS="OK"
    Else
      Rollback
      PRES="100"
      PMESS="Problema modificando impriso en: " + PLPNNUM
      End
    Endif



  Close Local File [F:YLPN]
  Close Local File [F:YTCTR]

End


#######################################################################################
# Común a las preparación y al prepicking
######################################################################################

#**
#* Devuelve el código y la descripción de la familia que se pasa
#*
#* @param PNUMTAB, código de la familia a recoger
#* @param PCODE
#* @param PLNGDES
#* @param PRES
#* @param PMESS
#*!
Subprog GETFAMEST(PNUMTAB, PCODE, PLNGDES, PRES, PMESS)
  Value Integer PNUMTAB
  Variable Char PCODE()()
  Variable Char PLNGDES()()
  Variable Char PRES
  Variable Char PMESS


 If !clalev([F:YADI]) Then : Local File  ATABDIV     [F:YADI] : Endif
  #
  # Buscamos el contador para el nuevo bulto
  #


  Local Integer I
  I=0

 Filter [F:YADI] Where NUMTAB=PNUMTAB Order By CODE Asc
 # Call OUVRE_TRACE("Ejecución automatica SCADA") From LECFIC
  For [F:YADI]
    PCODE(I)=[F:YADI]CODE
    PLNGDES(I)=func AFNC.TEXTRA("ATABDIV","LNGDES", num$(PNUMTAB),[F:YADI]CODE)
    Infbox(PCODE(I)+PLNGDES(I))
    I=I+1
  Next


PRES="200"
PMESS="Lectura correcta"
  Close Local File [YADI]

End




#
#Subprog OPEN_FILE(LFILE)
#  Variable Char LFILE()
#  adxifs = ";"
#  adxirs = chr$(13)+chr$(10)
#  Openo LFILE
#  # Iomode adxium (50)
#End
#
#
##**
##* Da de alta el LPN mediante el modelo e/i: YLPNS
##*
##* @param PLPNNUM
##*!
#Subprog ALTALPN(PLPNNUM)
#Variable Char PLPNNUM()
#
#  Local Char LFILE(250)
#  Local Char FECHA(250),HORA(250)
#  Local Char PATHFILE(250)
#  Local Integer LCONT : LCONT = 0
#  Local Char    PUBICPREPICKING(20)
#  Local Char    PTIPOUBICPREPICKING(20)
#  Local Char    PALMIOPRE(20)
#  Local Char    PCONTENEDOR(20)
#  Local Char LMFG(40)(1..20)
#  Local Char PRES(20)
#  Local Char PMESS(100)
#
#  Call PARAM_PREPICKING(PUBICPREPICKING, PTIPOUBICPREPICKING, PALMIOPRE,PCONTENEDOR)
#
#
#  If PLPNNUM="" Then
#    Call GETLPNNUM(PLPNNUM, PRES, PMESS  )
#  Endif
#  Infbox(PLPNNUM)
#
#  FECHA = vireblc(num$(date$),4) : FECHA = mid$(FECHA,1,2)+mid$(FECHA,4,2)+mid$(FECHA,7,4)
#  HORA = vireblc(num$(time$),4) : HORA = mid$(HORA,1,2)+mid$(HORA,4,2)+mid$(HORA,7,4)
#  PATHFILE = filpath("",PALMIOPRE,"")
#  LID = PLPNNUM+"_"+FECHA+"_"+HORA+"_"+GUSER
#  LFILE = PATHFILE + "\ALTALPN_" + PLPNNUM + "_" + FECHA + "_" + HORA + ".txt"
#  Infbox(LFILE)
#
#  Call OPEN_FILE(LFILE)
#
#  LMFG(1) = PLPNNUM
#  LMFG(2) = "11"
#  LMFG(3) = PCONTENEDOR
#  LMFG(4) = PUBICPREPICKING
#  LMFG(5) = "2"
#  LMFG(6) = "1"
#  LMFG(7) = "1"
#  LMFG(8) = ""
#  LMFG(9) = PTIPOUBICPREPICKING
#
#
#  Wrseq LMFG(1), LMFG(2), LMFG(3), LMFG(4), LMFG(5), LMFG(6), LMFG(7), LMFG(8), LMFG(9)
#  Openo
#
#End
#
#
##**
##* APP: Da de alta la operación de LPN,
##* 1º da de alta el contenedor si no existe
##* 2º da de alta la operación
##*
##* @param PLPNNUM
##* @param PIPTDAT
##* @param PSOHNUM
##* @param PSOPLIN
##* @param PTIMREF
##* @param PQTYPCU
##* @param PQTYSTU
##* @param PSERNUM
##* @param PRES
##* @param PMESS
##*!
#Subprog PUTLPNOPE (PLPNNUM, PIPTDAT, PSOHNUM, PSOPLIN, PTIMREF, PQTYPCU, PQTYSTU, PSERNUM, PRES, PMESS)
#Variable Char PLPNNUM()
#Variable Char PIPTDAT()
#Variable Char PSOHNUM()
#Variable Char PSOPLIN()
#Variable Char PTIMREF()
#Variable Char PQTYPCU()
#Variable Char PQTYSTU()
#Variable Char PSERNUM()
#Variable Char PRES()
#Variable Char PMESS()
#
#
#If !clalev([F:YLPN]) Then : Local File LPN  [F:YLPN] : Endif
#
#Read[F:YLPN]LPN0=PLPNNUM
#If fstat Then
#  Call ALTALPN(PLPNNUM)
#
#Endif
#
#End
