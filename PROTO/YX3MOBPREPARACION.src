#<AdxTL>@(#)0.0.0.0 $Revision$
#<AdxTL>@(#)0.0.0.0 $Revision$
#################################################################################################################
#
# @01@ - SCD - 25/06/2024 - Ajuste para el campo YESTADOPREP
# @02@ - JMF - 15/07/2024 - Gestión de nuevos campos transportista para la generación y envío de entregas
# @03@ - EQM - 07/08/2024 - Gestión para guardar NPALET en YSPACK
# @04@ - VEG - 11/11/2024 - Función de impresión documentos de preparación
#
#################################################################################################################
####################################################################
#**
#* Sub que devuelve los clientes de la lista de preparción en curso
#*
#*!
Subprog GETLISTCLIENTEPREP(PDVLDATDESDE, PDVLDATHASTA, QUERY, COD_CLIENTE, NOMBRE_CLIENTE)
  # Entrada
  Value Char PDVLDATDESDE()
  Value Char PDVLDATHASTA()
  Value Char QUERY()
  # Salida
  Variable Char COD_CLIENTE()()
  Variable Char NOMBRE_CLIENTE()()

  Local Char LREQSQL(250)(5)

  Local Integer I : I = 0

  If !clalev([YPBC]) Then : Local File BPCUSTOMER      [YPBC] : Endif
  If !clalev([YPBR]) Then : Local File BPARTNER        [YPBR] : Endif

  Raz LREQSQL

  LREQSQL(0) = "Select BPCORD_0 "
  LREQSQL(1) = " From "+nomap + ".STOPREH "
  LREQSQL(2) = " Where DLVFLG_0 = 1  and  SHIDAT_0 >= '" + PDVLDATDESDE + "' and SHIDAT_0 <= '" + PDVLDATHASTA + "'"
  LREQSQL(3) = " GROUP BY BPCORD_0"
  LREQSQL(4) = " ORDER BY BPCORD_0 ASC"

  For (Char BPCORD) From '5' Sql LREQSQL As [YAPP]
    Read [YPBR]BPR0=[F:YAPP]BPCORD
    If !fstat Then
      If QUERY = '' Then
        COD_CLIENTE(I)=[F:YAPP]BPCORD
        NOMBRE_CLIENTE(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)

        I+=1
      Else
        If instr(1, toupper([YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)), toupper(QUERY)) > 0
          COD_CLIENTE(I)=[F:YAPP]BPCORD
          NOMBRE_CLIENTE(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)

          I+=1
        Endif
      Endif
    Endif
  Next

  Close Local File [YPBC]
  Close Local File [YPBR]
End

####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*
#*!
Subprog GETLISTTRANSPREP(PDVLDATDESDE, PDVLDATHASTA, QUERY, COD_TRANSPORTISTA, TRANSPORTISTA)
  # Entrada
  Value Char PDVLDATDESDE()
  Value Char PDVLDATHASTA()
  Value Char QUERY()
  # Salida
  Variable Char COD_TRANSPORTISTA()()
  Variable Char TRANSPORTISTA()()

  Local Char LREQSQL(250)(5) : Raz LREQSQL
  Local Integer I : I = 0

  If !clalev([YBPT]) Then : Local File BPCARRIER [YBPT] : Endif

  LREQSQL(0) = "Select BPTNUM_0 "
  LREQSQL(1) = " From "+nomap + ".STOPREH "
  LREQSQL(2) = " Where DLVFLG_0 = 1  and  SHIDAT_0 >= '" + PDVLDATDESDE + "' and SHIDAT_0 <= '" + PDVLDATHASTA + "' and BPTNUM_0<>''"
  LREQSQL(3) = " GROUP BY BPTNUM_0"
  LREQSQL(4) = " ORDER BY BPTNUM_0 ASC"

  For (Char BPTNUM) From '5' Sql LREQSQL As [YAPP]
    Read [F:YBPT]BPT0=[F:YAPP]BPTNUM
    If !fstat Then
      If QUERY = "" Then
        COD_TRANSPORTISTA(I)=[F:YAPP]BPTNUM
        TRANSPORTISTA(I) = [F:YBPT]BPTNAM

        I+=1
      Else
        If instr(1, toupper([F:YBPT]BPTNAM), toupper(QUERY)) > 0 Then
          COD_TRANSPORTISTA(I)=[F:YAPP]BPTNUM
          TRANSPORTISTA(I) = [F:YBPT]BPTNAM

          I+=1
        Endif
      Endif
    Endif
  Next

  Close Local File [YBPT]
End

####################################################################
#**
#* Sub que devuelve las listas de preparación en curso
#*
#*!
Subprog GETDOCUMENTOSPREPARACION(PCOD_PLANTA, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE, PPRHNUM , PPREUSR, PPRLNUM,  PBPCORD, PBPCNAM,  PBPTNUM, PBPTDES, PDLVDAT, BLOQUEADO)
  # Entrada
  Value Char PCOD_PLANTA()
  Value Char PDVLDATDESDE()
  Value Char PDVLDATHASTA()
  Value Char PBPCORDDESDE()
  Value Char PBTNUMDESDE()
  # Salida
  Variable Char PPRHNUM()()
  Variable Char PPREUSR()()
  Variable Char PPRLNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PBPTNUM()()
  Variable Char PBPTDES()()
  Variable Char PDLVDAT()()
  Variable Integer BLOQUEADO()

  Local Char CRITERE(250)(4)
  Local Integer ESTADO : Raz ESTADO
  Local Integer I : I = 0

  If !clalev([YPRH]) Then : Local File STOPREH     [YPRH] : Endif
  If !clalev([YPBC]) Then : Local File BPCUSTOMER  [YPBC] : Endif
  If !clalev([YBPT]) Then : Local File BPCARRIER   [YBPT] : Endif
  If !clalev([YPBR]) Then : Local File BPARTNER    [YPBR] : Endif

  Raz CRITERE

  CRITERE(0)="[YPRH]DLVFLG = 1 & [YPRH]STOFCY = '" + PCOD_PLANTA + "'"

  If PDVLDATDESDE <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT>=[" + (PDVLDATDESDE) + "]"
  Endif
  If PDVLDATHASTA <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT<=[" + (PDVLDATHASTA) + "]"
  Endif
  If PBPCORDDESDE <> "" Then
    CRITERE(2) += " & [YPRH]BPCORD='" + PBPCORDDESDE + "'"
  Endif
  If PBTNUMDESDE <> "" Then
    CRITERE(3) += " & [YPRH]BPTNUM='" + PBTNUMDESDE + "'"
  Endif

  Filter [F:YPRH] Where evalue(CRITERE)

  For [F:YPRH]
    ESTADO = func SPEPRH.ESTADO_VALE([F:YPRH]PRHNUM)
    If ESTADO <> 3
      PPRHNUM(I)=[F:YPRH]PRHNUM
      PPREUSR(I)=[F:YPRH]PREUSR
      PPRLNUM(I)=[F:YPRH]PRLNUM
      PBPCORD(I)=[F:YPRH]BPCORD
      PBPTNUM(I)=[F:YPRH]BPTNUM
      PDLVDAT(I)=num$([F:YPRH]SHIDAT)
      Read [YPBR]BPR0=[F:YPRH]BPCORD
      If !fstat Then
        PBPCNAM(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)
      Endif
      If [F:YPRH]BPTNUM<>""
        Read [YBPT]BPT0=[F:YPRH]BPTNUM
        If !fstat Then
          PBPTDES(I) = [YBPT]BPTNAM
        Endif
      Endif
      BLOQUEADO(I) = [YPRH]YAPPWIP
      I+=1
    Endif

    Next

  Close Local File [YPRH], [YPBC], [YPBR]
End

##########################################################
#**
#*Estado de empaquetamiento del vale de preparación
#*
#* @param PPRHNUM
#*!
Funprog ESTADO_VALE(PPRHNUM)
Value Char    PPRHNUM

Local Integer ZEST
Local Integer CONT_TOTAL
Local Integer EN_CURSO

If !clalev([YP01]) Then : Local File YSPACK   [YP01] : Endif
If !clalev([YP02]) Then : Local File STOPRED  [YP02] : Endif

For [YP01] Where [YP01]VCRNUM = PPRHNUM
  [L]CONT_TOTAL += 1
Next

If [L]CONT_TOTAL = 0
  ZEST = 1 # Estado = En Espera
Else
  Filter [YP02] Where [YP02]PRHNUM = PPRHNUM Order By [YP02]PRELIN Asc
    For [YP02]
      If [YP02]YQTYSTU < [YP02]QTYSTU
        [L]EN_CURSO = 2
        Break
      Endif
    Next
  Filter [YP02]

  If [L]EN_CURSO = 2
    ZEST = 2 # Estado = En Curso
  Else
    ZEST = 3 # Estado = Preparado
  Endif
Endif


Close Local File [YP01]
Close Local File [YP02]
End ZEST

Subprog PREPCONTROLWIP(COD_PREPARACION, ESTADO, USUARIO)
  # Entrada
  Value Char COD_PREPARACION
  # Salida
  Variable Integer ESTADO
  Variable Char USUARIO

  ESTADO = -1

  If !clalev([SPH]) : Local File STOPREH [SPH] : Endif

  Read [SPH]PRH0 = COD_PREPARACION
  If !fstat Then
    ESTADO = [SPH]YAPPWIP
    USUARIO = [SPH]YUSUARIOWIP
  Endif

  Close Local File [SPH]
End

Subprog PREPCAMBIOWIP(PCOD_PREPARACION, PWIP, PUSUARIO, PRES, PMESS)
  # Entrada
  Value Char PCOD_PREPARACION
  Value Integer PWIP
  Value Char PUSUARIO
  # Salida
  Variable Integer PRES
  Variable Char PMESS

  PRES = 100
  PMESS = "Error al actualizar WIP"

  If !clalev([SPH]) : Local File STOPREH [SPH] : Endif

  Read [SPH]PRH0 = PCOD_PREPARACION
  If !fstat Then
    Trbegin [SPH]
    If !fstat Then
      [SPH]YAPPWIP = PWIP
      [SPH]YUSUARIOWIP = PUSUARIO
      Rewrite [SPH]
      If !fstat Then
        Commit
        PRES = 200
        PMESS = "Actualización WIP correcta"
      Else
        Rollback
      Endif
    Endif
  Endif

  Close Local File [SPH]
End

####################################################################
#**
#* Sub que devuelve el detalle de la lista de preparación
#* También devuelve si hay algún bulto no terminado de la lista de preparación
#* Si no hay ninguno, lo crea
#*
#*!
Subprog DETALLEPREPARACION(PPRHNUM, PPRELIN, PORINUM, PORILIN, PITMREF, PITMDES1, PITMDES2, PQTYSTU, PYQTYSTU, PALLQTY, PPENDIENTE, PSERNUM, PLOT, PCONTENEDOR, PYCOMCARGA, PYCOMPREPARA, TIPO_LINEA, 
& PPACNUM, PRES, PMESS)
  # Entrada
  Value Char PPRHNUM()
  # Salida 1
  Variable Integer PPRELIN()
  Variable Char PORINUM()()
  Variable Integer PORILIN()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PITMDES2()()
  Variable Decimal PQTYSTU()
  Variable Decimal PYQTYSTU()
  Variable Decimal PALLQTY()
  Variable Decimal PPENDIENTE()
  Variable Char PSERNUM()
  Variable Char PLOT()
  Variable Char PCONTENEDOR()
  Variable Char PYCOMCARGA()
  Variable Char PYCOMPREPARA()
  Variable Integer TIPO_LINEA()
  # Salida 2
  Variable Char PPACNUM()
  Variable Char PRES
  Variable Char PMESS

  Local Char PACNUM(30)
  Local Char PCK(10)
  Local Char LREQSQL(250)(14)

  PRES="800"
  PMESS="No hay artículos"

  If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif


  Local Integer I       : I = 0

  Raz LREQSQL

  LREQSQL(0) = "SELECT P.PRHNUM_0, P.PRELIN_0, P.ITMREF_0, P.ITMDES1_0, P.QTYSTU_0, P.YQTYSTU_0, P.ALLQTY_0, P.ORINUM_0, P.ORILIN_0,A.QTYSTU_0 as QTYSTUA, S.SERNUM_0, S.LOT_0, S.SLO_0, S.LPNNUM_0, SO"
&  + ".YCOMCARGA_0, SO.YCOMPREPARA_0, "
  LREQSQL(1) = " P.LINTYP_0, SP.ITMDES_0 FROM " + nomap + ".STOPRED P INNER JOIN " + nomap + ".STOALL A ON P.PRHNUM_0=A.VCRNUM_0 AND P.PRELIN_0=A.VCRLIN_0 "
  LREQSQL(2) = " LEFT OUTER JOIN " + nomap + ".SORDERP SP ON P.ORINUM_0 = SP.SOHNUM_0 AND P.ORILIN_0 = SP.SOPLIN_0 AND P.ORISEQ_0 = SP.SOPSEQ_0 "
  LREQSQL(3) = " LEFT JOIN " + nomap + ".STOCK S ON A.STOCOU_0=S.STOCOU_0 INNER JOIN " + nomap + ".SORDER SO ON P.ORINUM_0=SO.SOHNUM_0 "
  LREQSQL(4) = " WHERE P.PRHNUM_0='" + PPRHNUM+"'"
  LREQSQL(5) = " ORDER BY P.PRELIN_0 "

For (Char PRHNUM,Integer PRELIN,Char ITMREF,Char ITMDES1(250),Decimal QTYSTU,Decimal YQTYSTU,Decimal ALLQTY,Char ORINUM,Integer ORILIN, Decimal QTYSTUA,Char SERNUM,Char LOT,Char SLO, Char LPNNUM, Char
& YCOMCARGA(255), Char YCOMPREPARA(255), Integer LINTYP, Char ITMDES(250)) From '5' Sql LREQSQL As [YAPP]
    Read [F:YSOH]SOH0=[F:YAPP]ORINUM
    If !fstat Then
      If [F:YSOH]CDTSTA=1 and [F:YSOH]HLDSTA=1 Then
        If [F:YAPP]ALLQTY<>0
          PPRELIN(I)    = [F:YAPP]PRELIN
          PORINUM(I)    = [F:YAPP]ORINUM
          PORILIN(I)    = [F:YAPP]ORILIN
          PITMREF(I)    = [F:YAPP]ITMREF
          PITMDES1(I)   = [F:YAPP]ITMDES1
          PITMDES2(I)   = [F:YAPP]ITMDES
          PQTYSTU(I)    = [F:YAPP]QTYSTUA
          PALLQTY(I)    = [F:YAPP]QTYSTUA
          PSERNUM(I)    = [F:YAPP]SERNUM
          PLOT(I)       = [F:YAPP]LOT
          PCONTENEDOR(I)= [F:YAPP]LPNNUM
          PYCOMCARGA(I) = [F:YAPP]YCOMCARGA
          PYCOMPREPARA(I) = [F:YAPP]YCOMPREPARA
          TIPO_LINEA(I) = [F:YAPP]LINTYP
          Raz LREQSQL
           If [F:YAPP]SERNUM<>"" or [F:YAPP]LOT<>"" or [F:YAPP]LPNNUM<>""
             LREQSQL(0)="select sum(QTYPCU_0) AS QTY FROM " + nomap + ".YSPACKD "
             LREQSQL(1)=" WHERE VCRNUM_0='"+PPRHNUM+"' AND VCRLIN_0="+num$([F:YAPP]PRELIN)
             If [F:YAPP]SERNUM<>""
                  LREQSQL(2)=" AND SERNUM_0='"+[F:YAPP]SERNUM+"'"
             Elsif [F:YAPP]LOT<>""
                LREQSQL(2)=" AND LOT_0='"+[F:YAPP]LOT+"'"
             Elsif [F:YAPP]LPNNUM<>""
                LREQSQL(2)=" AND YLPNNUM_0='"+[F:YAPP]LPNNUM+"'"
             Endif
             For (Decimal QTY) From '5' Sql LREQSQL(0..3) As [YAPP2]
                PPENDIENTE(I) = PQTYSTU-[YAPP2]QTY
                PYQTYSTU(I)   = [F:YAPP2]QTY
             Next
          Else
            PPENDIENTE(I) = PQTYSTU-[F:YAPP]YQTYSTU
            PYQTYSTU(I)   = [F:YAPP]YQTYSTU
          Endif
          I+=1
          PRES="200"
          PMESS="Lectura correcta"
       Endif
      Endif
    Endif
  Next

  #BUSCAMOS SI ESTA LISTA DE PREPARACIÓN TIENE ALGÚN BULTO sin TERMINAR
  PACNUM=""
  Filter [F:YSPH] Where VCRNUM=PPRHNUM and YCERRADO<>2
  For [F:YSPH]
    PACNUM=[F:YSPH]PACNUM
  Next
  PPACNUM=PACNUM

  Close Local File [YYPR2]
  Close Local File [YSPH]
  Close Local File [YSOH]
End

######################################################################################
#**
#* GETLSSPACK
#* APP: devuelve   todos los bultos de una preparación, y sus líneas
#*
#*
#* @param PPRHNUM, preparación
#*
#* @param CAMPO1: campo izquierdo: BULTO: No bulto, LINEA: ref. artículo
#* @param CAMPO2: campo descripción: BULTO: peso, largo, ancho, alto, LINEA: descrip. artículo
#* @param CAMPO3: campo de cola, numérico: BULTO: vacio, LINEA: unidadeas de producto
#* @param TIPOCAMPO: "B" si es bulto. "L" si es la línea del producto.
#* @param PPACNUM
#* @param PPACIND
#* @param PITMREF
#* @param PITMDES1
#* @param PSERNUM
#* @param PQTYPCU
#* @param PPESONETO
#* @param PCAMION
#* @param PRES
#* @param PMESS
#*
#*!
Subprog DETALLEEMPAQUETADOPREPARACION(PPRHNUM, PCAMPO1, PCAMPO2, PCAMPO3,  PTIPOCAMPO,  PPACNUM , PPRELIN, PPACIND, PITMREF, PITMDES1, PSERNUM, PLOT, PSLO,  PQTYPCU,  PCAMION)
  # Entrada
  Value Char PPRHNUM()
  # Salida
  Variable Char PCAMPO1()()
  Variable Char PCAMPO2()()
  Variable Char PCAMPO3()()
  Variable Char PTIPOCAMPO()()
  Variable Char PPACNUM()()
  Variable Integer PPRELIN()
  Variable Integer PPACIND()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PSERNUM()()
  Variable Char PLOT()()
  Variable Char PSLO()()
  Variable Decimal PQTYPCU()
  Variable Char PCAMION()()

  Local Decimal  PESONETO


  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif


  Local Integer I       : I = 0

  #Filtramos todos los bultos de la preparacion
  Filter [F:YSPH] Where VCRNUM=PPRHNUM
    For [F:YSPH]
      PCAMPO1(I)=[F:YSPH]PACNUM
      PCAMPO2(I)="Peso: " + num$([F:YSPH]YBRWEI) + "kg" + " Largo: "+ num$([F:YSPH]YPCKLEN)+ "cm Ancho: "+ num$([F:YSPH]YPCKWID)+"cm Alto: "+ num$([F:YSPH]YPCKHEI) +"cm" - "Camión: "+[F:YSPH]YCAMION
      PCAMPO3(I)=""
      If [F:YSPH]YCERRADO=2 Then
        PTIPOCAMPO(I)="C"
      Else
        PTIPOCAMPO(I)="B"
      Endif
      #Filtramos todos los componentes de los bultos
      I+=1
      Filter [YSPD] Where PACNUM=[F:YSPH]PACNUM and YASOCIADO = 1  Order By PACIND
      For [F:YSPD]
        #Campos que se verán en la rejilla
        PCAMPO1(I)=[F:YSPD]ITMREF
        PCAMPO2(I)=[F:YSPD]ITMDES1
        If [F:YSPD]SERNUM<>"" Then : PCAMPO2(I)+=" Serie: "+[F:YSPD]SERNUM: Endif
        If [F:YSPD]LOT<>""    Then : PCAMPO2(I)+=" Lote: "+[F:YSPD]LOT: Endif
        PCAMPO3(I)= num$([F:YSPD]QTYPCU)
        PTIPOCAMPO(I)="D"
        #Campos que no se ven, pero pueden ser interesantes
        PPACNUM(I)=[F:YSPH]PACNUM
        PPRELIN(I)=[F:YSPD]VCRLIN
        PPACIND(I)=[F:YSPD]PACIND
        PITMREF(I)=[F:YSPD]ITMREF
        PITMDES1(I)=[F:YSPD]ITMDES1
        PSERNUM(I)=[F:YSPD]SERNUM
        PLOT(I)=[F:YSPD]LOT
        PSLO(I)=[F:YSPD]SLO
        PQTYPCU(I)=[F:YSPD]QTYPCU
        PCAMION(I)=[F:YSPH]YCAMION
        I+=1
      Next # De la línea de bulto YPACKD
  Next #Del bulto, YPACK
PPESONETO=PESONETO

  Close Local File [YSPD]
  Close Local File [YSPH]
End

####################################################################
#**
#* RMSPACKDET
#* APP: borra una línea del empaquetado
#*
#* @param PPACNUM
#* @param PPACIND
#* @param PRES
#* @param PMESS
#*!
Subprog BORRARLINEAEMPAQUETADO(PPACNUM, PPACIND, PRES, PMESS)
  # Entrada
  Value Char PPACNUM()
  Value  Integer PPACIND
  # Salida
  Variable Char PRES()
  Variable Char PMESS()

  Local Char LREQ(255)

  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YPRE]) Then : Local File STOPRED      [YPRE] : Endif
  If !clalev([YSPD2]) Then : Local File YSPACKD      [YSPD2] : Endif

  Read [F:YSPD]YSPD0= PPACNUM;PPACIND
  If !fstat Then
    Read  [F:YPRE]PRE0=[F:YSPD]VCRNUM;[F:YSPD]VCRLIN
    If !fstat Then
      [F:YPRE]YQTYSTU=[F:YPRE]YQTYSTU-[F:YSPD]QTYPCU
      Rewrite [F:YPRE]
      Delete [F:YSPD]
      #Borramos asociados si existen
      Filter [F:YSPD2] Where PACNUM = PPACNUM and PACINDASOC = PPACIND
      For [F:YSPD2]
        Delete [F:YSPD2]
      Next
      #Si no quedan lineas borramos el paquete
      Filter [F:YSPD] Where PACNUM=PPACNUM
      If rowcount([F:YSPD])=0 Then
        Read [F:YSPH]YSPH0=PPACNUM
        If !fstat Then
          Delete [F:YSPH]
        Endif
      Endif
      PRES="200"
      PMESS="Borrado correcto"
    Else
      PRES="110"
      PMESS="No existe el documento de prep.: " + [F:YSPD]VCRNUM + ", linea: "+ num$([F:YSPD]VCRLIN)
    Endif
  Else
    PRES="100"
    PMESS="No existe el bulto: " + PPACNUM + ", linea: "+ num$(PPACIND)
  Endif
  Close Local File [YSPD]
  Close Local File [YSPD2]
  Close Local File [YSPH]
End

####################################################################
#**
#* Sub que comprueba el código de barras que se le pasa,
#* Comprueba que es válido para la lista de preparación.
#*
#* 1º Número de serie
#* 2º EAN
#* 3º Contenedor, LPN, para el caso del prepiking
#* Si es válido, rellena YQTYPCU
#* Devuelve el nº de Bulto, si no existe, lo crea
#*
#* PRES: 200, OK
#*
#* PMES: Mensaje con lo que ha hecho
#*!
Subprog NUEVOEMPAQUETADO(PPRHNUM, PCODIGOBARRAS, PUSUARIO, PLINEA_KIT, PCOD_KIT, PCANT,PPACNUM, PRES, PMESS)
  # ENTRADA
  Value Char PPRHNUM()
  Value Char PCODIGOBARRAS()
  Value Char PUSUARIO()
  Value Integer PLINEA_KIT
  Value Char PCOD_KIT
  Value Integer PCANT
  # SALIDA
  Variable Char PPACNUM()
  Variable Char PRES
  Variable Char PMESS

  Local  Integer CANTIDAD
  Local Char INFNAM
  Local Char DESTINO
  Local Char PRELPN

  If !clalev([YYPRE]) Then : Local File STOPRED      [YYPRE] : Endif
  If !clalev([YITM])  Then : Local File ITMMASTER    [YITM]  : Endif
  If !clalev([YSTO])  Then : Local File STOCK        [YSTO]  : Endif
  If !clalev([YSTA])  Then : Local File STOALL       [YSTA]  : Endif
  If !clalev([YSPD])  Then : Local File YSPACKD      [YSPD]  : Endif

  # Comprobamos primero que sea un código válido (puede ser un contenedor, un ean, un lote o un número de serie)
    Filter [YSTO] Where LPNNUM = PCODIGOBARRAS
    # Comprobamos si existe algún contendor en stock con este código
    If rowcount([YSTO]) = 0
      Filter [YSTO]
      # Comprobamos si extiste algún artículo con ese EAN
      Filter [YITM] Where EANCOD = PCODIGOBARRAS
      If rowcount([YITM]) = 0
        # Comprobamos si existe algún lote en stock con ese código
        Filter [YSTO] Where LOT = PCODIGOBARRAS
        If rowcount([YSTO]) = 0
          Filter [YSTO]
          Filter [YSTO] Where SERNUM = PCODIGOBARRAS
          If rowcount([YSTO]) = 0
             PRES = "110"
             PMESS = "El código leído no es válido"
             Goto FIN
          Endif
        Endif
      Endif
    Endif

    Filter [F:YSTO]
    Filter [F:YITM]



    Call PARAM_YSPACKD(INFNAM, DESTINO, PRELPN)

    PRES="100"
    PMESS="El producto leído no se encuentra en esta preparación"

    CANTIDAD=1


    #Testeamos si es un LPN, para ello debe empezar por "PP"
    If left$(PCODIGOBARRAS,2)=PRELPN Then
      PRES="160"
      PMESS="El prepicking leído no está en esta preparación"
      If PCANT>1
        PRES="160"
        PMESS="El prepicking leído no está en esta preparación"
      Else
        Local Char LREQ(255)(0..1)
        LREQ(0) = "SELECT STA.VCRLIN_0 FROM " + nomap + ".STOCK STO INNER JOIN " + nomap + ".STOALL STA "
        LREQ(1) = "ON STO.STOCOU_0 = STA.STOCOU_0 WHERE STO.LPNNUM_0 = '" + PCODIGOBARRAS + "' AND STA.VCRNUM_0 = '" + PPRHNUM + "'"

        For(Integer PVCRLIN) From "5" Sql LREQ As [YLIN]
          Filter [F:YYPRE] Where PRHNUM=PPRHNUM and PRELIN=[YLIN]PVCRLIN
          For [F:YYPRE]
            Filter [F:YSTO] Where  LPNNUM=PCODIGOBARRAS and ITMREF=[F:YYPRE]ITMREF
            For [F:YSTO]
                If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
                  Trbegin [F:YYPRE]
                  If [F:YSTO]QTYSTU > [F:YYPRE]QTYSTU Then
                    CANTIDAD=[F:YYPRE]QTYSTU
                  Else
                    CANTIDAD=[F:YSTO]QTYSTU
                  Endif

                  [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
    #             Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM,"", "", PCODIGOBARRAS, PUSUARIO, PCOD_KIT)
                  Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM,[YSTO]SERNUM, "", PCODIGOBARRAS, PUSUARIO, PCOD_KIT)
                  Rewrite [F:YYPRE]
                  If !fstat Then
                    Commit
                  Else
                    Rollback
                  Endif
                  PRES="200"
                  PMESS="Correcto"
                Endif
            Next
          Next
        Next
       Endif #de la cantidad
###########################################################
    Else #no es contenedor
      Filter [F:YYPRE] Where PRHNUM=PPRHNUM and [F:YYPRE]ALLTYP = 2 and PRELIN > PLINEA_KIT Order By PRELIN
      For [F:YYPRE]
        Read [YITM]ITM0=[F:YYPRE]ITMREF
        If !fstat Then
          #Comprobamos núm de serie
#          If [YITM]SERMGTCOD <> 1 Then
          If func NUM_SERIE(PPRHNUM, PCODIGOBARRAS) = 2 Then
            #Numero de serie
             If PCANT>1
              PRES="160"
              PMESS="La cantidad introducida no es adecuada para este tipo de código"
            Else
              Read [F:YSTO]STO5=[F:YYPRE]ITMREF;PCODIGOBARRAS
              If !fstat Then
                 #Si está en stock, buscamos que esté asignada a esta preparación STOALL
                Filter [F:YSTA] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and ITMREF= [F:YYPRE]ITMREF and STOCOU=[F:YSTO]STOCOU
                  If rowcount([F:YSTA])=0 Then
                    PRES="120"
                    PMESS="Número de serie no asignado a esta preparación"
                  Else
                    For [F:YSTA]
                    #Por último tenemos que ver si el número de serie está en un bulto YPACKD
                    PRES="200"
                    PMESS="Número de serie correcto"
                    Filter [F:YSPD] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and SERNUM=PCODIGOBARRAS
                      #Si existe, incorrecto
                      For [F:YSPD]
                        PRES="101"
                        PMESS="Ya está utilizado el número de serie: " + PCODIGOBARRAS
                      Next
                      If PRES="200" Then
                        Trbegin [F:YYPRE]
                        [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                        Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM, PCODIGOBARRAS,"","", PUSUARIO, PCOD_KIT)
                        Rewrite [F:YYPRE]
                        If !fstat Then
                          Commit
                        Else
                         Rollback
                        Endif
                        PRES="200"
                        PMESS="Correcto"
                        Break
                      Endif
                      Next
                Endif #DEL rowcount
              Endif
           Endif #DE LA CANTIDAD
          Else
              #Número de lote
              If [YITM]LOTMGTCOD <> 1  Then
               #Lote
               Infbox("lot: " -[F:YYPRE]ITMREF-PCODIGOBARRAS)
               Read [F:YSTO]YSTO7=[F:YYPRE]ITMREF;PCODIGOBARRAS
               If !fstat Then
                  #Si está en stock, buscamos que esté asignada a esta preparación STOALL
                  Filter [F:YSTA] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and ITMREF= [F:YYPRE]ITMREF and STOCOU=[F:YSTO]STOCOU
                  If rowcount([F:YSTA])=0 Then
                      PRES="120"
                      PMESS="Lote no asignado a esta preparación"
                  Else
                    For [F:YSTA]
                      #Por último tenemos que ver si el número de serie está en un bulto YPACKD
                      PRES="200"
                      PMESS="Lote correcto"
                      Filter [F:YSPD] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and SERNUM=PCODIGOBARRAS
                      #Si existe, incorrecto
                      For [F:YSPD]
                        Infbox("exite el bulto")
                        PRES="101"
                        PMESS="Ya está utilizado el lote: " + PCODIGOBARRAS
                      Next
                      If PRES="200" Then
                        If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
                          Infbox("damos el alta: "-num$([F:YYPRE]YQTYSTU)-num$(CANTIDAD)-num$([F:YYPRE]QTYSTU) )
                          Trbegin [F:YYPRE]
                          [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                          Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM, "", PCODIGOBARRAS,"", PUSUARIO, PCOD_KIT)
                          Rewrite [F:YYPRE]
                          If !fstat Then
                            Commit
                          Else
                            Rollback
                          Endif
                          PRES="200"
                          PMESS="Correcto"
                          Break
                        Else
                          PRES="150"
                          PMESS="Artículo " + [F:YYPRE]ITMREF - "Lote:-"- PCODIGOBARRAS -"totalmente recogido."
                        Endif # De la cantidad ya recogida [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU
                      Endif
                    Next
                  Endif #DEL rowcount
                Endif

              #Si no es correcto:
            Else
            #por código EAN
#TODO
            If [F:YITM]EANCOD=PCODIGOBARRAS
              # JMF - 18.09.2023
              # Comprobamos en asignaciones y stock si el artículo tiene número de contenedor asignado
              Filter [F:YSTA] Where VCRNUM = [F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN
              Local Integer PSTOCOU
              For [F:YSTA]
                PSTOCOU = [F:YSTA]STOCOU
              Next

              Local Char PLPNNUM
              Filter [F:YSTO] Where STOCOU = PSTOCOU
              For [F:YSTO]
                PLPNNUM = [F:YSTO]LPNNUM
              Next


              If PLPNNUM <> "" Then
                PRES = "155"
                PMESS = "Artículo dentro de contenedor, no se puede utilizar el EAN."
              Else
              If PCANT>[F:YYPRE]QTYSTU-[F:YYPRE]YQTYSTU  Then
                 PRES="160"
                PMESS="La cantidad es superior a la que queda por asignar"
              Else
                If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
                  Trbegin [F:YYPRE]
                  [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+PCANT
                  Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, PCANT, PPACNUM,"", "","",PUSUARIO, PCOD_KIT)
                  Rewrite [F:YYPRE]
                  If !fstat Then
                    Commit
                  Else
                    Rollback
                  Endif
                  PRES="200"
                  PMESS="Correcto"
                  Break
                Else
                 # Infbox("NO SUMA")
                  PRES="150"
                  PMESS="Artículo " + [F:YYPRE]ITMREF - "totalmente recogido."
                  #Break, SEGUIMOS POR SI HAY OTRO ARTÍCULO
                Endif
               Endif
            Endif
          Endif #Si coincide el código de barras
        Endif
       Endif
      Endif   #No exite artículo
    Next
  Endif #prepicking

  $FIN

  Close Local File [YYPRE]
  Close Local File [YITM]
  Close Local File [YSTO]
  Close Local File [YSTA]
  Close Local File [YSPD]

End

Funprog NUM_SERIE(PPRHNUM, PCOD_BARRAS)
  Value Char PPRHNUM
  Value Char PCOD_BARRAS

  Local Integer LRET : LRET = 1

  If !clalev([YSTOAF]) : Local File STOALL [YSTOAF] : Endif
  If !clalev([YSTOCKF]) : Local File STOCK [YSTOCKF] : Endif

  Filter [YSTOAF] Where VCRNUM = PPRHNUM
  For [YSTOAF]
    Read [YSTOCKF]STO0 = '11';[YSTOAF]STOCOU
    If !fstat
      If [YSTOCKF]SERNUM = PCOD_BARRAS Then
        LRET = 2
      Endif
    Endif
  Next

  Close Local File [YSTOAF]
  Close Local File [YSTOCKF]
End LRET

########################################################
#**
#* Funcion que devuelve el valor de los parámetros para el informe y para el destino
#*!
Subprog PARAM_YSPACKD(PINFNAM, PDESTINO, PPRELPN)
Variable Char    PINFNAM
Variable Char    PDESTINO
Variable Char    PPRELPN

If !clalev([YTAB]) Then : Local File ATABDIV [YTAB] : Endif

 Filter [F:YTAB] Where NUMTAB = 6001
  For [F:YTAB]
    Case [F:YTAB]A1
      When "ETIQUETABULTO"   :   PINFNAM=[F:YTAB]A2
      When "DESTINOBULTO"    :   PDESTINO=[F:YTAB]A2
      When "PRELPN"          :   PPRELPN=[F:YTAB]A2
    Endcase
  Next

 Close Local File [YTAB]
End

####################################################################
#**
#* Sub que crea los registros en las tablas YPACKD
#*
#* Se le pasa el número del listado de preparación, linea, cantidad  y el número de bulto
#* la cantidad normalmente será  1
#*!

Subprog PUTYSPACKDET(PPRHNUM, PPRELIN ,PQTYPCU, PPACNUM, PSERNUM, PLOT, PLPNNUM, PUSUARIO, PCOD_KIT)
  Value Char PPRHNUM()
  Value  Integer PPRELIN
  Value Integer PQTYPCU
  Variable Char PPACNUM()
  Value Char PSERNUM()
  Value Char PLPNNUM()
  Value Char PUSUARIO()
  Value Char PCOD_KIT

  Local Integer I
  Local Integer NUM_LINEA
  Local Decimal CANT_ASOCIADO : Raz CANT_ASOCIADO
  Local Integer INDICE_ASOCIADO : Raz INDICE_ASOCIADO

  Local Char PRES, PMESS

  If !clalev([YSPD]) Then  : Local File YSPACKD [YSPD]   : Endif
  If !clalev([YPRE]) Then  : Local File STOPRED [YPRE]   : Endif
  If !clalev([YCONT]) Then : Local File YSPACKD [YCONT]  : Endif
  If !clalev([YSOQ]) Then  : Local File SORDERQ [YSOQ]   : Endif
  If !clalev([YITM]) Then  : Local File ITMMASTER [YITM] : Endif

   Local Char PCK
    PCK=""
    If PPACNUM="" Then
        Call PUTNEWYSPACK(PPRHNUM, PCK, PUSUARIO, PPACNUM, PRES, PMESS)
    Endif


  #Filtramos por las cantidades pendientes de poner en un bulto
  I=0
  Filter [YCONT] Where VCRNUM=PPRHNUM
    If !fstat Then
      NUM_LINEA=rowcount([YCONT])+1
    Else
      NUM_LINEA=1
    Endif
  Filter [F:YPRE] Where PRHNUM=PPRHNUM and PRELIN =PPRELIN
  For [F:YPRE]
    I=I+1
    [YSPD]VCRNUM=PPRHNUM
    [YSPD]VCRLIN=PPRELIN
    [YSPD]STOFCY="11"
    [YSPD]CPY="1"
    [YSPD]VCRTYP=3
    [YSPD]PACSEQ=I
    [YSPD]PACNUM=PPACNUM
    [YSPD]PACIND=NUM_LINEA
    [YSPD]PCK=""
    [YSPD]ITMREF=[F:YPRE]ITMREF
    [YSPD]ITMDES1=[F:YPRE]ITMDES1
    [YSPD]QTYPCU=PQTYPCU
    If PSERNUM<>"" Then
      [YSPD]SERNUM=PSERNUM
    Endif
    If PLPNNUM<>"" Then
      [YSPD]YLPNNUM=PLPNNUM
    Endif
    If PLOT<>"" Then
      [YSPD]LOT=PLOT
    Endif
    [YSPD]YASOCIADO = 1
    [YSPD]YCODKIT = PCOD_KIT
    Write [YSPD]
    If !fstat Then
    #  Commit
    Else
    #  Rollback
    Endif

    # Comprobamos si el producto tiene asociados y en caso afirmativo introducimos en el bulto
    # las cantidades proporcionales de estos
    # NOTA: los productos asociados los encontraremos en la tabla SORDERQ por el campo ZLINASOC
    INDICE_ASOCIADO = NUM_LINEA

    Filter [YSOQ] Where SOHNUM = [YPRE]ORINUM and [YSOQ]ZLINASOC = [YPRE]ORILIN
    For [YSOQ]
       # Necesitamos saber la proporción que corresponde al artículo asociado en función de la cantidad del artículo principal en el pedido
      CANT_ASOCIADO = func PROPORCIONASOCIADO([YPRE]ORINUM, [YPRE]ORILIN, [YSOQ]SOPLIN)
      If CANT_ASOCIADO <> 0 Then
        # Metemos el asociado en el bulto
        NUM_LINEA += 1
        I += 1

        [YSPD]VCRNUM=PPRHNUM
        [YSPD]VCRLIN=PPRELIN
        [YSPD]STOFCY="11"
        [YSPD]CPY="1"
        [YSPD]VCRTYP=3
        [YSPD]PACSEQ=I
        [YSPD]PACNUM=PPACNUM
        [YSPD]PACIND=NUM_LINEA
        [YSPD]PCK=""
        [YSPD]ITMREF=[YSOQ]ITMREF
        Read [YITM]ITM0 = [YSOQ]ITMREF
        If !fstat
          [YSPD]ITMDES1=[F:YITM]ITMDES1
        Endif
        [YSPD]QTYPCU=CANT_ASOCIADO
        [YSPD]SERNUM = ""
        [YSPD]LOT = ""
        [YSPD]YLPNNUM = ""
        [YSPD]YASOCIADO = 2
        [YSPD]PACINDASOC = INDICE_ASOCIADO
        Write [YSPD]

      Endif
    Next

    Filter [YSOQ]
  Next
  Close Local File [YSPD]
  Close Local File [YPRE]
  Close Local File [YCONT]
  Close Local File [YSOQ]
  Close Local File [YITM]
End

Funprog PROPORCIONASOCIADO(PCOD_PEDIDO, PLINEA_PRINCIPAL, PLINEA_ASOCIADO)
  Value Char PCOD_PEDIDO
  Value Integer PLINEA_PRINCIPAL
  Value Integer PLINEA_ASOCIADO

  Local Decimal LRET : Raz LRET
  Local Decimal CANTIDAD_PRINCIPAL
  Local Decimal CANTIDAD_ASOCIADO

  If !clalev([YSOQ2]) : Local File SORDERQ [YSOQ2] : Endif

  Filter [YSOQ2] Where SOHNUM = PCOD_PEDIDO and SOPLIN = PLINEA_PRINCIPAL
  Read [YSOQ2] First
  If !fstat
    CANTIDAD_PRINCIPAL = [YSOQ2]QTYSTU
    Filter [YSOQ2]
    Filter [YSOQ2] Where SOHNUM = PCOD_PEDIDO and SOPLIN = PLINEA_ASOCIADO
    Read [YSOQ2] First
    If !fstat
      CANTIDAD_ASOCIADO = [YSOQ2]QTYSTU

      If CANTIDAD_PRINCIPAL <> 0
        LRET = CANTIDAD_ASOCIADO / CANTIDAD_PRINCIPAL
      Endif
    Endif
  Endif

  Filter [YSOQ2]

  Close File [YSOQ2]
End LRET

Subprog PUTNEWYSPACK(  PPRHNUM, PPCK, PUSUARIO, PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PPCK()
  Variable Char PUSUARIO()
  Variable Char PPACNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif
  If !clalev([YYSPH2]) Then : Local File YSPACK      [YYSPH2] : Endif

  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer STAT
  Local Char LCONTADOR
  Local Integer SECUENCIA : SECUENCIA = 1
  Local Integer NPAL : NPAL = 1  # @03@ - EQM

  # @03@ - EQM - Buscamos si hay registro en YSPACK y el último NPALT
  Filter [YYSPH2] Where VCRNUM = PPRHNUM Order By NPALET Desc
  If rowcount([YYSPH2]) > 0
    Read [YYSPH2] First
    NPAL = [YYSPH2]NPALET+1
  Endif
  Filter [YYSPH2]
  # @03@ - EQM

  Call NUMERO("YPAAP","11",date$,"",LCONTADOR,STAT) From SUBANM

  # JMF - 30.11.2023
  # Comprobamos si ya existe algún registro en la tabla YSPACK para actualizar el número de secuencia
  Filter [YYSPH2] Where VCRNUM = PPRHNUM Order By PACSEQ Desc
  If rowcount([YYSPH2]) > 0
    Read [YYSPH2] First
    SECUENCIA = [YYSPH2]PACSEQ + 1
  Endif
  Filter [YYSPH2]

  [YYSPH]STOFCY="11"
  [YYSPH]CPY="1"
  [YYSPH]PACSEQ=SECUENCIA
  [YYSPH]VCRTYP=3
  [YYSPH]VCRNUM=PPRHNUM
  [YYSPH]PACNUM=LCONTADOR
  [YYSPH]PCK=PPCK
  [YYSPH]PREUSR = PUSUARIO
  [YYSPH]YCARGADO = 1
  [YYSPH]NPALET = NPAL # @03@ - EQM
  Write [YYSPH]
  If !fstat Then
    PRES="200"
    PMESS="OK"
  Else
    PRES="100"
    PMESS="Problema dando de alta el bulto"
    End
  Endif

PPACNUM=LCONTADOR
  Close Local File [YYSPH]
  Close Local File [YYSPH2]
End

#**
#* APP: Sub que devuelve el detalle del bulto que vamos a cerrar
#*
#*!
Subprog DETALLEBULTO(PPACNUM , PPACIND, PITMREF, PITMDES1, PSERNUM,  PQTYPCU, PPESONETO, PRES, PMESS)
  # Entrada
  Value Char PPACNUM()
  # Salida 1
  Variable Integer PPACIND()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PSERNUM()()
  Variable Decimal PQTYPCU()
  # Salida 2
  Variable Decimal PPESONETO
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO

  If !clalev([YSPD]) Then  : Local File YSPACKD      [YSPD]  : Endif
  If !clalev([YITM]) Then  : Local File ITMMASTER    [YITM]  : Endif
  If !clalev([YTPK]) Then  : Local File YTMPYPCKD    [YTPK]  : Endif
  If !clalev([YTPK2]) Then : Local File YTMPYPCKD    [YTPK2] : Endif

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0
    # Sin numero de serie
    PRES = '100'
    PMESS = 'Problemas'
    PESONETO=0

    Filter [F:YTPK] Where PACNUM=PPACNUM
    For [F:YTPK]
      Delete [F:YTPK]
    Next

    # Rellenamos la tabla temporal para que se agrupe en pantalla por
    #   1- Si numero de serie->número de serie
    #   2- Si viene de un LPN: LPN+ITMREF
    #   3- Si viene del código ean, por artículo
    #
    Filter [YSPD] Where PACNUM=PPACNUM  Order By PACIND
    For [F:YSPD]
      Read [F:YTPK]YTPK0=PPACNUM;[F:YSPD]ITMREF;[F:YSPD]YLPNNUM;[F:YSPD]SERNUM
      Trbegin [F:YTPK]
      [F:YTPK]PACNUM=PPACNUM
      [F:YTPK]ITMREF=[F:YSPD]ITMREF
      [F:YTPK]SERNUM=[F:YSPD]SERNUM
      [F:YTPK]LPNNUM=[F:YSPD]YLPNNUM
      If !fstat Then
        [F:YTPK]QTYPCU= [F:YTPK]QTYPCU+[F:YSPD]QTYPCU
        Rewrite  [F:YTPK]
      Else
        [F:YTPK]ITMDES=[F:YSPD]ITMDES1
        [F:YTPK]QTYPCU=[F:YSPD]QTYPCU
        Write  [F:YTPK]
      Endif
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
      Read [F:YITM]ITM0=[F:YSPD]ITMREF
      If !fstat Then
        PESONETO = PESONETO +([F:YITM]ITMWEI*[F:YSPD]QTYPCU)
#        PESONETO = PESONETO + [F:YTIM]
      Endif
      I+=1
    Next

    I=0
    Filter [F:YTPK2] Where PACNUM=PPACNUM
    For [F:YTPK2]
      PPACIND(I)=I
      PITMREF(I)= [F:YTPK2]ITMREF
      PITMDES1(I)=[F:YTPK2]ITMDES
      If [F:YTPK2]SERNUM<>"" or [F:YTPK2]LPNNUM<>"" Then
        If [F:YTPK2]SERNUM="" Then
          PSERNUM(I)="Caja:" - [F:YTPK2]LPNNUM
        Else
          PSERNUM(I)="N.Ser.:" - [F:YTPK2]SERNUM
        Endif
      Endif
      PQTYPCU(I)=[F:YTPK2]QTYPCU
      PRES = '200'
      PMESS = 'OK'
      I+=1
      If I>LISTMAX Then
        Break
      Endif

    Next

PPESONETO=PESONETO
  Close Local File [YSPD]
  Close Local File [YITM]
  Close Local File [F:YTPK]
  Close Local File [F:YTPK2]
End

Subprog COMPROBARKIT(PCOD_PREPARACION, PCOD_BULTO, PRES, PMESS)
  # Entrada
  Value Char PCOD_PREPARACION
  Value Char PCOD_BULTO
  # Salida
  Variable Integer PRES
  Variable Char PMESS

  Local Integer LRET : LRET = 1
  Local Char COD_ARTICULO_KIT(25) : Raz COD_ARTICULO_KIT

  Local Decimal CANTIDAD_ANTERIOR : Raz CANTIDAD_ANTERIOR
  Local Decimal PROPORCION        : Raz PROPORCION
  Local Char LREQ(255)(0..1)

  If !clalev([YPRHD])  : Local File STOPRED [YPRHD]  : Endif
  If !clalev([YPRHD2]) : Local File STOPRED [YPRHD2] : Endif
  If !clalev([YPRHD3]) : Local File STOPRED [YPRHD3] : Endif

  PRES = 200
  PMESS = "OK"

  LREQ(0) = "SELECT ITMREF_0, VCRLIN_0, SUM(QTYPCU_0) AS QTYPCU_0 FROM " + nomap + ".YSPACKD WHERE VCRNUM_0 = '" + PCOD_PREPARACION + "' "
  LREQ(1) = "AND PACNUM_0 = '" + PCOD_BULTO + "' GROUP BY ITMREF_0, VCRLIN_0 "

  For (Char ITMREF, Integer VCRLIN, Decimal QTYPCU) From "5" Sql LREQ As [F:YSPAD]
    Filter [YPRHD] Where PRHNUM = PCOD_PREPARACION and PRELIN = VCRLIN
    Read [YPRHD] First
    If !fstat
      If [YPRHD]LINTYP = 3
        # Ahora tenemos que buscar a qué artículo kit corresponde el componente (buscando hacia arriba por las líneas hasta encontrar un artículo con LINTYP_0 = 2)
        Filter [YPRHD2] Where PRHNUM = PCOD_PREPARACION and PRELIN < [YPRHD]PRELIN and LINTYP = 2
        Read [YPRHD2] Last

        If !fstat
          COD_ARTICULO_KIT = [YPRHD2]ITMREF

          Filter [YPRHD3] Where PRHNUM = PCOD_PREPARACION and PRELIN > [YPRHD2]PRELIN
          Local Integer I : I= 0
          For [YPRHD3]
            If [YPRHD3]LINTYP <> 3
              Break
            Endif

            PROPORCION = func  GETPROPORCIONCOMPUESTOKIT(COD_ARTICULO_KIT, [YPRHD3]ITMREF)

            If I = 0 Then
              I += 1
              CANTIDAD_ANTERIOR = func GETCANTIDADBULTO(PCOD_PREPARACION, PCOD_BULTO, [YPRHD3]PRELIN) / PROPORCION
            Else
              If CANTIDAD_ANTERIOR <> (func GETCANTIDADBULTO(PCOD_PREPARACION, PCOD_BULTO, [YPRHD3]PRELIN) / PROPORCION)
                PRES = 100
                PMESS = "Faltan componentes para el kit " + COD_ARTICULO_KIT + ". No se puede finalizar el bulto."
              Endif
            Endif
          Next
        Endif
      Endif
    Endif
  Next
  Filter [YPRHD]

  Close Local File [YPRHD]
  Close Local File [YPRHD2]
  Close Local File [YPRHD3]
End

Funprog GETPROPORCIONCOMPUESTOKIT(COD_KIT, COD_COMPUESTO)
  Value Char COD_KIT
  Value Char COD_COMPUESTO

  Local Decimal LRET : LRET = 1

  Local Decimal CANTIDAD_BASE : Raz CANTIDAD_BASE

  If !clalev([YBOM])  : Local File BOM [YBOM]   : Endif
  If !clalev([YBOMD]) : Local File BOMD [YBOMD] : Endif

  Filter [YBOM] Where BOMALT = 10 and ITMREF = COD_KIT and BOMALTTYP = 1 and (BOHSTRDAT <= date$ and (BOHENDDAT>= date$ or BOMENDDAT = [00/00/000]))
  Read [YBOM] First
  If !fstat
    CANTIDAD_BASE = [YBOM]BASQTY
    Filter [YBOMD] Where BOMALT = 10 and ITMREF = COD_KIT and CPNITMREF = COD_COMPUESTO and BOMALT = [YBOM]BOMALT and BOMALTTYP = 1 and (BOMSTRDAT <= date$ and (BOMENDDAT>= date$ or BOMENDDAT = [00/00
& /0000]))
    For [YBOMD]
      LRET = [YBOMD]BOMQTY / CANTIDAD_BASE
    Next
  Endif
  Filter [YBOM]
  Filter [YBOMD]

  Close Local File [YBOM]
  Close Local File [YBOMD]

End LRET

Funprog GETCANTIDADBULTO(PCOD_PREPARACION, PCOD_BULTO, PVCRLIN)
  Value Char PCOD_PREPARACION
  Value Char PCOD_BULTO
  Value Integer PVCRLIN

  Local Decimal LRET : Raz LRET

  If !clalev([YSPAD2]) : Local File YSPACKD [YSPAD2] : Endif

  Filter [YSPAD2] Where VCRNUM = PCOD_PREPARACION and PACNUM = PCOD_BULTO and VCRLIN = PVCRLIN
  For [YSPAD2]
    LRET += [YSPAD2]QTYPCU
  Next

  Close Local File [YSPAD2]
End LRET

#**
#* Sub que devuelve los distintos tipos de embalajes
#*
#*!
Subprog GETLISTCONTENEDORES(QUERY, PPCK, PLANDESSHO, PLBLFMT, PPCKWEI, PPCKLEN, PPCKWID,PPCKHEI)
  # Entrada
  Value Char QUERY
  # Salida 1
  Variable Char PPCK()()
  Variable Char PLANDESSHO()()
  Variable Char PLBLFMT()()
  Variable Decimal   PPCKWEI()
  Variable Decimal   PPCKLEN()
  Variable Decimal   PPCKWID()
  Variable Decimal   PPCKHEI()

  Local Char TEMP(250)
  Local Integer POS
  Local Integer POS2
  Local Integer I       : I = 0

  If !clalev([YTPA]) Then : Local File TABPACKAGE      [YTPA] : Endif
    Filter [F:YTPA] Order By PCK
      For [F:YTPA]
        POS=instr(1,[F:YTPA]LANDESSHO,"~")
        POS2=instr(POS+1,[F:YTPA]LANDESSHO,"~")
        TEMP=mid$([F:YTPA]LANDESSHO, POS+1,POS2-POS-1 )
        If QUERY = "" or instr(1, toupper(TEMP), toupper(QUERY)) > 0 Then
          PPCK(I)=[F:YTPA]PCK
          PLANDESSHO(I)=TEMP
          PLBLFMT(I)=[F:YTPA]LBLFMT
          PPCKWID(I)=[F:YTPA]PCKWID
          PPCKLEN(I)=[F:YTPA]PCKLEN
          PPCKHEI(I)=[F:YTPA]PCKHEI
          PPCKWEI(I)=[F:YTPA]PCKWEI

          I+=1
        Endif
      Next
    Filter [F:YTPA]
  Close Local File [F:YTPA]
End

#**
#* Sub rellena los datos del bulto que faltan
#* lo da por terminado
#* imprime la etiqueta
#*
#*!
Subprog FINALIZARBULTO(PPACNUM , PPCK,  PLBLFMT, PNETWEI, PBRWEI, PVOL,  PPCKWEI, PPCKLEN, PPCKWID, PPCKHEI, PCAMION, PUSR,  PRES, PMESS)
  # Entrada
  Value Char PPACNUM()
  Value Char PPCK()
  Value Char PLBLFMT()
  Value Decimal PNETWEI
  Value Decimal  PBRWEI
  Value Decimal PPCKWEI
  Value Decimal PVOL
  Value Decimal  PPCKLEN
  Value Decimal PPCKWID
  Value Decimal PPCKHEI
  Value Char PCAMION()
  Value Char PUSR
  # Salida
  Variable Char PRES
  Variable Char PMESS

  Local Char INFNAM
  Local Char DESTINO
  Local Decimal  PESONETO
  Local Char PRELPN
  Local Integer LCERRADO
  Local Char VALE

  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([JMF1]) Then : Local File YSPACKD     [JMF1] : Endif

  Filter [JMF1] Where PACNUM = PPACNUM
  Read [JMF1] First
  If !fstat Then
    Local Char HORA(6)
    HORA = num$(time$)
    HORA = mid$(HORA,1,2)+mid$(HORA,4,2)+mid$(HORA,7,2)

    PRES="100"
    PMESS="No se encuentra el bulto/paquete"
    Filter [YSPH] Where PACNUM=PPACNUM
      For [YSPH]
        LCERRADO = [YSPH]YCERRADO

        Trbegin [F:YSPH]
        [F:YSPH]PCK=PPCK
        [F:YSPH]NETWEI=PNETWEI
        [F:YSPH]YBRWEI=PBRWEI
        [F:YSPH]YPCKHEI=PPCKHEI
        [F:YSPH]YPCKLEN=PPCKLEN
        [F:YSPH]YPCKWID=PPCKWID
        [F:YSPH]YPCKHEI=PPCKHEI
        [F:YSPH]VOL=PVOL
        [F:YSPH]YCAMION=PCAMION
        [F:YSPH]YFECHA = date$
        [F:YSPH]YHORA = HORA
        [F:YSPH]YCERRADO=2 #CERRAMOS EL BULTO
        Rewrite [F:YSPH]
        If !fstat Then
          Commit

          VALE = [JMF1]VCRNUM

          If LCERRADO <> 2 Then

            Call PARAM_YSPACKD(INFNAM, DESTINO, PRELPN)

            Local Char LDEST(50) : LDEST = func YX3MOBPREPICKING.GETDESTINOINFORME(INFNAM, PUSR)
            If LDEST <> ""
              DESTINO = LDEST
            Endif

            Call IMPETIQSPACK(PPACNUM, INFNAM,DESTINO)
          Endif


          PRES="200"
          PMESS="OK"

        Else
          Rollback
        Endif
      Next
    Filter [YSPH]
  Endif

  If clalev([YSPH]) : Close Local File [YSPH] : Endif
  If clalev([JMF1]) : Close Local File [JMF1] : Endif
End

Subprog ADDCOMPUESTOKITBULTO(PCOD_PREPARACION, PCOD_BULTO, LRET)
  # Entrada
  Value Char PCOD_PREPARACION
  Value Char PCOD_BULTO
  # Salida
  Variable Integer LRET

  LRET = 200

  Local Char LREQ(255)(2) : Raz LREQ

  Local Decimal PROPORCION : Raz PROPORCION
  Local Decimal CANTIDAD : Raz CANTIDAD
  Local Char DESC_KIT(255) : Raz DESC_KIT
  Local Char CODKIT_ANTERIOR(25) : Raz CODKIT_ANTERIOR

  If !clalev([YSPDJM]) : Local File STOPRED [YSPDJM] : Endif
  If !clalev([YSPAD]) : Local File YSPACKD [YSPAD] : Endif
  If !clalev([YITM])   : Local File ITMMASTER [YITM] : Endif
  If !clalev([YSPAD2]) : Local File YSPACKD [YSPAD2] : Endif

  Filter [YSPAD] Where VCRNUM = PCOD_PREPARACION and PACNUM = PCOD_BULTO and YCODKIT <> '' Order By YCODKIT
  For [YSPAD]
    If [YSPAD]YCODKIT <> CODKIT_ANTERIOR Then
      LREQ(0) = "SELECT ITMREF_0, SUM(QTYPCU_0) AS QTYPCU_0 FROM " + nomap + ".YVISSPACKD WHERE PACNUM_0 = '" + PCOD_BULTO + "' "
      LREQ(1) = "AND YCODKIT_0 = '" + [YSPAD]YCODKIT + "' GROUP BY ITMREF_0"
      For (Char COD_COMPUESTO, Decimal CANTIDAD_COMPONENTE) From "5" Sql LREQ As [ZJ1]
        PROPORCION = func GETPROPORCIONCOMPUESTOKIT([YSPAD]YCODKIT, [ZJ1]COD_COMPUESTO)
        CANTIDAD = [ZJ1]CANTIDAD_COMPONENTE / PROPORCION

        Read [YITM]ITM0 = [YSPAD]YCODKIT
        If !fstat Then
          DESC_KIT = [YITM]ITMDES1
        Else
          DESC_KIT = ""
        Endif

        Filter [YSPDJM] Where PRHNUM = PCOD_PREPARACION and ITMREF = [YSPAD]YCODKIT
        Read [YSPDJM] First
        If !fstat Then
          Filter [YSPAD2]
          Trbegin [YSPAD2]
          [YSPAD2]VCRNUM = PCOD_PREPARACION
          [YSPAD2]VCRLIN = [YSPDJM]PRELIN
          [YSPAD2]STOFCY = "11"
          [YSPAD2]CPY = "1"
          [YSPAD2]VCRTYP = 3
          [YSPAD2]PACSEQ = 2
          [YSPAD2]PACNUM = PCOD_BULTO
          [YSPAD2]PACIND = func GETPACIND(PCOD_PREPARACION, PCOD_BULTO)
          [YSPAD2]PCK = ""
          [YSPAD2]ITMREF = [YSPAD]YCODKIT
          [YSPAD2]ITMDES1 = DESC_KIT
          [YSPAD2]QTYPCU = CANTIDAD
          [YSPAD2]YASOCIADO = 1
          Write [YSPAD2]
          If !fstat Then
            Commit
          Else
            Rollback
          Endif
        Endif

        CODKIT_ANTERIOR = [YSPAD]YCODKIT
        Break
      Next
    Endif
  Next
  Filter [YSPAD]

  Close Local File [YSPDJM]
  Close Local File [YSPAD]
  Close Local File [YITM]
  Close Local File [YSPAD2]
End

Subprog IMPETIQSPACK(PPACNUM, PINFNAM, PDESTINO)
  Value     Char    PINFNAM
  Value     Char    PPACNUM
  Value     Char    PDESTINO

  Local Char    TBPAR(20)(1..20)
  Local Char    TBVAL(20)(1..20)
  Local Integer LIMPFAC # estado impresión factura
  # Fuerzo a que el informe a imprimir sea Y_SAN_ETIQBULTO
  # PINFNAM = "Y_SAN_ETIQBULTO"
  Raz TBPAR, TBVAL, LIMPFAC
  TBPAR(1)  = "Bulto"         : TBVAL(1)  = PPACNUM
  Call ETAT(PINFNAM, PDESTINO, "SPA", 0, "", TBPAR, TBVAL) From AIMP3
End

#**
#*
#* cambia el estado de la dcoumento  de preparación a "entregable"
#* Comprueba primero que no queda nada por entregar
#* Si el transportista es DACHSER lanzo la generación del envío del fichero de forma automática
#*
#* @param PPRHNUM, lista de distribución
#* @param PUSR, usuario que finaliza la preparación
#* @param PRES , resultado del web service
#* @param PMESS, mensaje
#*!

#Subprog TERMINARPREPARACION(PPRHNUM, PUSR, PCAMION,  PRES, PMESS)
#  # Entrada
#  Value Char PPRHNUM()
#  Value Char PUSR()
#  Value Integer PCAMION
#  # Salida
#  Variable Char PRES()
#  Variable Char PMESS()
#
#  Local Char LOK(1)
#  Local Char LNUM_ENTREGA(25) : Raz LNUM_ENTREGA
#
#  If !clalev([YPRH])  Then : Local File STOPREH      [YPRH]  : Endif
#  If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
#  If !clalev([YBPT])  Then : Local File BPCARRIER    [YBPT]  : Endif
#  If !clalev([YSPA])  Then : Local File YSPACK       [YSPA]  : Endif
#  If !clalev([YBPA])  Then : Local File BPADDRESS [YBPA]  : Endif
#
#    LOK="S"
#
#
#    Filter [F:YYPR2] Where PRHNUM=PPRHNUM and ([F:YYPR2]QTYSTU-[F:YYPR2]YQTYSTU) > 0 and [YYPR2]ALLQTY<>0
#    For [F:YYPR2]
#      LOK="N"
#      PRES="175"
#      PMESS="Preparación sin terminar. No se puede finalizar."
#      Break
#    Next
#    Filter [F:YYPR2]
#
#    # Solamente lo marco entregable si el transportista tiene en el campo Modo de Entrega = Entregable directo
#    If LOK="S"
#      Read [YPRH]PRH0=PPRHNUM
#      If !fstat Then
#        Read [YBPT]BPT0 = [YPRH]BPTNUM
#        If fstat = 0
#          If [YBPT]YMODENTREGA <> 1
#            LOK="N"
#            PRES = "200"
#            PMESS = "Modo de entrega NO directo. No se realiza ninguna acción adicional."
#          Endif
#        Else
#          LOK="N"
#        Endif
#      Else
#        LOK="N"
#      Endif
#    Endif
#
#    Local Char HORA(6)
#    HORA = num$(time$)
#    HORA = mid$(HORA, 1, 2) + mid$(HORA, 4, 2) + mid$(HORA, 7, 2)
#
#    # JMF - 20.06.24 - Guardamos la fecha y la hora de finalización de la preparación en los bultos
#    Filter [YSPA] Where VCRNUM = PPRHNUM
#    For [YSPA]
#      Trbegin [YSPA]
#      [YSPA]YFECHAP = date$
#      [YSPA]YHORAP = HORA
#      Rewrite [YSPA]
#      If !fstat
#        Commit
#      Else
#        Rollback
#      Endif
#    Next
#    Filter [YSPA]
#
## @01@ - SCD - 25/06/2024 - INI
#
#    Read [F:YPRH]PRH0=PPRHNUM
#    If !fstat Then
#      [F:YPRH]YESTADOPREP = 3
#      Rewrite [F:YPRH]
#    Endif
#
## @01@ - SCD - 25/06/2024 - FIN
#
#    # -----------------------------------
#
#    If LOK="S" Then
#      #Modificación 10/12/24. Actualizo las líneas del pedido de venta
#      If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
#      If !clalev([SOH])  Then : Local File SORDER   [SOH]  : Endif
#      If !clalev([SOQ])  Then : Local File SORDERQ  [SOQ]  : Endif
#      If !clalev([SOP])  Then : Local File SORDERP  [SOP]  : Endif
#      If clalev([M:ORDK])=0 Local Mask ORDK [ORDK] Endif
#
#      Filter [F:YYPR2] Where PRHNUM=PPRHNUM
#        For [F:YYPR2]
#          If find([F:YYPR2]ORITYP,1,2)
#           Call MAJ_SOQ (3,[F:YYPR2]ORINUM,[F:YYPR2]ORILIN,[F:YYPR2]ORISEQ,[F:YYPR2]PCU,[F:YYPR2]PCUSTUCOE,[F:YYPR2]QTYSTU) From STKPREPA
#           If GOK=0 Break Endif
#          Endif
#        Next
#      Filter [F:YYPR2]
#
#      If GOK = 0
#        End
#      Endif
#      #Modificación 10/12/24. Fin
#
#      Local Integer I
#      I=0
#      Read [F:YPRH]PRH0=PPRHNUM
#      If !fstat Then
#        Trbegin [F:YPRH]
#        [F:YPRH]DLVFLG = 2
#        [F:YPRH]YCAMION = PCAMION
#        Rewrite [F:YPRH]
#        If !fstat Then
#          Commit
#
#          # Si hemos llegado hasta aquí es porque el transportista tiene en el campo Modo de Entrega = Entregable directo,
#          # por lo que actualizamos todos los bultos a Cargado = Sí
#          Filter [YSPA] Where VCRNUM = PPRHNUM
#          For [YSPA]
#            Trbegin [YSPA]
#            [YSPA]YCARGADO = 2
#            Rewrite [YSPA]
#            If !fstat Then
#              Commit
#            Else
#              Rollback
#            Endif
#          Next
#
#          # @02@ - JMF - 15/07/2024 - Si la entrega es automática, generamos entregas
#          If [YBPT]YMODENTREGA = 1 Then
#            If [YBPT]YDOCUMENTA = 1 Then
#
#              #@04@ - Inicio
#              Local Char INFORME_PREP(20) : INFORME_PREP = "Y_SAN_DOCP_PRU"
#              Local Integer LRES_IMPR_PREP : Raz LRES_IMPR_PREP
#
#              Call PRINT_PPRHNUM([F:YPRH]PRHNUM, INFORME_PREP, 1, PUSR, LRES_IMPR_PREP)
#              #@04@ - Fin
#
#              YGUSERI3 = PUSR
#
#              # @05@ - Envío de documento de preparación a Dascher o transportistas con envío por email (ej: General Courier)
#              Case [YBPT]YTIPENVAGE
#                When 1: # Generación fichero integración con Dachser
#                  Local Integer LERR
#                  Local Char LOK
#                  Call DACHSER_CHECK(PPRHNUM,LERR) From YENVDACH
#
#                  # Si todo OK, genero fichero
#                  If LERR = 0
#                    LOK = ""
#                    Call DACHSER_GENERA_FICHERO(PPRHNUM,LOK) From YENVDACH
#                    If LOK = 'N'
#                      Call TRAZA_DACHSER(PPRHNUM,4,GUSER,2) From YENVDACH
#                    Else
#                      [F:YPRH]YDACESTADO  = 5
#                      [F:YPRH]YDACFECHA   = date$
#                      [F:YPRH]YDACHORA    = time$
#                      [F:YPRH]YDACUSUARIO = GUSER
#                      Trbegin [F:YPRH]
#                        Rewrite [F:YPRH]
#                      Commit
#                      Call TRAZA_DACHSER(PPRHNUM,5,GUSER,0) From YENVDACH
#                    Endif
#                  Endif
#                When 2: # Email
#                  #Borramos primero el fichero
#                    Local Char YNOMFIC(255) : YNOMFIC = filpath("FILES/SDH","preparacion_sanycces_" + PUSR, "pdf")
#                    Local Integer DEL_STA
#                    DEL_STA = Delfile(YNOMFIC)
#                    If DEL_STA = 0 or DEL_STA = -20 Then
#                      # Generamos PDF
#                      Call PRINT_PPRHNUM([F:YPRH]PRHNUM, INFORME_PREP, 2, PUSR, LRES_IMPR_PREP)
#                      # Esperamos a que se cree el fichero
#                      Local Integer I, J
#                      For I = 0 To 30
#                        Sleep 1
#                        J = filinfo(YNOMFIC, 7)
#                        If J > 0 Then
#                          Global Char GYRECIPIENT1(255), GYRECIPIENT2(255), GYRECIPIENT3(255), GYRECIPIENT4(255), GYRECIPIENT5(255), GYOBJETC(100),GYMAILTEXT(255), GYFILE(255), GYENTREGA(25)
#
#                          GYENTREGA = [F:YPRH]PRHNUM
#
#                          Read [YBPA]BPA0 = 1;[YPRH]BPTNUM;[YBPT]BPAADD
#                          If !fstat Then
#                            GYRECIPIENT1 = "marta.bermejo@nunsys.com"
#
##                            If [YBPA]WEB(0) <> "" Then
##                              GYRECIPIENT2 = [YBPA]WEB(0)
##                            Endif
##                            If [YBPA]WEB(1) <> "" Then
##                              GYRECIPIENT3 = [YBPA]WEB(1)
##                            Endif
##                            If [YBPA]WEB(2) <> "" Then
##                              GYRECIPIENT4 = [YBPA]WEB(2)
##                            Endif
##                            If [YBPA]WEB(3) <> "" Then
##                              GYRECIPIENT5 = [YBPA]WEB(3)
##                            Endif
#
#                            GYOBJETC    = "SANYCCES - Preparación " + GYENTREGA
#                            #GYMAILTEXT  = "Es es un mensaje de prueba para el número de entrega " + LNUM_ENTREGA
#                            GYFILE = YNOMFIC
#
#                            Call WORKFLOW(1,"YMA","",PUSR) From AWRK
#                          Endif
#
#                          Kill GYRECIPIENT1
#                          Kill GYRECIPIENT2
#                          Kill GYRECIPIENT3
#                          Kill GYRECIPIENT4
#                          Kill GYRECIPIENT5
#                          Kill GYOBJETC
#                          Kill GYMAILTEXT
#                          Kill GYFILE
#                          Kill GYENTREGA
#
#                          Break
#                        Endif
#                      Next I
#                    Endif
#              Endcase
#
#              # Generamos la/s entrega/s
#              #Call MAKE_SDH(PPRHNUM, LNUM_ENTREGA)
#              # @05@ - Fin
#            Endif
#          Endif
#
##          #@04@ - Inicio
##          Local Char INFORME_PREP(20) : INFORME_PREP = "Y_SAN_DOCP_PRU"
##          Local Integer LRES_IMPR_PREP : Raz LRES_IMPR_PREP
##
##          Call PRINT_PPRHNUM([F:YPRH]PRHNUM, INFORME_PREP, 1, PUSR, LRES_IMPR_PREP)
##          #@04@ - Fin
##
##
##          # @02@ - JMF - 15/07/2024 - Si la entrega es automática, generamos entregas
##          Local Char INFORME : INFORME = "YBONLIV"
##          Local Integer LRES_IMPR : Raz LRES_IMPR
##          If [YBPT]YMODENTREGA = 1 Then
##            If [YBPT]YDOCUMENTA = 1 Then
##              Call MAKE_SDH(PPRHNUM, LNUM_ENTREGA)
##            Endif
##            If LNUM_ENTREGA <> "" Then
##              YGUSERI3 = PUSR
##              # Imprimimos por impresora
##              Call PRINT_SDH(LNUM_ENTREGA, INFORME, 1, PUSR, LRES_IMPR)
##
##              Case [YBPT]YTIPENVAGE
##                When 1: # Dachser
##                  Local Integer LERR
##                  Local Char LOK
##                  Call DACHSER_CHECK(PPRHNUM,LERR) From YENVDACH
##
##                  # Si todo OK, genero fichero
##                  If LERR = 0
##                    LOK = ""
##                    Call DACHSER_GENERA_FICHERO(PPRHNUM,LOK) From YENVDACH
##                    If LOK = 'N'
##                      Call TRAZA_DACHSER(PPRHNUM,4,GUSER,2) From YENVDACH
##                    Else
##                      [F:YPRH]YDACESTADO  = 5
##                      [F:YPRH]YDACFECHA   = date$
##                      [F:YPRH]YDACHORA    = time$
##                      [F:YPRH]YDACUSUARIO = GUSER
##                      Trbegin [F:YPRH]
##                        Rewrite [F:YPRH]
##                      Commit
##                      Call TRAZA_DACHSER(PPRHNUM,5,GUSER,0) From YENVDACH
##                    Endif
##                  Endif
##
##                When 2: # Email
##                  #########################################
##                  # GESTIÓN ENVÍO EMAIL
##                  #########################################
##                  #Borramos primero el fichero
##                  Local Char YNOMFIC(255) : YNOMFIC = filpath("FILES/SDH","entrega_sanycces_" + PUSR, "pdf")
##                  Local Integer DEL_STA
##                  DEL_STA = Delfile(YNOMFIC)
##                  If DEL_STA = 0 or DEL_STA = -20 Then
##                    # Generamos PDF
##                    Call PRINT_SDH(LNUM_ENTREGA, INFORME, 2, PUSR, LRES_IMPR)
##                    # Esperamos a que se cree el fichero
##                    Local Integer I, J
##                    For I = 0 To 45
##                      Sleep 1
##                      J = filinfo(YNOMFIC, 7)
##                      If J > 0 Then
##                        Global Char GYRECIPIENT1(255), GYRECIPIENT2(255), GYRECIPIENT3(255), GYRECIPIENT4(255), GYRECIPIENT5(255), GYOBJETC(100), GYFILE(255), GYENTREGA(25)
##                        GYENTREGA = LNUM_ENTREGA
##                        Read [YBPA]BPA0 = 1;[YPRH]BPTNUM;[YBPT]BPAADD
##                        If !fstat Then
##                          GYRECIPIENT1 = "cargas@sanycces.es"
##
##                          If [YBPA]WEB(0) <> "" Then
##                            GYRECIPIENT2 = [YBPA]WEB(0)
##                          Endif
##                          If [YBPA]WEB(1) <> "" Then
##                            GYRECIPIENT3 = [YBPA]WEB(1)
##                          Endif
##                          If [YBPA]WEB(2) <> "" Then
##                            GYRECIPIENT4 = [YBPA]WEB(2)
##                          Endif
##                          If [YBPA]WEB(3) <> "" Then
##                            GYRECIPIENT5 = [YBPA]WEB(3)
##                          Endif
##
##                          GYOBJETC    = "SANYCCES - Envío entrega " + LNUM_ENTREGA
##                          #GYMAILTEXT  = "Es es un mensaje de prueba para el número de entrega " + LNUM_ENTREGA
##                          GYFILE = YNOMFIC
##
##                          Call WORKFLOW(1,"YMA","",PUSR) From AWRK
##                        Endif
##
##                        Kill GYRECIPIENT1
##                        Kill GYRECIPIENT2
##                        Kill GYRECIPIENT3
##                        Kill GYRECIPIENT4
##                        Kill GYRECIPIENT5
##                        Kill GYOBJETC
##                        Kill GYFILE
##                        Kill GYENTREGA
##
##                        Break
##                      Endif
##                    Next I
##                  Endif
##
##              Endcase
##            Endif
##          Endif
#
#          PRES="200"
#          PMESS="OK"
#        Else
#          Rollback
#          PRES="100"
#          PMESS="Problema modificando entregable en: " +PPRHNUM
#          End
#        Endif
#      Else
#        PRES="150"
#        PMESS="No existe: "+PPRHNUM
#      Endif
#    Endif
#
#  Close Local File [F:YPRH], [F:YYPR2], [YBPT], [YSPA], [YBPA]
#End

Subprog TERMINARPREPARACION(PPRHNUM, PUSR, PCAMION,  PRES, PMESS)
  # Entrada
  Value Char PPRHNUM()
  Value Char PUSR()
  Value Integer PCAMION
  # Salida
  Variable Char PRES()
  Variable Char PMESS()

  Local Char LOK(1)
  Local Char LNUM_ENTREGA(25) : Raz LNUM_ENTREGA

  If !clalev([YPRH])  Then : Local File STOPREH      [YPRH]  : Endif
  If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
  If !clalev([YBPT])  Then : Local File BPCARRIER    [YBPT]  : Endif
  If !clalev([YSPA])  Then : Local File YSPACK       [YSPA]  : Endif
  If !clalev([YBPA])  Then : Local File BPADDRESS [YBPA]  : Endif

    LOK="S"


    # @05@ - JMF
#    Filter [F:YYPR2] Where PRHNUM=PPRHNUM and ([F:YYPR2]QTYSTU-[F:YYPR2]YQTYSTU) > 0 and [YYPR2]ALLQTY<>0
    Filter [F:YYPR2] Where PRHNUM=PPRHNUM and [YYPR2]ALLQTY<>0
    For [F:YYPR2]
      Local Decimal CANT_EMPAQUETADA
      CANT_EMPAQUETADA = func GETCANTIDADEMPAQUETADA(PPRHNUM, [YYPR2]PRELIN)
      If [F:YYPR2]QTYSTU - [L]CANT_EMPAQUETADA > 0 Then
        LOK="N"
        PRES="175"
        PMESS="Preparación sin terminar. No se puede finalizar."
        Break
      Endif
    Next
    Filter [F:YYPR2]

    # Solamente lo marco entregable si el transportista tiene en el campo Modo de Entrega = Entregable directo
    If LOK="S"
      Read [YPRH]PRH0=PPRHNUM
      If !fstat Then
        Read [YBPT]BPT0 = [YPRH]BPTNUM
        If fstat = 0
          If [YBPT]YMODENTREGA <> 1
            LOK="N"
            PRES = "200"
            PMESS = "Modo de entrega NO directo. No se realiza ninguna acción adicional."
          Endif
        Else
          LOK="N"
        Endif
      Else
        LOK="N"
      Endif
    Endif

    Local Char HORA(6)
    HORA = num$(time$)
    HORA = mid$(HORA, 1, 2) + mid$(HORA, 4, 2) + mid$(HORA, 7, 2)

    # JMF - 20.06.24 - Guardamos la fecha y la hora de finalización de la preparación en los bultos
    Filter [YSPA] Where VCRNUM = PPRHNUM
    For [YSPA]
      Trbegin [YSPA]
      [YSPA]YFECHAP = date$
      [YSPA]YHORAP = HORA
      Rewrite [YSPA]
      If !fstat
        Commit
      Else
        Rollback
      Endif
    Next
    Filter [YSPA]

# @01@ - SCD - 25/06/2024 - INI

    Read [F:YPRH]PRH0=PPRHNUM
    If !fstat Then
      [F:YPRH]YESTADOPREP = 3
      Rewrite [F:YPRH]
    Endif

# @01@ - SCD - 25/06/2024 - FIN

    # -----------------------------------

    If LOK="S" Then
      #Modificación 10/12/24. Actualizo las líneas del pedido de venta
      If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
      If !clalev([SOH])  Then : Local File SORDER   [SOH]  : Endif
      If !clalev([SOQ])  Then : Local File SORDERQ  [SOQ]  : Endif
      If !clalev([SOP])  Then : Local File SORDERP  [SOP]  : Endif
      If clalev([M:ORDK])=0 Local Mask ORDK [ORDK] Endif

      Filter [F:YYPR2] Where PRHNUM=PPRHNUM
        For [F:YYPR2]
          If find([F:YYPR2]ORITYP,1,2)
           Call MAJ_SOQ (3,[F:YYPR2]ORINUM,[F:YYPR2]ORILIN,[F:YYPR2]ORISEQ,[F:YYPR2]PCU,[F:YYPR2]PCUSTUCOE,[F:YYPR2]QTYSTU) From STKPREPA
           If GOK=0 Break Endif
          Endif
        Next
      Filter [F:YYPR2]

      If GOK = 0
        End
      Endif
      #Modificación 10/12/24. Fin

      Local Integer I
      I=0
      Read [F:YPRH]PRH0=PPRHNUM
      If !fstat Then
        Trbegin [F:YPRH]
        [F:YPRH]DLVFLG = 2
        [F:YPRH]YCAMION = PCAMION
        Rewrite [F:YPRH]
        If !fstat Then
          Commit

          # Si hemos llegado hasta aquí es porque el transportista tiene en el campo Modo de Entrega = Entregable directo,
          # por lo que actualizamos todos los bultos a Cargado = Sí
          Filter [YSPA] Where VCRNUM = PPRHNUM
          For [YSPA]
            Trbegin [YSPA]
            [YSPA]YCARGADO = 2
            Rewrite [YSPA]
            If !fstat Then
              Commit
            Else
              Rollback
            Endif
          Next

          # @02@ - JMF - 15/07/2024 - Si la entrega es automática, generamos entregas
          If [YBPT]YMODENTREGA = 1 Then
            If [YBPT]YDOCUMENTA = 1 Then

              #@04@ - Inicio
              Local Char INFORME_PREP(20) : INFORME_PREP = "Y_SAN_DOCP_PRU"
              Local Integer LRES_IMPR_PREP : Raz LRES_IMPR_PREP

              Call PRINT_PPRHNUM([F:YPRH]PRHNUM, INFORME_PREP, 1, PUSR, LRES_IMPR_PREP)
              #@04@ - Fin

              YGUSERI3 = PUSR

              # @05@ - Envío de documento de preparación a Dascher o transportistas con envío por email (ej: General Courier)
              Case [YBPT]YTIPENVAGE
                When 1: # Generación fichero integración con Dachser
                  Local Integer LERR
                  Local Char LOK
                  Call DACHSER_CHECK(PPRHNUM,LERR) From YENVDACH

                  # Si todo OK, genero fichero
                  If LERR = 0
                    LOK = ""
                    Call DACHSER_GENERA_FICHERO(PPRHNUM,LOK) From YENVDACH
                    If LOK = 'N'
                      Call TRAZA_DACHSER(PPRHNUM,4,GUSER,2) From YENVDACH
                    Else
                      [F:YPRH]YDACESTADO  = 5
                      [F:YPRH]YDACFECHA   = date$
                      [F:YPRH]YDACHORA    = time$
                      [F:YPRH]YDACUSUARIO = GUSER
                      Trbegin [F:YPRH]
                        Rewrite [F:YPRH]
                      Commit
                      Call TRAZA_DACHSER(PPRHNUM,5,GUSER,0) From YENVDACH
                    Endif
                  Endif
                When 2: # Email
                  #Borramos primero el fichero
                    Local Char YNOMFIC(255) : YNOMFIC = filpath("FILES/SDH","preparacion_sanycces_" + PUSR, "pdf")
                    Local Integer DEL_STA
                    DEL_STA = Delfile(YNOMFIC)
                    If DEL_STA = 0 or DEL_STA = -20 Then
                      # Generamos PDF
                      Call PRINT_PPRHNUM([F:YPRH]PRHNUM, INFORME_PREP, 2, PUSR, LRES_IMPR_PREP)
                      # Esperamos a que se cree el fichero
                      Local Integer I, J
                      For I = 0 To 30
                        Sleep 1
                        J = filinfo(YNOMFIC, 7)
                        If J > 0 Then
                          Global Char GYRECIPIENT1(255), GYRECIPIENT2(255), GYRECIPIENT3(255), GYRECIPIENT4(255), GYRECIPIENT5(255), GYOBJETC(100),GYMAILTEXT(255), GYFILE(255), GYENTREGA(25)

                          GYENTREGA = [F:YPRH]PRHNUM

                          Read [YBPA]BPA0 = 1;[YPRH]BPTNUM;[YBPT]BPAADD
                          If !fstat Then
                            GYRECIPIENT1 = "cargas@sanycces.es"

                            If [YBPA]WEB(0) <> "" Then
                              GYRECIPIENT2 = [YBPA]WEB(0)
                            Endif
                            If [YBPA]WEB(1) <> "" Then
                              GYRECIPIENT3 = [YBPA]WEB(1)
                            Endif
                            If [YBPA]WEB(2) <> "" Then
                              GYRECIPIENT4 = [YBPA]WEB(2)
                            Endif
                            If [YBPA]WEB(3) <> "" Then
                              GYRECIPIENT5 = [YBPA]WEB(3)
                            Endif

                            GYOBJETC    = "SANYCCES - Preparación " + GYENTREGA
                            #GYMAILTEXT  = "Es es un mensaje de prueba para el número de entrega " + LNUM_ENTREGA
                            GYFILE = YNOMFIC

                            Call WORKFLOW(1,"YMA","",PUSR) From AWRK
                          Endif

                          Kill GYRECIPIENT1
                          Kill GYRECIPIENT2
                          Kill GYRECIPIENT3
                          Kill GYRECIPIENT4
                          Kill GYRECIPIENT5
                          Kill GYOBJETC
                          Kill GYMAILTEXT
                          Kill GYFILE
                          Kill GYENTREGA

                          Break
                        Endif
                      Next I
                    Endif
              Endcase

              # Generamos la/s entrega/s
              #Call MAKE_SDH(PPRHNUM, LNUM_ENTREGA)
              # @05@ - Fin
            Endif
          Endif

#          #@04@ - Inicio
#          Local Char INFORME_PREP(20) : INFORME_PREP = "Y_SAN_DOCP_PRU"
#          Local Integer LRES_IMPR_PREP : Raz LRES_IMPR_PREP
#
#          Call PRINT_PPRHNUM([F:YPRH]PRHNUM, INFORME_PREP, 1, PUSR, LRES_IMPR_PREP)
#          #@04@ - Fin
#
#
#          # @02@ - JMF - 15/07/2024 - Si la entrega es automática, generamos entregas
#          Local Char INFORME : INFORME = "YBONLIV"
#          Local Integer LRES_IMPR : Raz LRES_IMPR
#          If [YBPT]YMODENTREGA = 1 Then
#            If [YBPT]YDOCUMENTA = 1 Then
#              Call MAKE_SDH(PPRHNUM, LNUM_ENTREGA)
#            Endif
#            If LNUM_ENTREGA <> "" Then
#              YGUSERI3 = PUSR
#              # Imprimimos por impresora
#              Call PRINT_SDH(LNUM_ENTREGA, INFORME, 1, PUSR, LRES_IMPR)
#
#              Case [YBPT]YTIPENVAGE
#                When 1: # Dachser
#                  Local Integer LERR
#                  Local Char LOK
#                  Call DACHSER_CHECK(PPRHNUM,LERR) From YENVDACH
#
#                  # Si todo OK, genero fichero
#                  If LERR = 0
#                    LOK = ""
#                    Call DACHSER_GENERA_FICHERO(PPRHNUM,LOK) From YENVDACH
#                    If LOK = 'N'
#                      Call TRAZA_DACHSER(PPRHNUM,4,GUSER,2) From YENVDACH
#                    Else
#                      [F:YPRH]YDACESTADO  = 5
#                      [F:YPRH]YDACFECHA   = date$
#                      [F:YPRH]YDACHORA    = time$
#                      [F:YPRH]YDACUSUARIO = GUSER
#                      Trbegin [F:YPRH]
#                        Rewrite [F:YPRH]
#                      Commit
#                      Call TRAZA_DACHSER(PPRHNUM,5,GUSER,0) From YENVDACH
#                    Endif
#                  Endif
#
#                When 2: # Email
#                  #########################################
#                  # GESTIÓN ENVÍO EMAIL
#                  #########################################
#                  #Borramos primero el fichero
#                  Local Char YNOMFIC(255) : YNOMFIC = filpath("FILES/SDH","entrega_sanycces_" + PUSR, "pdf")
#                  Local Integer DEL_STA
#                  DEL_STA = Delfile(YNOMFIC)
#                  If DEL_STA = 0 or DEL_STA = -20 Then
#                    # Generamos PDF
#                    Call PRINT_SDH(LNUM_ENTREGA, INFORME, 2, PUSR, LRES_IMPR)
#                    # Esperamos a que se cree el fichero
#                    Local Integer I, J
#                    For I = 0 To 45
#                      Sleep 1
#                      J = filinfo(YNOMFIC, 7)
#                      If J > 0 Then
#                        Global Char GYRECIPIENT1(255), GYRECIPIENT2(255), GYRECIPIENT3(255), GYRECIPIENT4(255), GYRECIPIENT5(255), GYOBJETC(100), GYFILE(255), GYENTREGA(25)
#                        GYENTREGA = LNUM_ENTREGA
#                        Read [YBPA]BPA0 = 1;[YPRH]BPTNUM;[YBPT]BPAADD
#                        If !fstat Then
#                          GYRECIPIENT1 = "cargas@sanycces.es"
#
#                          If [YBPA]WEB(0) <> "" Then
#                            GYRECIPIENT2 = [YBPA]WEB(0)
#                          Endif
#                          If [YBPA]WEB(1) <> "" Then
#                            GYRECIPIENT3 = [YBPA]WEB(1)
#                          Endif
#                          If [YBPA]WEB(2) <> "" Then
#                            GYRECIPIENT4 = [YBPA]WEB(2)
#                          Endif
#                          If [YBPA]WEB(3) <> "" Then
#                            GYRECIPIENT5 = [YBPA]WEB(3)
#                          Endif
#
#                          GYOBJETC    = "SANYCCES - Envío entrega " + LNUM_ENTREGA
#                          #GYMAILTEXT  = "Es es un mensaje de prueba para el número de entrega " + LNUM_ENTREGA
#                          GYFILE = YNOMFIC
#
#                          Call WORKFLOW(1,"YMA","",PUSR) From AWRK
#                        Endif
#
#                        Kill GYRECIPIENT1
#                        Kill GYRECIPIENT2
#                        Kill GYRECIPIENT3
#                        Kill GYRECIPIENT4
#                        Kill GYRECIPIENT5
#                        Kill GYOBJETC
#                        Kill GYFILE
#                        Kill GYENTREGA
#
#                        Break
#                      Endif
#                    Next I
#                  Endif
#
#              Endcase
#            Endif
#          Endif

          PRES="200"
          PMESS="OK"
        Else
          Rollback
          PRES="100"
          PMESS="Problema modificando entregable en: " +PPRHNUM
          End
        Endif
      Else
        PRES="150"
        PMESS="No existe: "+PPRHNUM
      Endif
    Endif

  Close Local File [F:YPRH], [F:YYPR2], [YBPT], [YSPA], [YBPA]
End

#**
#* Sub que devuelve las listas de preparación sin entregar
#*
#*!
Subprog PREPARACIONESSINENTREGAR(PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE, PPRHNUM , PPREUSR, PSTOFCY, PPRLNUM,  PBPCORD, PBPCNAM,  PBPTNUM, PBPTDES, PDLVDAT)
  # Entrada
  Value Char PDVLDATDESDE()
  Value Char PDVLDATHASTA()
  Value Char PBPCORDDESDE()
  Value Char PBTNUMDESDE()
  # Salida 1
  Variable Char PPRHNUM()()
  Variable Char PPREUSR()()
  Variable Char PSTOFCY()()
  Variable Char PPRLNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PBPTNUM()()
  Variable Char PBPTDES()()
  Variable Char PDLVDAT()()

  Local Char CRITERE(250)(19) : CRITERE(0) ="1=1"
  Local    Char LFCY
  Local Integer YESTADOPREP

  If !clalev([YPRH]) Then : Local File STOPREH     [YPRH] : Endif
  If !clalev([YPBC]) Then : Local File BPCUSTOMER  [YPBC] : Endif
  If !clalev([YPBR]) Then : Local File BPARTNER    [YPBR] : Endif
  If !clalev([YBPT]) Then : Local File BPCARRIER   [YBPT] : Endif

 Raz CRITERE

 CRITERE(0)="[YPRH]DLVFLG = 1"

  #fecha envío
  If PDVLDATDESDE <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT>=[" + (PDVLDATDESDE) + "]"
  Endif
  If PDVLDATHASTA <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT<=[" + (PDVLDATHASTA) + "]"
  Endif
 #Cliente
  If PBPCORDDESDE <> "" Then
    CRITERE(2) += " & [YPRH]BPCORD='" + PBPCORDDESDE + "'"
  Endif
#transportista
  If PBTNUMDESDE <> "" Then
    CRITERE(3) += " & [YPRH]BPTNUM='" + PBTNUMDESDE + "'"
  Endif

  Local Integer I : I = 0

  Filter [F:YPRH] Where evalue(CRITERE(0..9))

  For [F:YPRH]
    YESTADOPREP = func SPEPRH.ESTADO_VALE([F:YPRH]PRHNUM)

    If YESTADOPREP = 3 Then
      PPRHNUM(I)=[F:YPRH]PRHNUM
      PPREUSR(I)=[F:YPRH]PREUSR
      PSTOFCY(I)=[F:YPRH]STOFCY
      PPRHNUM(I)=[F:YPRH]PRHNUM
      PPRLNUM(I)=[F:YPRH]PRLNUM
      PBPCORD(I)=[F:YPRH]BPCORD
      PBPTNUM(I)=[F:YPRH]BPTNUM
      PDLVDAT(I)=num$([F:YPRH]SHIDAT)
      Read [YPBR]BPR0=[F:YPRH]BPCORD
      If !fstat Then
        PBPCNAM(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)
      Endif
      If [F:YPRH]BPTNUM<>""
        Read [YBPT]BPT0=[F:YPRH]BPTNUM
        If !fstat Then
          PBPTDES(I) = [YBPT]BPTNAM
        Endif
      Endif

      I+=1
    Endif
  Next

  Close Local File [YPRH], [YPBC], [YPBR]
End

Subprog MARCARPREPARACIONENTREGABLE(PPRHNUM, PRES)
  # Entrada
  Value Char PPRHNUM
  # Salida
  Variable Integer PRES

  PRES = 0

  If !clalev([YPRH]) : Local File STOPREH [YPRH] : Endif

  #Modificación 10/12/24. Actualizo las líneas del pedido de venta
  If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
  If !clalev([SOH])  Then : Local File SORDER   [SOH]  : Endif
  If !clalev([SOQ])  Then : Local File SORDERQ  [SOQ]  : Endif
  If !clalev([SOP])  Then : Local File SORDERP  [SOP]  : Endif
  If clalev([M:ORDK])=0 Local Mask ORDK [ORDK] Endif

  Filter [F:YYPR2] Where PRHNUM=PPRHNUM
    For [F:YYPR2]
      If find([F:YYPR2]ORITYP,1,2)
       Call MAJ_SOQ (3,[F:YYPR2]ORINUM,[F:YYPR2]ORILIN,[F:YYPR2]ORISEQ,[F:YYPR2]PCU,[F:YYPR2]PCUSTUCOE,[F:YYPR2]QTYSTU) From STKPREPA
       If GOK=0 Break Endif
      Endif
    Next
  Filter [F:YYPR2]

  If GOK = 0
    End
  Endif
  #Modificación 10/12/24. Fin


  Read [YPRH]PRH0 = PPRHNUM
  If !fstat Then
    Trbegin [YPRH]
    If !fstat Then
      [YPRH]DLVFLG = 2
      Rewrite [YPRH]
      If !fstat Then
        Commit
        PRES = 1
      Else
        Rollback
      Endif
    Endif
  Endif

  Close Local File [YPRH]
End

Subprog MARCARBULTOCARGADO(PCOD_BULTO)
  Value Char PCOD_BULTO

  If !clalev([YSPA]) : Local File YSPACK [YSPA]: Endif

  Filter [YSPA] Where PACNUM = PCOD_BULTO
  Read [YSPA] First
  If !fstat
    Trbegin [YSPA]
    If !fstat
      [YSPA]YCARGADO = 2
      Rewrite [YSPA]
      If !fstat
        Commit
      Else
        Rollback
      Endif
    Endif
  Endif

  Filter [YSPA]

  Close Local File [YSPA]
End


Funprog GETPACIND(PCOD_PREPARACION, PPACNUM)
  Value Char PCOD_PREPARACION
  Value Char PPACNUM

  Local Integer LRET : LRET = 0

  If !clalev([YSPACK2]) : Local File YSPACKD [YSPACK2] : Endif

  Filter [YSPACK2] Where VCRNUM = PCOD_PREPARACION and PACNUM = PPACNUM Order By PACIND
  Read [YSPACK2] Last
  If !fstat
    LRET = [YSPACK2]PACIND + 1
  Endif

  Close Local File [YSPACK2]
End LRET

Funprog GETCANTIDADBULTOKIT(PCOD_PREPARACION, PCOD_BULTO, PCOD_ARTICULO)
  Value Char PCOD_PREPARACION
  Value Char PCOD_BULTO
  Value Char PCOD_ARTICULO

  Local Decimal LRET : LRET = 0

  If !clalev([YSPACKD]) : Local File YSPACKD [YSPACKD] : Endif

  Filter [YSPACKD] Where VCRNUM = PCOD_PREPARACION and PACNUM = PCOD_BULTO and ITMREF = PCOD_ARTICULO
  For [YSPACKD]
    LRET += [YSPACKD]QTYPCU
  Next

  Close Local File [YSPACKD]
End LRET

Subprog PRINT_SDH(VSDH, VINF, VPDF, PUSR, RES)
  # Entrada
  Value Char VSDH   # Número de la entrega
  Value Char VINF   # Código informe
  Value Integer VPDF # Generar PDF (1 = 'No' // 2 = 'Sí')
  Value Char PUSR
  # Salida
  Variable Integer RES

  Local Char VDES   # Destino de impresión
  Local Char TBVAL(30)(20)
  Local Char TBPAR(30)(20)

  If !clalev([YSDH]) : Local File SDELIVERY [YSDH] : Endif
  Read [YSDH]SDH0 = VSDH
  If !fstat
    TBPAR(1) = "sitedeb"
    TBVAL(1) = [YSDH]STOFCY

    TBPAR(2) = "sitefin"
    TBVAL(2) = [YSDH]STOFCY

    TBPAR(3) = "Livraisondeb"
    TBVAL(3) = VSDH

    TBPAR(4) = "Livraisonfin"
    TBVAL(4) = VSDH

    TBPAR(5) = "clientdeb"
    TBVAL(5) = [YSDH]BPCORD

    TBPAR(6) = "clientfin"
    TBVAL(6) = [YSDH]BPCORD

    TBPAR(7) = "datedeb"
    TBVAL(7) = [YSDH]DLVDAT

    TBPAR(8) = "datefin"
    TBVAL(8) = [YSDH]DLVDAT

    TBPAR(9) = "valdeb"
    TBVAL(9) = "1"

    TBPAR(10) = "valfin"
    TBVAL(10) = "2"

    TBPAR(11) = "facdeb"
    TBVAL(11) = "1"

    TBPAR(12) = "facfin"
    TBVAL(12) = "2"

    If !clalev([X1]) : Local File SDELIVERY  [X1] : Endif

    If VPDF = 1 Then
      TBPAR(13) = "codimp"
      TBVAL(13) = "1"    # Impresión
    Else
      Read [X1]SDH0 = VSDH
      If fstat = 0
        If [X1]PRNNDE = 2
          TBPAR(13) = "codimp"
          TBVAL(13) = "2"    # Reimpresión
        Else
          TBPAR(13) = "codimp"
          TBVAL(13) = "1"    # Impresión
        Endif
      Endif
    Endif

    VDES = func YX3MOBPREPICKING.GETDESTINOINFORME(VINF, PUSR)

    Close Local File [X1]

    If VINF <> "" and VDES <> ""
      If VPDF = 2 Then
        VDES = "PDF"
      Endif
        Call ETAT(VINF,VDES,"",0,"",TBPAR,TBVAL) From AIMP3
        RES = fstat
    Endif

  Endif

  Close Local File [YSDH]
End

Subprog MAKE_SDH(VPRE, VNUM)
  # Entrada
  Value Char VPRE
  # Salida
  Variable Char VNUM

  If !clalev([M:YGSDH])  Local Mask YGENSDH     [YGSDH]   Endif

  Default Mask [YGSDH]

  [M:YGSDH]SOCIEDAD = "1"
  [M:YGSDH]PLANTA   = "11"
  [M:YGSDH]TIPOSDH  = "SDH"
  [M:YGSDH]PREPARAINI  = VPRE
  [M:YGSDH]PREPARAFIN  = VPRE

  Local Integer TRACE : TRACE = 1 # 1 = No Traza --- 2 = Si Traza

  Call GEN_SDH([L]TRACE, VNUM) From SPEYGSDH

  Close Local Mask [YGSDH]
End

Subprog GETKITSPENDIENTES(PPRHNUM, PCOD_EAN, COD_KIT, DESC_KIT, LINEA_KIT)
  # Entrada
  Value Char PPRHNUM
  Value Char PCOD_EAN
  # Salida
  Variable Char COD_KIT()()
  Variable Char DESC_KIT()()
  Variable Integer LINEA_KIT()

  Local Integer I : I = 0
  Local Decimal PROPORCION_COMPUESTO : Raz PROPORCION_COMPUESTO
  Local Decimal CANTIDAD_EMPAQUETADA : Raz CANTIDAD_EMPAQUETADA
  Local Char LREQ(250)(4) : Raz LREQ
  Local Char LCOD_COMPUESTO(25) : Raz LCOD_COMPUESTO

  If !clalev([YSPDL]) : Local File STOPRED [YSPDL]  : Endif
  If !clalev([YITM])  : Local File ITMMASTER [YITM] : Endif

  Filter [YITM] Where EANCOD = PCOD_EAN
    If rowcount([YITM]) > 0 Then
    Read [YITM] First
    LCOD_COMPUESTO = [YITM]ITMREF

    Infbox(LCOD_COMPUESTO)

    LREQ(0) = "SELECT PRELIN_0, ITMREF_0, ITMDES1_0, QTYSTU_0 FROM " + nomap + ".STOPRED "
    LREQ(1) = "WHERE PRHNUM_0 = '" + PPRHNUM + "' and LINTYP_0 = 2 AND ITMREF_0 IN "
    LREQ(2) = "(SELECT DISTINCT ITMREF_0 FROM " + nomap + ".BOMD B WHERE BOMALT_0 = 10 AND "
    LREQ(3) = "B.CPNITMREF_0 = '" + LCOD_COMPUESTO + "' AND BOMALTTYP_0 = 1 AND "
    LREQ(3) += "BOMSTRDAT_0 <= GETDATE() AND (BOMENDDAT_0 >= GETDATE() OR BOMENDDAT_0 = '01/01/1753'))"

    For(Integer PRELIN, Char ITMREF, Char ITMDES1, Decimal QTYSTU) From "5" Sql LREQ As [YSPD]
      Filter [YSPDL] Where PRHNUM = PPRHNUM and ITMREF = LCOD_COMPUESTO and PRELIN > [YSPD]PRELIN
      Read [YSPDL] First
      If !fstat
        PROPORCION_COMPUESTO = func GETPROPORCIONCOMPUESTOKIT([YSPD]ITMREF, [YSPDL]ITMREF)
        CANTIDAD_EMPAQUETADA = func GETCANTIDADEMPAQUETADA([YSPDL]PRHNUM, [YSPDL]PRELIN)

        If PROPORCION_COMPUESTO <> 0 Then
          If (CANTIDAD_EMPAQUETADA / PROPORCION_COMPUESTO) <> [YSPD]QTYSTU Then
            COD_KIT(I) = [YSPD]ITMREF
            DESC_KIT(I) = [YSPD]ITMDES1
            LINEA_KIT(I) = [YSPD]PRELIN

            I += 1
          Endif
        Endif
      Endif
      Filter [YSPDL]
    Next
  Endif

  Close Local File [YSPDL]
  Close Local File [YITM]
End

Funprog GETCANTIDADEMPAQUETADA(PPRHNUM, PPRELIN)
  Value Char PPRHNUM
  Value Integer PPRELIN

  Local Decimal LRET : Raz LRET

  If !clalev([YSPACKD]) : Local File YSPACKD [YSPACKD] : Endif

  Filter [YSPACKD] Where VCRNUM = PPRHNUM and VCRLIN = PPRELIN
  For [YSPACKD]
    LRET += [YSPACKD]QTYPCU
  Next
  Filter [YSPACKD]

  Close Local File [YSPACKD]

End LRET

#@04@ - Inicio
#---------------------------------------------------------------------------------------------------#
#**
#* Subprograma que imprime un documento de preparación por el destino por defecto del usuario
#*
#* @param VPRH Número de documento de preparación
#* @param VINF Código del informe
#* @param VPDF Flag que determina si se imprime en PDF o por destino (1 = 'No' // 2 = 'Sí')
#* @param PUSR Código del usuario
#* @return RES resultado de la ejecución de la función
#*!
Subprog PRINT_PPRHNUM(VPRH, VINF, VPDF, PUSR, RES)
  # Entrada
  Value Char VPRH
  Value Char VINF
  Value Integer VPDF
  Value Char PUSR
  # Salida
  Variable Integer RES

  Local Char VDES(GLONAIM)   # Destino de impresión
  Local Char TBVAL(30)(20)
  Local Char TBPAR(30)(20)

  If !clalev([F:YPRHAUX]) : Local File STOPREH [YPRHAUX] : Endif
  Read [F:YPRHAUX]PRH0 = VPRH
  If !fstat
    TBPAR(1) = "VCRNUM"
    TBVAL(1) = [F:YPRHAUX]PRHNUM

    TBPAR(2) = "EAN13"
    TBVAL(2) = "1"

    VDES = func YX3MOBPREPICKING.GETDESTINOINFORME(VINF, PUSR)

    If VINF <> "" and VDES <> ""
      If VPDF = 2 Then
        VDES = "PDF"
      Endif

      Call ETAT(VINF,VDES,"",0,"",TBPAR,TBVAL) From AIMP3
      RES = fstat
    Else
      RES = 1
    Endif

  Else
    RES = fstat
  Endif

  Close Local File [YPRHAUX]
End
#---------------------------------------------------------------------------------------------------#
#@04@ - Fin

Subprog GETBLOQUEOSPEDIDOS(PNUM_VALE, BLOQUEOS)
  # Entrada
  Value Char PNUM_VALE
  # Salida
  Variable Char BLOQUEOS()()

  If !clalev([YLCK]) : Local File APLLCK [YLCK] : Endif

  Local Integer I : Raz I
  Local Char LREQ(255)

  LREQ = "SELECT DISTINCT ORINUM_0 FROM " + nomap + ".STOPRED WHERE PRHNUM_0 = '" + PNUM_VALE + "'"
  For(Char ORINUM) From "5" Sql LREQ As [YPED]
    Read [YLCK]LCKCLE = "SOH" + ORINUM;0
    If !fstat
      BLOQUEOS(I) = mid$([YLCK]LCKSYM, 4, len([YLCK]LCKSYM) - 3)

      I += 1
    Endif
  Next

  Close Local File [YLCK]
End

Subprog GETBLOQUEOPREPARACION(PNUM_VALE, BLOQUEADO)
  # Entrada
  Value Char PNUM_VALE
  # Salida
  Variable Integer BLOQUEADO

  BLOQUEADO = 1

  If !clalev([YLCK]) : Local File APLLCK [YLCK] : Endif

  Read [YLCK]LCKCLE = "PRH" + PNUM_VALE;0
  If !fstat
    BLOQUEADO = 2
  Endif

  Close Local File [YLCK]
End
