#<AdxTL>@(#)0.0.0.0 $Revision$
####################################################################
#**
#* Sub que devuelve los clientes de la lista de preparción en curso
#*
#*!
Subprog GETLISTCLIENTE(PBPCORD, PBPCNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(10)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  If !clalev([YPBC]) Then : Local File BPCUSTOMER      [YPBC] : Endif
  If !clalev([YPBR]) Then : Local File BPARTNER        [YPBR] : Endif

    Raz LREQSQL

    LREQSQL(0) = "Select BPCORD_0 "
    LREQSQL(1) = " From "+nomap + ".STOPREH "
    LREQSQL(2) = " Where DLVFLG_0 = 1  and  SHIDAT_0 >= '" + PDVLDATDESDE + "' and SHIDAT_0 <= '" + PDVLDATHASTA + "'"
    LREQSQL(3) = " GROUP BY BPCORD_0"
    LREQSQL(4) = " ORDER BY BPCORD_0 ASC"


  Infbox(LREQSQL)
  I=0
  For (Char BPCORD) From '5' Sql LREQSQL(0..9) As [YAPP]
    PBPCORD(I)=[F:YAPP]BPCORD
    #razón social del cliente
    Read [YPBR]BPR0=[F:YAPP]BPCORD
    If !fstat Then
      PBPCNAM(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)
    Endif
    PRES = '200'
    PMESS = 'OK'
    I+=1
    If I>LISTMAX Then
      Break
    Endif

  Next
  Close Local File [YPBC]
  Close Local File [YPBR]
End


####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*
#*!
Subprog GETLISTTRANS(PBPTNUM, PBPTNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPTNUM()()
  Variable Char PBPTNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(10)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0
  If !clalev([YBPT]) Then : Local File BPCARRIER      [YBPT] : Endif

    Raz LREQSQL
    LREQSQL(0) = "Select BPTNUM_0 "
    LREQSQL(1) = " From "+nomap + ".STOPREH "
    LREQSQL(2) = " Where DLVFLG_0 = 1  and  SHIDAT_0 >= '" + PDVLDATDESDE + "' and SHIDAT_0 <= '" + PDVLDATHASTA + "' and BPTNUM_0<>''"
    LREQSQL(3) = " GROUP BY BPTNUM_0"
    LREQSQL(4) = " ORDER BY BPTNUM_0 ASC"
  I=0
  For (Char BPTNUM) From '5' Sql LREQSQL(0..9) As [YAPP]
    #Infbox (num$(I)+ " " +[F:YAPP]BPCORD)
    PBPTNUM(I)=[F:YAPP]BPTNUM
    #razón social del cliente
    Read [F:YBPT]BPT0=[F:YAPP]BPTNUM
    If !fstat Then
      PBPTNAM(I) = [F:YBPT]BPTNAM
    Endif
    PRES = '200'
    PMESS = 'OK'
    I+=1
    If I>LISTMAX Then
      Break
    Endif

  Next

  Close Local File [YBPT]
End



####################################################################
#**
#* Subprograma para controlar el acceso a la appmovil
#*
#* @param PUSR
#* @param PPASS
#* @param PACCESO
#* @param PUSUARIO
#* @param PMESS
#*!
Subprog GETACCESO(PUSR, PPASS, PACCESO, PUSUARIO, PMESS)
  Value Char PUSR
  Value Char PPASS
  Variable Char PACCESO, PUSUARIO(), PMESS()

  PUSUARIO=""

  If !clalev([YUSR]) Then : Local File AUTILIS [YUSR] : Endif

  Read [F:YUSR]CODUSR=PUSR
  If !fstat Then
    If [F:YUSR]YUSRAPP = 2 Then
      If [F:YUSR]YPASSAPP = PPASS Then
        PACCESO = "1" # acceso correcto
        PMESS = "Acceso correcto"
        PUSUARIO= [F:YUSR]NOMUSR
      Else
        PACCESO = "2" # pass incorrecta
        PMESS = "Password incorrecta"
      Endif
    Else
      PACCESO = "0" # usuario sin acceso a la app
      PMESS = "Usuario sin acceso a la App"
    Endif
 Else
  PACCESO = "3" # usuario no encontrado
  PMESS = "Usuario no encontrado"
 Endif

  Close Local File [YUSR]
End



####################################################################
#**
#* Sub que devuelve las listas de preparación en curso
#*
#*!
Subprog GETLISTPREPARA(PPRHNUM , PPREUSR, PSTOFCY, PPRLNUM,  PBPCORD, PBPCNAM,  PBPTNUM, PBPTDES, PDLVDAT, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE)

  Variable Char PPRHNUM()()
  Variable Char PPREUSR()()
  Variable Char PSTOFCY()()
  Variable Char PPRLNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PBPTNUM()()
  Variable Char PBPTDES()()
  Variable Char PDLVDAT()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()
  Variable Char PBPCORDDESDE()
  Variable Char PBTNUMDESDE()

  Local Char CRITERE(250)(19) : CRITERE(0) ="1=1"
  Local    Char LFCY
  Local Integer ESTADO : Raz ESTADO

  If !clalev([YPRH]) Then : Local File STOPREH     [YPRH] : Endif
  If !clalev([YPBC]) Then : Local File BPCUSTOMER  [YPBC] : Endif
  If !clalev([YBPT]) Then : Local File BPCARRIER   [YBPT] : Endif
  If !clalev([YPBR]) Then : Local File BPARTNER    [YPBR] : Endif

 Raz CRITERE

 CRITERE(0)="[YPRH]DLVFLG = 1"

  #fecha envío
  If PDVLDATDESDE <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT>=[" + (PDVLDATDESDE) + "]"
  Endif
  If PDVLDATHASTA <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT<=[" + (PDVLDATHASTA) + "]"
  Endif
 #Cliente
  If PBPCORDDESDE <> "" Then
    CRITERE(2) += " & [YPRH]BPCORD='" + PBPCORDDESDE + "'"
  Endif
#transportista
  If PBTNUMDESDE <> "" Then
    CRITERE(3) += " & [YPRH]BPTNUM='" + PBTNUMDESDE + "'"
  Endif

   Infbox CRITERE

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0


    PRES = '200'
    PMESS = 'No hay doc. preparación.'
    Filter [F:YPRH] Where evalue(CRITERE(0..9))

    For [F:YPRH]
      ESTADO = func ESTADO_VALE([F:YPRH]PRHNUM)

      If ESTADO <> 3
        PPRHNUM(I)=[F:YPRH]PRHNUM
        PPREUSR(I)=[F:YPRH]PREUSR
        PSTOFCY(I)=[F:YPRH]STOFCY
        PPRHNUM(I)=[F:YPRH]PRHNUM
        PPRLNUM(I)=[F:YPRH]PRLNUM
        PBPCORD(I)=[F:YPRH]BPCORD
        PBPTNUM(I)=[F:YPRH]BPTNUM
        PDLVDAT(I)=num$([F:YPRH]SHIDAT)
        Read [YPBR]BPR0=[F:YPRH]BPCORD
        If !fstat Then
          PBPCNAM(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)
        Endif
        If [F:YPRH]BPTNUM<>""
          Read [YBPT]BPT0=[F:YPRH]BPTNUM
          If !fstat Then
            PBPTDES(I) = [YBPT]BPTNAM
          Endif
        Endif
        PRES = '200'
        PMESS = 'OK'
        I+=1
        If I>LISTMAX Then
          Break
        Endif
      Endif

    Next

  Close Local File [YPRH], [YPBC], [YPBR]
End

####################################################################
#**
#* Sub que devuelve las listas de preparación en curso
#*
#*!
Subprog GETLISTPRENOENT(PPRHNUM , PPREUSR, PSTOFCY, PPRLNUM,  PBPCORD, PBPCNAM,  PBPTNUM, PBPTDES, PDLVDAT, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE)
  Variable Char PPRHNUM()()
  Variable Char PPREUSR()()
  Variable Char PSTOFCY()()
  Variable Char PPRLNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PBPTNUM()()
  Variable Char PBPTDES()()
  Variable Char PDLVDAT()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()
  Variable Char PBPCORDDESDE()
  Variable Char PBTNUMDESDE()

  Local Char CRITERE(250)(19) : CRITERE(0) ="1=1"
  Local    Char LFCY
  Local Integer YESTADOPREP

  If !clalev([YPRH]) Then : Local File STOPREH     [YPRH] : Endif
  If !clalev([YPBC]) Then : Local File BPCUSTOMER  [YPBC] : Endif
  If !clalev([YPBR]) Then : Local File BPARTNER    [YPBR] : Endif
  If !clalev([YBPT]) Then : Local File BPCARRIER   [YBPT] : Endif

 Raz CRITERE

 CRITERE(0)="[YPRH]DLVFLG = 1"

  #fecha envío
  If PDVLDATDESDE <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT>=[" + (PDVLDATDESDE) + "]"
  Endif
  If PDVLDATHASTA <> "" Then
    CRITERE(1) += " & [YPRH]SHIDAT<=[" + (PDVLDATHASTA) + "]"
  Endif
 #Cliente
  If PBPCORDDESDE <> "" Then
    CRITERE(2) += " & [YPRH]BPCORD='" + PBPCORDDESDE + "'"
  Endif
#transportista
  If PBTNUMDESDE <> "" Then
    CRITERE(3) += " & [YPRH]BPTNUM='" + PBTNUMDESDE + "'"
  Endif

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0


    PRES = '200'
    PMESS = 'No hay doc. preparación.'
    Filter [F:YPRH] Where evalue(CRITERE(0..9))

    For [F:YPRH]
      YESTADOPREP = func SPEPRH.ESTADO_VALE([F:YPRH]PRHNUM)

      If YESTADOPREP = 3 Then
        PPRHNUM(I)=[F:YPRH]PRHNUM
        PPREUSR(I)=[F:YPRH]PREUSR
        PSTOFCY(I)=[F:YPRH]STOFCY
        PPRHNUM(I)=[F:YPRH]PRHNUM
        PPRLNUM(I)=[F:YPRH]PRLNUM
        PBPCORD(I)=[F:YPRH]BPCORD
        PBPTNUM(I)=[F:YPRH]BPTNUM
        PDLVDAT(I)=num$([F:YPRH]SHIDAT)
        Read [YPBR]BPR0=[F:YPRH]BPCORD
        If !fstat Then
          PBPCNAM(I) = [YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)
        Endif
        If [F:YPRH]BPTNUM<>""
          Read [YBPT]BPT0=[F:YPRH]BPTNUM
          If !fstat Then
            PBPTDES(I) = [YBPT]BPTNAM
          Endif
        Endif
        PRES = '200'
        PMESS = 'OK'
        I+=1
        If I>LISTMAX Then
          Break
        Endif
      Endif
    Next

  Close Local File [YPRH], [YPBC], [YPBR]
End

####################################################################
#**
#* Sub que duplica la tabla STOPRED
#*
#*!
Subprog AP_DUPSTOP (PPRHNUM)
 Variable Char PPRHNUM()

  If !clalev([YPRE]) Then : Local File STOPRED     [YPRE] : Endif
  If !clalev([YYPRE]) Then : Local File YSTOPRED      [YYPRE] : Endif

  Filter [F:YPRE] Where PRHNUM=PPRHNUM

  For [F:YPRE]
  #Infbox([F:YPRE]PRHNUM+ " " +num$([F:YPRE]PRELIN))
    [F:YYPRE]PRHNUM=[F:YPRE]PRHNUM
    [F:YYPRE]PRELIN=[F:YPRE]PRELIN
    [F:YYPRE]ITMREF=[F:YPRE]ITMREF
    [F:YYPRE]ITMDES1=[F:YPRE]ITMDES1
    [F:YYPRE]ORINUM=[F:YPRE]ORINUM
    [F:YYPRE]ORILIN=[F:YPRE]ORILIN
    [F:YYPRE]ORISEQ=[F:YPRE]ORISEQ
    [F:YYPRE]QTYSTU=[F:YPRE]QTYSTU
    [F:YYPRE]ALLQTY=[F:YPRE]ALLQTY
    Write [F:YYPRE]
  Next

End


######################################################################################
#**
#*
#* APP. comprueba si hay cambios en las líneas del documento de preparación
#* @param PPRHNUM: DOCUMENTO de preparación
#* @param PRES
#* @param PMESS
#*!
Subprog TESTYTOPRE (PPRHNUM,  PRES, PMESS)
 Variable Char PPRHNUM()
 Variable Char PRES
 Variable Char  PMESS

  If !clalev([YPRE]) Then : Local File STOPRED     [YPRE] : Endif
  If !clalev([YYPRE]) Then : Local File STOPRED      [YYPRE] : Endif

  PRES="200"
  PMESS="Lectura información OK"

  #Si no hay lineas no hacems ningún control
 Filter [F:YYPRE] Where PRHNUM=PPRHNUM
 If rowcount([F:YYPRE]) > 0 Then
        #recorremos las líneas de la copia del detalle
        Filter [F:YYPRE] Where PRHNUM=PPRHNUM
        For [F:YYPRE]
          Read [F:YPRE]PRE0=[F:YYPRE]PRHNUM;[F:YYPRE]PRELIN
          If !fstat Then
            If [F:YYPRE]ITMREF<> [F:YPRE]ITMREF or
&               [F:YYPRE]ORINUM<>[F:YPRE]ORINUM or
&               [F:YYPRE]ORILIN<>[F:YPRE]ORILIN or
&               [F:YYPRE]QTYSTU<>[F:YPRE]QTYSTU or
&               [F:YYPRE]ALLQTY<>[F:YPRE]ALLQTY Then
                PRES="110"
                PMESS="Línea cambiada doc. prep.:" -  num$([F:YYPRE]ITMREF)
                Break
            Endif
          Else
            PRES="100"
            PMESS="Linea borrada en doc. prep.:" -num$([F:YYPRE]ITMREF)
            Break
          Endif
        Next

       #recorremos las líneas que hay en  X3 para ver si alguna no está en la copia
        Filter [F:YPRE] Where PRHNUM=PPRHNUM
        For [F:YPRE]
          Read [F:YYPRE]PRE0=[F:YPRE]PRHNUM;[F:YPRE]PRELIN
          If fstat Then
            PRES="120"
            PMESS="Línea nueva doc. prep.:" - [F:YYPRE]ITMRE
            Break
          Endif
        Next

  Endif

  #Duplicamos o actualizamos
  Filter [F:YYPRE]Where PRHNUM=PPRHNUM
  For [F:YYPRE]
    Read  [F:YPRE]PRE0=[F:YYPRE]PRHNUM;[F:YYPRE]PRELIN
    If fstat  Then # si no la encuentra, la borramos
      Delete [F:YYPRE]
    Endif
  Next

  #Duplicamos o actualizamos
  Filter [F:YPRE]Where PRHNUM=PPRHNUM
  For [F:YPRE]
    Read [F:YYPRE]PRE0=[F:YPRE]PRHNUM;[F:YPRE]PRELIN
    Trbegin [F:YYPRE]
    If !fstat Then
      [F:YYPRE]ITMREF=[F:YPRE]ITMREF
      [F:YYPRE]ITMDES1=[F:YPRE]ITMDES1
      [F:YYPRE]ORINUM=[F:YPRE]ORINUM
      [F:YYPRE]ORILIN=[F:YPRE]ORILIN
      [F:YYPRE]ORISEQ=[F:YPRE]ORISEQ
      [F:YYPRE]QTYSTU=[F:YPRE]QTYSTU
      [F:YYPRE]ALLQTY=[F:YPRE]ALLQTY
      Rewrite [F:YYPRE]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Else
      [F:YYPRE]PRHNUM=[F:YPRE]PRHNUM
      [F:YYPRE]PRELIN=[F:YPRE]PRELIN
      [F:YYPRE]ITMREF=[F:YPRE]ITMREF
      [F:YYPRE]ITMDES1=[F:YPRE]ITMDES1
      [F:YYPRE]ORINUM=[F:YPRE]ORINUM
      [F:YYPRE]ORILIN=[F:YPRE]ORILIN
      [F:YYPRE]ORISEQ=[F:YPRE]ORISEQ
      [F:YYPRE]QTYSTU=[F:YPRE]QTYSTU
      [F:YYPRE]ALLQTY=[F:YPRE]ALLQTY
      Write [F:YYPRE]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Endif
  Next

Close Local File [YPRE]
Close Local File [YYPRE]
End


####################################################################
#**
#* Sub que devuelve el detalle de la lista de preparación
#* También devuelve si hay algún bulto no terminado de la lista de preparación
#* Si no hay ninguno, lo crea
#*
#*!
Subprog GETYSTOPRED(PPRHNUM , PPRELIN, PORINUM, PORILIN,  PITMREF, PITMDES1,  PQTYSTU, PYQTYSTU,  PALLQTY, PPENDIENTE,  PSERNUM, PLOT, PCONTENEDOR, PYCOMCARGA, PYCOMPREPARA, PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Integer PPRELIN()
  Variable Char PORINUM()()
  Variable Integer PORILIN()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Decimal PQTYSTU()
  Variable Decimal PYQTYSTU()
  Variable Decimal PALLQTY()
  Variable Decimal PPENDIENTE()
  Variable Char PPACNUM()
  Variable Char PSERNUM()
  Variable Char PLOT()
  Variable Char PCONTENEDOR()
  Variable Char PYCOMCARGA()
  Variable Char PYCOMPREPARA()
  Variable Char PRES
  Variable Char PMESS
  Local    Char PACNUM(30)
  Local Char PRES1(10)
  Local Char PMESS1(60)
  Local Char PCK(10)
  Local Char LREQSQL(250)(14)

  PRES="800"
  PMESS="No hay artículos"

  If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  Raz LREQSQL


  LREQSQL(0) = "SELECT P.PRHNUM_0, P.PRELIN_0, P.ITMREF_0, P.ITMDES1_0, P.QTYSTU_0, P.YQTYSTU_0, P.ALLQTY_0, P.ORINUM_0, P.ORILIN_0,A.QTYSTU_0 as QTYSTUA, S.SERNUM_0, S.LOT_0, S.SLO_0, S.LPNNUM_0, SO"
&  + ".YCOMCARGA_0, SO.YCOMPREPARA_0 "
  LREQSQL(1) = " FROM " + nomap + ".STOPRED P INNER JOIN " + nomap + ".STOALL A ON P.PRHNUM_0=A.VCRNUM_0 AND P.PRELIN_0=A.VCRLIN_0 "
  LREQSQL(2) = " LEFT JOIN " + nomap + ".STOCK S ON A.STOCOU_0=S.STOCOU_0 INNER JOIN " + nomap + ".SORDER SO ON P.ORINUM_0=SO.SOHNUM_0 "
  LREQSQL(3) = " WHERE P.PRHNUM_0='" + PPRHNUM+"'"
  LREQSQL(4) = " ORDER BY P.PRELIN_0 "

For (Char PRHNUM,Integer PRELIN,Char ITMREF,Char ITMDES1(250),Decimal QTYSTU,Decimal YQTYSTU,Decimal ALLQTY,Char ORINUM,Integer ORILIN, Decimal QTYSTUA,Char SERNUM,Char LOT,Char SLO, Char LPNNUM, Char
& YCOMCARGA, Char YCOMPREPARA) From
& '5' Sql
& LREQSQL(0
& ..6) As [YAPP]
    Read [F:YSOH]SOH0=[F:YAPP]ORINUM
    If !fstat Then
      If [F:YSOH]CDTSTA=1 and [F:YSOH]HLDSTA=1 Then
        If [F:YAPP]ALLQTY<>0
          PPRELIN(I)    = [F:YAPP]PRELIN
          PORINUM(I)    = [F:YAPP]ORINUM
          PORILIN(I)    = [F:YAPP]ORILIN
          PITMREF(I)    = [F:YAPP]ITMREF
          PITMDES1(I)   = [F:YAPP]ITMDES1
          PQTYSTU(I)    = [F:YAPP]QTYSTUA
          PALLQTY(I)    = [F:YAPP]QTYSTUA
          PSERNUM(I)    = [F:YAPP]SERNUM
          PLOT(I)       = [F:YAPP]LOT
          PCONTENEDOR(I)= [F:YAPP]LPNNUM
          PYCOMCARGA(I) = [F:YAPP]YCOMCARGA
          PYCOMPREPARA(I) = [F:YAPP]YCOMPREPARA
          Raz LREQSQL
           If [F:YAPP]SERNUM<>"" or [F:YAPP]LOT<>""
             LREQSQL(0)="select sum(QTYPCU_0) AS QTY FROM " + nomap + ".YSPACKD "
             LREQSQL(1)=" WHERE VCRNUM_0='"+PPRHNUM+"' AND VCRLIN_0="+num$([F:YAPP]PRELIN)
             If [F:YAPP]SERNUM<>""
                  LREQSQL(2)=" AND SERNUM_0='"+[F:YAPP]SERNUM+"'"
             Elsif [F:YAPP]LOT<>""
                LREQSQL(2)=" AND LOT_0='"+[F:YAPP]LOT+"'"
             Endif
             For (Decimal QTY) From '5' Sql LREQSQL(0..3) As [YAPP2]
                PPENDIENTE(I) = PQTYSTU-[YAPP2]QTY
                PYQTYSTU(I)   = [F:YAPP2]QTY
             Next
          Else
            PPENDIENTE(I) = PQTYSTU-[F:YAPP]YQTYSTU
            PYQTYSTU(I)   = [F:YAPP]YQTYSTU
          Endif
          I+=1
          PRES="200"
          PMESS="Lectura correcta"
          If I>LISTMAX Then
            Break
          Endif
       Endif
      Endif
    Endif
  Next

    #BUSCAMOS SI ESTA LISTA DE PREPARACIÓN TIENE ALGÚN BULTO sin TERMINAR
    PACNUM=""
    Filter [F:YSPH] Where VCRNUM=PPRHNUM and YCERRADO<>2
    For [F:YSPH]
      PACNUM=[F:YSPH]PACNUM
    Next
    PPACNUM=PACNUM

  Close Local File [YYPR2]
  Close Local File [YSPH]
  Close Local File [YSOH]
End


####################################################################
#**
#* Sub que comprueba el código de barras que se le pasa,
#* Comprueba que es válido para la lista de preparación.
#*
#* 1º Número de serie
#* 2º EAN
#* 3º Contenedor, LPN, para el caso del prepiking
#* Si es válido, rellena YQTYPCU
#* Devuelve el nº de Bulto, si no existe, lo crea
#*
#* PRES: 200, OK
#*
#* PMES: Mensaje con lo que ha hecho
#*!
Subprog PUTCONSUMO(PPRHNUM, PCODIGOBARRAS, PPACNUM, PUSUARIO, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PCODIGOBARRAS()
  Variable Char PPACNUM()
  Variable Char PUSUARIO()
  Variable Char PRES
  Variable Char PMESS

  Local  Integer CANTIDAD
  Local Char INFNAM
  Local Char DESTINO
  Local Char PRELPN

  If !clalev([YYPRE]) Then : Local File STOPRED      [YYPRE] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER      [YITM] : Endif
  If !clalev([YSTO]) Then : Local File STOCK      [YSTO] : Endif
  If !clalev([YSTA]) Then : Local File STOALL      [YSTA] : Endif
  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif

    #Read [F:YSTO]STO4=LFCY;PUBICACION


    Call PARAM_YSPACKD(INFNAM, DESTINO, PRELPN)

    PRES="100"
    PMESS="No se encuentra"

    CANTIDAD=1


    #Testeamos si es un LPN, para ello debe empezar por "PP"
    If left$(PCODIGOBARRAS,2)=PRELPN Then
      PRES="160"
      PMESS="No existe la caja o ya se ha escaneado"
      Filter [F:YYPRE] Where PRHNUM=PPRHNUM Order By PRELIN
      For [F:YYPRE]
        Infbox("ANTES FILTRO "- [F:YYPRE]ITMREF-PCODIGOBARRAS )
        Filter [F:YSTO] Where  LPNNUM=PCODIGOBARRAS and ITMREF=[F:YYPRE]ITMREF
        For [F:YSTO]
            If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
              Trbegin [F:YYPRE]
              If [F:YSTO]QTYSTU > [F:YYPRE]QTYSTU Then
                CANTIDAD=[F:YYPRE]QTYSTU
              Else
                CANTIDAD=[F:YSTO]QTYSTU
              Endif

              [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD

              Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM,"", "", PCODIGOBARRAS, PUSUARIO) From YAPPLIB
              Rewrite [F:YYPRE]
              If !fstat Then
                Commit
              Else
                Rollback
              Endif
              PRES="200"
              PMESS="Correcto"
            Else
            Endif
        Next
      Next
    Else
      Infbox("No prepicking")
      Filter [F:YYPRE] Where PRHNUM=PPRHNUM Order By PRELIN
      For [F:YYPRE]
        Read [YITM]ITM0=[F:YYPRE]ITMREF
        Infbox([F:YYPRE]ITMREF)
        If !fstat Then
          #Comprobamos núm de serie
          Infbox(num$([YITM]LOTMGTCOD)-"-"-num$([YITM]SERMGTCOD) )
          # Núm de serie
          If [YITM]SERMGTCOD <> 1 Then
            #Numero de serie
            Infbox("ser: " -[F:YYPRE]ITMREF-PCODIGOBARRAS)
            Read [F:YSTO]STO5=[F:YYPRE]ITMREF;PCODIGOBARRAS
            If !fstat Then
                Infbox("Existe numero de serie en STOCK")
                #Si está en stock, buscamos que esté asignada a esta preparación STOALL
                Filter [F:YSTA] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and ITMREF= [F:YYPRE]ITMREF and STOCOU=[F:YSTO]STOCOU
                If rowcount([F:YSTA])=0 Then
                    PRES="120"
                    PMESS="Número de serie no asignado a esta preparación"
                Else
                  For [F:YSTA]
                    #Por último tenemos que ver si el número de serie está en un bulto YPACKD
                    PRES="200"
                    PMESS="Número de serie correcto"
                    Filter [F:YSPD] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and SERNUM=PCODIGOBARRAS
                    #Si existe, incorrecto
                    For [F:YSPD]
                      Infbox("exite el bulto")
                      PRES="101"
                      PMESS="Ya está utilizado el número de serie: " + PCODIGOBARRAS
                    Next
                    If PRES="200" Then
                      Infbox("damos el alta")
                      Trbegin [F:YYPRE]
                      [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                      Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM, PCODIGOBARRAS,"","", PUSUARIO) From YAPPLIB
                      Rewrite [F:YYPRE]
                      If !fstat Then
                        Commit
                      Else
                        Rollback
                      Endif
                      PRES="200"
                      PMESS="Correcto"
                      Break
                    Endif
                  Next
              Endif #DEL rowcount
            Endif
          Else
            #Número de lote
            If [YITM]LOTMGTCOD <> 1  Then
              #Lote
              Infbox("lot: " -[F:YYPRE]ITMREF-PCODIGOBARRAS)
              Read [F:YSTO]YSTO7=[F:YYPRE]ITMREF;PCODIGOBARRAS
              If !fstat Then
                  Infbox("Existe lote en STOCK")
                  #Si está en stock, buscamos que esté asignada a esta preparación STOALL
                  Filter [F:YSTA] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and ITMREF= [F:YYPRE]ITMREF and STOCOU=[F:YSTO]STOCOU
                  If rowcount([F:YSTA])=0 Then
                      PRES="120"
                      PMESS="Lote no asignado a esta preparación"
                  Else
                    For [F:YSTA]
                      #Por último tenemos que ver si el número de serie está en un bulto YPACKD
                      PRES="200"
                      PMESS="Lote correcto"
                      Filter [F:YSPD] Where VCRNUM=[F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN and SERNUM=PCODIGOBARRAS
                      #Si existe, incorrecto
                      For [F:YSPD]
                        Infbox("exite el bulto")
                        PRES="101"
                        PMESS="Ya está utilizado el lote: " + PCODIGOBARRAS
                      Next
                      If PRES="200" Then
                        If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
                          Infbox("damos el alta: "-num$([F:YYPRE]YQTYSTU)-num$(CANTIDAD)-num$([F:YYPRE]QTYSTU) )
                          Trbegin [F:YYPRE]
                          [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                          Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM, "", PCODIGOBARRAS,"", PUSUARIO) From YAPPLIB
                          Rewrite [F:YYPRE]
                          If !fstat Then
                            Commit
                          Else
                            Rollback
                          Endif
                          PRES="200"
                          PMESS="Correcto"
                          Break
                        Else
                          PRES="150"
                          PMESS="Artículo " + [F:YYPRE]ITMREF - "Lote:-"- PCODIGOBARRAS -"totalmente recogido."
                        Endif # De la cantidad ya recogida [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU
                      Endif
                    Next
                Endif #DEL rowcount
              Endif
              #Si no es correcto:
            Else
            #por código EAN
            If [F:YITM]EANCOD=PCODIGOBARRAS

              # JMF - 18.09.2023
              # Comprobamos en asignaciones y stock si el artículo tiene número de contenedor asignado
              Infbox ([F:YYPRE]PRHNUM + " - " + num$([F:YYPRE]PRELIN))
              Filter [F:YSTA] Where VCRNUM = [F:YYPRE]PRHNUM and VCRLIN=[F:YYPRE]PRELIN
              Local Integer PSTOCOU
              For [F:YSTA]
                PSTOCOU = [F:YSTA]STOCOU
              Next
              Infbox("STOCOU: " + num$(PSTOCOU))

              Local Char PLPNNUM
              Filter [F:YSTO] Where STOCOU = PSTOCOU
              For [F:YSTO]
                PLPNNUM = [F:YSTO]LPNNUM
              Next


              If PLPNNUM <> "" Then
                PRES = "155"
                PMESS = "Artículo dentro de contenedor, no se puede utilizar el EAN."

              Else
                If [F:YYPRE]QTYSTU>[F:YYPRE]YQTYSTU Then
                  Trbegin [F:YYPRE]
                  [F:YYPRE]YQTYSTU=[F:YYPRE]YQTYSTU+CANTIDAD
                  Call PUTYSPACKDET(PPRHNUM, [F:YYPRE]PRELIN, CANTIDAD, PPACNUM,"", "","",PUSUARIO) From YAPPLIB
                  Rewrite [F:YYPRE]
                  If !fstat Then
                    Commit
                  Else
                    Rollback
                  Endif
                  PRES="200"
                  PMESS="Correcto"
                  Break
                Else
                 # Infbox("NO SUMA")
                  PRES="150"
                  PMESS="Artículo " + [F:YYPRE]ITMREF - "totalmente recogido."
                  #Break, SEGUIMOS POR SI HAY OTRO ARTÍCULO
                Endif
            Endif
          Endif #Si coincide el código de barras
        Endif
       Endif
      Endif   #No exite artículo
    Next
  Endif #prepicking

  Close Local File [YYPRE]
  Close Local File [YITM]
  Close Local File [YSTO]
  Close Local File [YSTA]
  Close Local File [YSPD]

End


######################################################################################
#**
#* GETLSSPACK
#* APP: devuelve   todos los bultos de una preparación, y sus líneas
#*
#*
#* @param PPRHNUM, preparación
#*
#* @param CAMPO1: campo izquierdo: BULTO: No bulto, LINEA: ref. artículo
#* @param CAMPO2: campo descripción: BULTO: peso, largo, ancho, alto, LINEA: descrip. artículo
#* @param CAMPO3: campo de cola, numérico: BULTO: vacio, LINEA: unidadeas de producto
#* @param TIPOCAMPO: "B" si es bulto. "L" si es la línea del producto.
#* @param PPACNUM
#* @param PPACIND
#* @param PITMREF
#* @param PITMDES1
#* @param PSERNUM
#* @param PQTYPCU
#* @param PPESONETO
#* @param PCAMION
#* @param PRES
#* @param PMESS
#*
#*!
Subprog GETLSSPACK(PPRHNUM, PCAMPO1, PCAMPO2, PCAMPO3,  PTIPOCAMPO,  PPACNUM , PPRELIN, PPACIND, PITMREF, PITMDES1, PSERNUM, PLOT, PSLO,  PQTYPCU,  PCAMION, PRES, PMESS)

  Value Char PPRHNUM()
  Variable Char PCAMPO1()()
  Variable Char PCAMPO2()()
  Variable Char PCAMPO3()()
  Variable Char PTIPOCAMPO()()
  Variable Char PPACNUM()()
  Variable Integer PPRELIN()
  Variable Integer PPACIND()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PSERNUM()()
  Variable Char PLOT()()
  Variable Char PSLO()()
  Variable Decimal PQTYPCU()
  Variable Char PCAMION()()
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO


  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif


  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  PRES = '100'
  PMESS = 'Problemas'

  #Filtramos todos los bultos de la preparacion
  Filter [F:YSPH] Where VCRNUM=PPRHNUM
    For [F:YSPH]
      PRES = '200'
      PMESS = 'OK'
      PCAMPO1(I)=[F:YSPH]PACNUM
      PCAMPO2(I)="Peso: " + num$([F:YSPH]YBRWEI) + "kg" + " Largo: "+ num$([F:YSPH]YPCKLEN)+ "cm Ancho: "+ num$([F:YSPH]YPCKWID)+"cm Alto: "+ num$([F:YSPH]YPCKHEI) +"cm" - "Camión: "+[F:YSPH]YCAMION
      PCAMPO3(I)=""
      If [F:YSPH]YCERRADO=2 Then
        PTIPOCAMPO(I)="C"
      Else
        PTIPOCAMPO(I)="B"
      Endif
      #Filtramos todos los componentes de los bultos
      I+=1
      Filter [YSPD] Where PACNUM=[F:YSPH]PACNUM  Order By PACIND
      For [F:YSPD]
        #Campos que se verán en la rejilla
        PCAMPO1(I)=[F:YSPD]ITMREF
        PCAMPO2(I)=[F:YSPD]ITMDES1
        If [F:YSPD]SERNUM<>"" Then : PCAMPO2(I)+=" Serie: "+[F:YSPD]SERNUM: Endif
        If [F:YSPD]LOT<>""    Then : PCAMPO2(I)+=" Lote: "+[F:YSPD]LOT: Endif
        PCAMPO3(I)= num$([F:YSPD]QTYPCU)
        PTIPOCAMPO(I)="D"
        #Campos que no se ven, pero pueden ser interesantes
        PPACNUM(I)=[F:YSPH]PACNUM
        PPRELIN(I)=[F:YSPD]VCRLIN
        PPACIND(I)=[F:YSPD]PACIND
        PITMREF(I)=[F:YSPD]ITMREF
        PITMDES1(I)=[F:YSPD]ITMDES1
        PSERNUM(I)=[F:YSPD]SERNUM
        PLOT(I)=[F:YSPD]LOT
        PSLO(I)=[F:YSPD]SLO
        PQTYPCU(I)=[F:YSPD]QTYPCU
        PCAMION(I)=[F:YSPH]YCAMION
        I+=1
        If I>LISTMAX Then
          Break
        Endif
      Next # De la línea de bulto YPACKD
  Next #Del bulto, YPACK
PPESONETO=PESONETO

  Close Local File [YSPD]
  Close Local File [YSPH]
End



####################################################################
#**
#* APP: Sub que devuelve el detalle del bulto que vamos a cerrar
#*
#*!
Subprog GETLISTYSPACKD(PPACNUM , PPACIND, PITMREF, PITMDES1, PSERNUM,  PQTYPCU, PPESONETO, PRES, PMESS)

  Variable Char PPACNUM()
  Variable Integer PPACIND()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Char PSERNUM()()
  Variable Decimal PQTYPCU()
  Variable Decimal PPESONETO
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO

  If !clalev([YSPD]) Then  : Local File YSPACKD      [YSPD]  : Endif
  If !clalev([YITM]) Then  : Local File ITMMASTER    [YITM]  : Endif
  If !clalev([YTPK]) Then  : Local File YTMPYPCKD    [YTPK]  : Endif
  If !clalev([YTPK2]) Then : Local File YTMPYPCKD    [YTPK2] : Endif

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0
    # Sin numero de serie
    PRES = '100'
    PMESS = 'Problemas'
    PESONETO=0

    Filter [F:YTPK] Where PACNUM=PPACNUM
    For [F:YTPK]
      Delete [F:YTPK]
    Next

    # Rellenamos la tabla temporal para que se agrupe en pantalla por
    #   1- Si numero de serie->número de serie
    #   2- Si viene de un LPN: LPN+ITMREF
    #   3- Si viene del código ean, por artículo
    #
    Filter [YSPD] Where PACNUM=PPACNUM  Order By PACIND
    For [F:YSPD]
      Read [F:YTPK]YTPK0=PPACNUM;[F:YSPD]ITMREF;[F:YSPD]YLPNNUM;[F:YSPD]SERNUM
      Trbegin [F:YTPK]
      [F:YTPK]PACNUM=PPACNUM
      [F:YTPK]ITMREF=[F:YSPD]ITMREF
      [F:YTPK]SERNUM=[F:YSPD]SERNUM
      [F:YTPK]LPNNUM=[F:YSPD]YLPNNUM
      If !fstat Then
        [F:YTPK]QTYPCU= [F:YTPK]QTYPCU+[F:YSPD]QTYPCU
        Rewrite  [F:YTPK]
      Else
        [F:YTPK]ITMDES=[F:YSPD]ITMDES1
        [F:YTPK]QTYPCU=[F:YSPD]QTYPCU
        Write  [F:YTPK]
      Endif
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
      Read [F:YITM]ITM0=[F:YSPD]ITMREF
      If !fstat Then
        PESONETO = PESONETO +([F:YITM]ITMWEI*[F:YSPD]QTYPCU)
#        PESONETO = PESONETO + [F:YTIM]
      Endif
      I+=1
    Next

    I=0
    Filter [F:YTPK2] Where PACNUM=PPACNUM
    For [F:YTPK2]
      PPACIND(I)=I
      PITMREF(I)= [F:YTPK2]ITMREF
      PITMDES1(I)=[F:YTPK2]ITMDES
      If [F:YTPK2]SERNUM<>"" or [F:YTPK2]LPNNUM<>"" Then
        If [F:YTPK2]SERNUM="" Then
          PSERNUM(I)="Caja:" - [F:YTPK2]LPNNUM
        Else
          PSERNUM(I)="N.Ser.:" - [F:YTPK2]SERNUM
        Endif
      Endif
      PQTYPCU(I)=[F:YTPK2]QTYPCU
      PRES = '200'
      PMESS = 'OK'
      I+=1
      If I>LISTMAX Then
        Break
      Endif

    Next

PPESONETO=PESONETO
  Close Local File [YSPD]
  Close Local File [YITM]
  Close Local File [F:YTPK]
  Close Local File [F:YTPK2]
End


######################################################################################
Subprog GETYPREBULT(PPRHNUM , PPRELIN, PORINUM, PORILIN,  PITMREF, PITMDES1,  PQTYSTU, PYQTYSTU,  PALLQTY, PYPACQTYSTU, PPENDBULTO, PPESONETO, PRES, PMESS)

  Variable Char PPRHNUM()
  Variable Integer PPRELIN()
  Variable Char PORINUM()()
  Variable Integer PORILIN()
  Variable Char PITMREF()()
  Variable Char PITMDES1()()
  Variable Decimal PQTYSTU()
  Variable Decimal PYQTYSTU()
  Variable Decimal PALLQTY()
  Variable Decimal PYPACQTYSTU()
  Variable Decimal PPENDBULTO()
  Variable Decimal PPESONETO
  Variable Char PRES
  Variable Char PMESS

  Local Decimal  PESONETO
  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER    [YITM] : Endif

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0
    #Filtramos por las cantidades pendientes de poner en un bulto
    Filter [F:YYPRE] Where PRHNUM=PPRHNUM and YPACQTYSTU < YQTYSTU Order By PRELIN
    PRES = '200'
    PMESS = 'Problemas'
    PESONETO=0

    For [F:YYPRE]
      PPRELIN(I)    = [F:YYPRE]PRELIN
      PORINUM(I)    = [F:YYPRE]ORINUM
      PORILIN(I)    = [F:YYPRE]ORILIN
      PITMREF(I)    = [F:YYPRE]ITMREF
      Read [F:YITM]ITM0 = [F:YYPRE]ITMREF
      If !fstat Then
        PESONETO = PESONETO +([F:YITM]ITMWEI)*([F:YYPRE]YQTYSTU-[F:YYPRE]YPACQTYSTU)
      Endif
      PITMDES1(I)   = [F:YYPRE]ITMDES1
      PQTYSTU(I)    = [F:YYPRE]QTYSTU
      PYQTYSTU(I)   = [F:YYPRE]YQTYSTU
      PYPACQTYSTU(I)=[F:YYPRE]YPACQTYSTU
      PALLQTY(I)=[F:YYPRE]ALLQTY
      PPENDBULTO(I)=[F:YYPRE]YQTYSTU-[F:YYPRE]YPACQTYSTU
      PRES = '200'
      PMESS = 'OK'
      I+=1
      If I>LISTMAX Then
        Break
      Endif
    Next
    PPESONETO=PESONETO
  Close Local File [YYPRE]
End


####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*
#*!
Subprog GETLISTPACKAGE(PPCK, PLANDESSHO, PLBLFMT, PPCKWEI, PPCKLEN, PPCKWID,PPCKHEI , PRES, PMESS)

  Variable Char PPCK()()
  Variable Char PLANDESSHO()()
  Variable Char PLBLFMT()()
  Variable Decimal   PPCKWEI()
  Variable Decimal   PPCKLEN()
  Variable Decimal   PPCKWID()
  Variable Decimal   PPCKHEI()
  Variable Char PRES
  Variable Char PMESS

  Local Char TEMP(40)
  Local Integer POS
  Local Integer POS2
  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  If !clalev([YTPA]) Then : Local File TABPACKAGE      [YTPA] : Endif
    Filter [F:YTPA] Order By PCK
      For [F:YTPA]
        PPCK(I)=[F:YTPA]PCK
        POS=instr(1,[F:YTPA]LANDESSHO,"~")
        POS2=instr(POS+1,[F:YTPA]LANDESSHO,"~")
        TEMP=mid$([F:YTPA]LANDESSHO, POS+1,POS2-POS-1 )
        PLANDESSHO(I)=TEMP
        PLBLFMT(I)=[F:YTPA]LBLFMT
        PPCKWID(I)=[F:YTPA]PCKWID
        PPCKLEN(I)=[F:YTPA]PCKLEN
        PPCKHEI(I)=[F:YTPA]PCKHEI
        PPCKWEI(I)=[F:YTPA]PCKWEI
        PRES="200"
        PMESS="OK"
        I+=1
        If I>LISTMAX Then
          Break
        Endif

      Next
    Filter [F:YTPA]
  Close Local File [F:YTPA]

End


####################################################################
#**
#* Sub que crea los registros en las tablas YPACK y YPACKD
#*
#* Se le pasa el número del listado de preparación y los datos del bulto, tamaño, peso, etc.
#* Devuelve el número de bulto
#*!

Subprog PUTYSPACK(  PPRHNUM, PPCK,  PLBLFMT, PNETWEI, PYBRWEI, PVOL,  PPCKWEI, PPCKLEN, PPCKWID, PPCKHEI , PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PPCK()
  Variable Char PLBLFMT()
  Variable Decimal PNETWEI
  Variable Decimal  PYBRWEI
  Variable Decimal PPCKWEI
  Variable Decimal PVOL
  Variable Decimal  PPCKLEN
  Variable Decimal PPCKWID
  Variable Decimal PPCKHEI
  Variable Char PPACNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif
  If !clalev([YYSPD]) Then : Local File YSPACKD      [YYSPD] : Endif
  If !clalev([YYPRE]) Then : Local File STOPRED      [YYPRE] : Endif

  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer STAT
  Local Char LCONTADOR

  # JMF - Inicializar fecha creación
  Local Date FECHAINICIAL
  Raz FECHAINICIAL

  Call NUMERO("YPAAP","11",date$,"",LCONTADOR,STAT) From SUBANM

  Infbox(LCONTADOR)

  Trbegin [YYSPH]
  [YYSPH]STOFCY="11"
  [YYSPH]CPY="1"
  [YYSPH]PACSEQ=1
  [YYSPH]VCRTYP=3
  [YYSPH]VCRNUM=PPRHNUM
  [YYSPH]PACNUM=LCONTADOR
  [YYSPH]PCK=PPCK
  [YYSPH]PCKWEI=PPCKWEI
  [YYSPH]NETWEI=PNETWEI
  [YYSPH]YBRWEI=PYBRWEI
  [YYSPH]LBLFMT=PLBLFMT
  [YYSPH]PCKWEI=PPCKLEN
  [YYSPH]NETWEI=PPCKWID
  [YYSPH]YBRWEI=PPCKHEI
  [YYSPH]YFECHA = FECHAINICIAL
  [YYSPH]YCARGADO = 1
  Write [YYSPH]
  If !fstat Then
    Commit
  Else
    Rollback
    Close Local File [YYSPH]
    End
  Endif

  Local Integer I
  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  #Filtramos por las cantidades pendientes de poner en un bulto
  I=0
  Filter [F:YYPRE] Where PRHNUM=PPRHNUM and YPACQTYSTU < YQTYSTU Order By PRELIN
  For [F:YYPRE]
    I=I+1
    Trbegin [YYSPD]
    [YYSPD]STOFCY="11"
    [YYSPD]CPY="1"
    [YYSPD]PACSEQ=I
    [YYSPD]PACNUM=LCONTADOR
    [YYSPD]PCK=PPCK
    [YYSPD]ITMREF=[F:YYPRE]ITMREF
    [YYSPD]ITMDES1=[F:YYPRE]ITMDES1
    [YYSPD]QTYPCU=[F:YYPRE]YQTYSTU-[F:YYPRE]YPACQTYSTU
    Write [YYSPD]
    If !fstat Then
      Commit
    Else
      Rollback
    Endif
 Next

PPACNUM=LCONTADOR

  Close Local File [YYSPH]
  Close Local File [YYSPD]
  Close Local File [YYPRE]
End


####################################################################
#**
#* Sub que crea un registro de un bulto
#*
#* Se le pasa el número del listado de preparación y el tipo de embalaje
#* Devuelve el número de bulto
#*!

Subprog PUTNEWYSPACK(  PPRHNUM, PPCK, PUSUARIO, PPACNUM, PRES, PMESS)
  Variable Char PPRHNUM()
  Variable Char PPCK()
  Variable Char PUSUARIO()
  Variable Char PPACNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif
  If !clalev([YYSPH2]) Then : Local File YSPACK      [YYSPH2] : Endif

  Infbox(PUSUARIO)
  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer STAT
  Local Char LCONTADOR
  Local Integer SECUENCIA : SECUENCIA = 1

  Call NUMERO("YPAAP","11",date$,"",LCONTADOR,STAT) From SUBANM

  # JMF - 30.11.2023
  # Comprobamos si ya existe algún registro en la tabla YSPACK para actualizar el número de secuencia
  Filter [YYSPH2] Where VCRNUM = PPRHNUM Order By PACSEQ Desc
  If rowcount([YYSPH2]) > 0
    Read [YYSPH2] First
    SECUENCIA = [YYSPH2]PACSEQ + 1
  Endif
  Filter [YYSPH2]

  [YYSPH]STOFCY="11"
  [YYSPH]CPY="1"
  [YYSPH]PACSEQ=SECUENCIA
  [YYSPH]VCRTYP=3
  [YYSPH]VCRNUM=PPRHNUM
  [YYSPH]PACNUM=LCONTADOR
  [YYSPH]PCK=PPCK
  [YYSPH]PREUSR = PUSUARIO
  [YYSPH]YCARGADO = 1
  Write [YYSPH]
  If !fstat Then
    PRES="200"
    PMESS="OK"
  Else
    PRES="100"
    PMESS="Problema dando de alta el bulto"
    End
  Endif

PPACNUM=LCONTADOR
  Close Local File [YYSPH]
  Close Local File [YYSPH2]
End


####################################################################
#**
#* RMSPACKDET
#* APP: borra una línea del empaquetado
#*
#* @param PPACNUM
#* @param PPACIND
#* @param PRES
#* @param PMESS
#*!
Subprog RMSPACKDET(PPACNUM,  PPACIND, PRES, PMESS)
  Value Char PPACNUM()
  Value  Integer PPACIND
  Variable Char PRES()
  Variable Char PMESS()


  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif
  If !clalev([YPRE]) Then : Local File STOPRED      [YPRE] : Endif

  Read [F:YSPD]YSPD0= PPACNUM;PPACIND
  If !fstat Then
    Read  [F:YPRE]PRE0=[F:YSPD]VCRNUM;[F:YSPD]VCRLIN
    If !fstat Then
      [F:YPRE]YQTYSTU=[F:YPRE]YQTYSTU-[F:YSPD]QTYPCU
      Rewrite [F:YPRE]
      Delete [F:YSPD]
      #Si no quedan lineas borramos el paquete
      Filter [F:YSPD] Where PACNUM=PPACNUM
      If rowcount([F:YSPD])=0 Then
        Read [F:YSPH]YSPH0=PPACNUM
        If !fstat Then
          Delete [F:YSPH]
        Endif
      Endif
      PRES="200"
      PMESS="Borrado correcto"
    Else
      PRES="110"
      PMESS="No existe el documento de prep.: " + [F:YSPD]VCRNUM + ", linea: "+ num$([F:YSPD]VCRLIN)
    Endif
  Else
    PRES="100"
    PMESS="No existe el bulto: " + PPACNUM + ", linea: "+ num$(PPACIND)
  Endif
  Close Local File [YSPD]
  Close Local File [YSPH]
End


####################################################################
#**
#* Sub que crea los registros en las tablas YPACKD
#*
#* Se le pasa el número del listado de preparación, linea, cantidad  y el número de bulto
#* la cantidad normalmente será  1
#*!

Subprog PUTYSPACKDET(PPRHNUM, PPRELIN ,PQTYPCU, PPACNUM, PSERNUM, PLOT, PLPNNUM, PUSUARIO)
  Value Char PPRHNUM()
  Value  Integer PPRELIN
  Value Integer PQTYPCU
  Variable Char PPACNUM()
  Value Char PSERNUM()
  Value Char PLPNNUM()
  Value Char PUSUARIO()

  Local Integer I
  Local Integer NUM_LINEA

  Local Char PRES, PMESS

  If !clalev([YSPD]) Then : Local File YSPACKD      [YSPD] : Endif
  If !clalev([YPRE]) Then : Local File STOPRED      [YPRE] : Endif
  If !clalev([YCONT]) Then : Local File YSPACKD      [YCONT] : Endif

   Local Char PCK
    PCK=""
    If PPACNUM="" Then
        Call PUTNEWYSPACK(  PPRHNUM, PCK, PUSUARIO, PPACNUM, PRES, PMESS)
    Endif


  #Filtramos por las cantidades pendientes de poner en un bulto
  I=0
  Filter [YCONT] Where VCRNUM=PPRHNUM
    If !fstat Then
      NUM_LINEA=rowcount([YCONT])+1
    Else
      NUM_LINEA=1
    Endif
  Filter [F:YPRE] Where PRHNUM=PPRHNUM and PRELIN =PPRELIN
  For [F:YPRE]
    I=I+1
    [YSPD]VCRNUM=PPRHNUM
    [YSPD]VCRLIN=PPRELIN
    [YSPD]STOFCY="11"
    [YSPD]CPY="1"
    [YSPD]VCRTYP=3
    [YSPD]PACSEQ=I
    [YSPD]PACNUM=PPACNUM
    [YSPD]PACIND=NUM_LINEA
    [YSPD]PCK=""
    [YSPD]ITMREF=[F:YPRE]ITMREF
    [YSPD]ITMDES1=[F:YPRE]ITMDES1
    [YSPD]QTYPCU=PQTYPCU
    If PSERNUM<>"" Then
      [YSPD]SERNUM=PSERNUM
    Endif
    If PLPNNUM<>"" Then
      [YSPD]YLPNNUM=PLPNNUM
    Endif
    If PLOT<>"" Then
      [YSPD]LOT=PLOT
    Endif
    Write [YSPD]
    If !fstat Then
    #  Commit
    Else
    #  Rollback
    Endif
  Next
  Close Local File [YSPD]
  Close Local File [YPRE]
  Close Local File [YCONT]
End



####################################################################
#**
#* Sub rellena los datos del bulto que faltan
#* lo da por terminado
#* imprime la etiqueta
#*
#*!
Subprog ENDYSPACKD(PPACNUM , PPCK,  PLBLFMT, PNETWEI, PBRWEI, PVOL,  PPCKWEI, PPCKLEN, PPCKWID, PPCKHEI, PCAMION ,  PRES, PMESS)

  Variable Char PPACNUM()
  Variable Char PPCK()
  Variable Char PLBLFMT()
  Variable Decimal PNETWEI
  Variable Decimal  PBRWEI
  Variable Decimal PPCKWEI
  Variable Decimal PVOL
  Variable Decimal  PPCKLEN
  Variable Decimal PPCKWID
  Variable Decimal PPCKHEI
  Variable Char PCAMION()
  Variable Char PRES
  Variable Char PMESS

  Local Char INFNAM
  Local Char DESTINO
  Local Decimal  PESONETO
  Local Char PRELPN

  If !clalev([YSPH]) Then : Local File YSPACK      [YSPH] : Endif

  Local Char HORA(6)
  HORA = num$(time$)
  HORA = mid$(HORA,1,2)+mid$(HORA,4,2)+mid$(HORA,7,2)

  PRES="100"
  PMESS="No se encuentra el bulto/paquete"
  Filter [F:YSPH] Where PACNUM=PPACNUM
    For [F:YSPH]
      [F:YSPH]PCK=PPCK
      [F:YSPH]NETWEI=PNETWEI
      [F:YSPH]YBRWEI=PBRWEI
      [F:YSPH]YPCKHEI=PPCKHEI
      [F:YSPH]YPCKLEN=PPCKLEN
      [F:YSPH]YPCKWID=PPCKWID
      [F:YSPH]YPCKHEI=PPCKHEI
      [F:YSPH]VOL=PVOL
      [F:YSPH]YCAMION=PCAMION
      [F:YSPH]YFECHA = date$
      [F:YSPH]YHORA = HORA
      [F:YSPH]YCERRADO=2 #CERRAMOS EL BULTO
      Rewrite [F:YSPH]

      Call PARAM_YSPACKD(INFNAM, DESTINO, PRELPN)
      #Infbox("->" +INFNAM+" " +DESTINO)
      Call IMPETIQSPACK(PPACNUM, INFNAM,DESTINO)
      PRES="200"
      PMESS="OK"

    Next
  Filter [F:YSPH]
  Close Local File [YSPH]
End


####################################################################
Subprog IMPETIQSPACK(PPACNUM, PINFNAM, PDESTINO)
Value     Char    PINFNAM
Value     Char    PPACNUM
Value     Char    PDESTINO

Local Char    TBPAR(20)(1..20)
Local Char    TBVAL(20)(1..20)
Local Integer LIMPFAC # estado impresión factura
# Fuerzo a que el informe a imprimir sea Y_SAN_ETIQBULTO
PINFNAM = "Y_SAN_ETIQBULTO"
Raz TBPAR, TBVAL, LIMPFAC
TBPAR(1)  = "Bulto"         : TBVAL(1)  = PPACNUM
Call ETAT(PINFNAM, PDESTINO, "SPA", 0, "", TBPAR, TBVAL) From AIMP3
End


########################################################
#**
#* Funcion que devuelve el valor de los parámetros para el informe y para el destino
#*!
Subprog PARAM_YSPACKD(PINFNAM, PDESTINO, PPRELPN)
Variable Char    PINFNAM
Variable Char    PDESTINO
Variable Char    PPRELPN

If !clalev([YTAB]) Then : Local File ATABDIV [YTAB] : Endif

 Filter [F:YTAB] Where NUMTAB = 6001
  For [F:YTAB]
    Case [F:YTAB]A1
      When "ETIQUETABULTO"   :    PINFNAM=[F:YTAB]A2
      When "DESTINOBULTO"  :   PDESTINO=[F:YTAB]A2
      When "PRELPN"  :   PPRELPN=[F:YTAB]A2
    Endcase
  Next

 Close Local File [YTAB]
End


####################################################################
#**
#* Sub que devuelve de una preparación la lista de bustos no terminados
#*
#* Se le pasa el número del listado de preparación
#*!
Subprog GETSPACKLST(  PPRHNUM,  PPACNUM,  PRES, PMESS)
  Value Char PPRHNUM()
  Variable Char PPACNUM()()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([YYSPH]) Then : Local File YSPACK      [YYSPH] : Endif

  Local Integer I
  I=0
  Local Integer STAT
  Filter [F:YYSPH] Where VCRNUM=PPRHNUM and YCERRADO=1
    For [F:YYSPH]
      I=I+1
      PPACNUM(I)=[F:YYSPH]PACNUM
    Next
  PRES="200"
  PMESS="OK"
  Close Local File [YYSPH]
End


####################################################################
#**
#*
#* cambia el estado de la dcoumento  de preparación a "entregable"
#* Comprueba primero que no queda nada por entregar
#* Si el transportista es DACHSER lanzo la generación del envío del fichero de forma automática
#*
#* @param PPRHNUM, lista de distribución
#* @param PUSR, usuario que finaliza la preparación
#* @param PRES , resultado del web service
#* @param PMESS, mensaje
#*!

Subprog PUTDLVFLG(  PPRHNUM, PUSR, PCAMION,  PRES, PMESS)
  Value Char PPRHNUM()
  Value Char PUSR()
  Value Integer PCAMION
  Variable Char PRES()
  Variable Char PMESS()

  Local Char LOK(1)

  If !clalev([YPRH])  Then : Local File STOPREH      [YPRH]  : Endif
  If !clalev([YYPR2]) Then : Local File STOPRED      [YYPR2] : Endif
  If !clalev([YBPT])  Then : Local File BPCARRIER    [YBPT]  : Endif
  If !clalev([YSPA])  Then : Local File YSPACK       [YSPA]  : Endif

    LOK="S"


    Filter [F:YYPR2] Where PRHNUM=PPRHNUM and ([F:YYPR2]QTYSTU-[F:YYPR2]YQTYSTU) > 0 and [YYPR2]ALLQTY<>0
    For [F:YYPR2]
      LOK="N"
      PRES="175"
      PMESS="Preparación sin terminar. No se puede finalizar."
      Break
    Next
    Filter [F:YYPR2]

    # Solamente lo marco entregable si el transportista tiene en el campo Modo de Entrega = Entregable directo
    If LOK="S"
      Read [YPRH]PRH0=PPRHNUM
      If !fstat Then
        Read [YBPT]BPT0 = [YPRH]BPTNUM
        If fstat = 0
          If [YBPT]YMODENTREGA <> 1
            LOK="N"
          Endif
        Else
          LOK="N"
        Endif
      Else
        LOK="N"
      Endif
    Endif

    Local Char HORA(6)
    HORA = num$(time$)
    HORA = mid$(HORA, 1, 2) + mid$(HORA, 4, 2) + mid$(HORA, 7, 2)

    If LOK="S" Then
      Local Integer I
      I=0
      Read [F:YPRH]PRH0=PPRHNUM
      If !fstat Then
        Trbegin [F:YPRH]
        [F:YPRH]DLVFLG = 2
        [F:YPRH]YCAMION = PCAMION
        Rewrite [F:YPRH]
        If !fstat Then
          Commit

          # Si hemos llegado hasta aquí es porque el transportista tiene en el campo Modo de Entrega = Entregable directo,
          # por lo que actualizamos todos los bultos a Cargado = Sí
          Filter [YSPA] Where VCRNUM = PPRHNUM
          For [YSPA]
            Trbegin [YSPA]
            [YSPA]YCARGADO = 2
            Rewrite [YSPA]
            If !fstat Then
              Commit
            Else
              Rollback
            Endif
          Next

          PRES="200"
          PMESS="OK"
        Else
          Rollback
          PRES="100"
          PMESS="Problema modificando entregable en: " +PPRHNUM
          End
        Endif
      Else
        PRES="150"
        PMESS="No existe: "+PPRHNUM
      Endif

      # Gestión del envío DASCHER
      If PMESS="OK"
        Read [F:YPRH]PRH0=PPRHNUM
        If fstat = 0 and [F:YPRH]BPTNUM = 'NA000030' Then
          Local Integer LERR
          Local Char LOK
          Call DACHSER_CHECK(PPRHNUM,LERR) From YENVDACH

          # Si todo OK, genero fichero
          If LERR = 0
            LOK = ""
            Call DACHSER_GENERA_FICHERO(PPRHNUM,LOK) From YENVDACH
            If LOK = 'N'
              Call TRAZA_DACHSER(PPRHNUM,4,GUSER,2) From YENVDACH
            Else
              [F:YPRH]YDACESTADO  = 5
              [F:YPRH]YDACFECHA   = date$
              [F:YPRH]YDACHORA    = time$
              [F:YPRH]YDACUSUARIO = GUSER
              Trbegin [F:YPRH]
                Rewrite [F:YPRH]
              Commit
              Call TRAZA_DACHSER(PPRHNUM,5,GUSER,0) From YENVDACH
            Endif
          Endif

        Endif
      Endif

    Endif




  Close Local File [F:YPRH], [F:YYPR2], [YBPT], [YSPA]
End



####################################################################
#**
#* Devuelve PRES=200 si el documento de preraparación está totalmente terminado
#*
#*!

Subprog GETTERMDOCPREP(  PPRHNUM,  PRES, PMESS)
  Value Char PPRHNUM()
  Variable Char PRES()
  Variable Char PMESS()

  If !clalev([F:YPRD]) Then : Local File STOPRED      [F:YPRD] : Endif

  PRES="200"
  PMESS="OK"
  Filter [F:YPRD] Where PRHNUM=PPRHNUM and PRELIN =PPRELIN
  For [F:YPRD]
    If [F:YPRD]QTYSTU<>[F:YPRD]YQTYSTU Then
      PRES="100"
      PMESS="No está todo servido"
    Endif
  Next
End



####################################################################
#**
#* APP Devuelve la lista de pedidos que cumplen una serie de condiciones:
#* -Entre sus componentes hay líneas de prepicking
#* #*
#* @param PSOHNUM
#* @param PBPCORD
#* @param PBPCNAM
#* @param PDLVDATMIN, ATENCIÓN CAMBIADO A SHIDAT, aunque el nombre se mantenga
#* @param PORDSTA
#* @param PBPTNUM
#* @param PBPTNAM
#* @param PTCTRNUM
#* @param PRES
#* @param PMESS
#* @param PDVLDATDESDE,FILTROS CAMBIADO A SHIDAT
#* @param PDVLDATHASTA
#* @param PBPCORDDESDE
#* @param PBTNUMDESDE
#* @param PTSICOD0 FAMILIA ESTADÍSTICA 1, (tabla varia 20) corresponde a Familia Superior
#* @param PTSICOD1 FAMILIA ESTADÍSTICA 2, (tabla varia 21)  corresponde a Familia
#*!
Subprog GETLISTPEDIDOS(PSOHNUM, PBPCORD,  PBPCNAM,  PDLVDATMIN, PORDSTA,  PBPTNUM , PBPTNAM,  PTCTRNUM, PSHIDAT, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA, PBPCORDDESDE, PBTNUMDESDE, PTSICOD0, PTSICOD1)

  Variable Char PSOHNUM()()
  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PDLVDATMIN()()
  Variable Integer PORDSTA()
  Variable Char PBPTNUM()()
  Variable Char PBPTNAM()()
  Variable Char PTCTRNUM()()
  Variable Char PSHIDAT()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()
  Variable Char PBPCORDDESDE()
  Variable Char PBTNUMDESDE()
  Variable Char PTSICOD0()
  Variable Char PTSICOD1()

  Local    Char ESTADO

  If !clalev([YPBR]) Then : Local File BPARTNER    [YPBR] : Endif

 Local Char LREQSQL(250)(20)
 Raz LREQSQL

  LREQSQL(0) =
&
& " SELECT P.SOHNUM_0, P.BPCORD_0, C.BPCNAM_0, MIN(D.SHIDAT_0) AS SHIDATMIN, P.ORDSTA_0, ISNULL(P.BPTNUM_0,'') As PBTNUM, ISNULL(CA.BPTNAM_0,'') As BPTNAM,'' As TCTRNUM,  D.SHIDAT_0"
  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
  LREQSQL(3) = " LEFT JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0 "
  LREQSQL(4) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 and P.YAPPWIP_0<>2 "
  LREQSQL(5) = " and ((D.ALLQTYSTU_0 > 0 and D.ALLTYP_0 = 1) or (D.ALLTYP_0 = 2 and ((ISNULL((SELECT sum(A.QTYSTU_0) "
  LREQSQL(6) = " From " + nomap + ".STOALL A Where A.VCRNUM_0 = D.SOHNUM_0 and A.VCRLIN_0 = D.SOPLIN_0 and A.ALLTYP_0 = 2 and A.STOCOU_0 IN("
  LREQSQL(7) = " SELECT K.STOCOU_0 From " + nomap + ".STOCK K Where K.STOFCY_0='11' and K.LPNNUM_0='')), 0) > 0)) and "
  LREQSQL(8) = " (D.QTYSTU_0 - D.SHTQTYSTU_0 - ISNULL((SELECT sum(A.QTYSTU_0)"
  LREQSQL(9) = " From " + nomap + ".STOALL A Where A.VCRNUM_0 = D.SOHNUM_0 and A.VCRLIN_0 = D.SOPLIN_0 and A.ALLTYP_0 = 2 and A.STOCOU_0 IN("
  LREQSQL(10)= " SELECT K.STOCOU_0 From " + nomap + ".STOCK K Where K.STOFCY_0='11' and K.LPNNUM_0='')), 0) >= 0)))"

  #fecha envío
  If PDVLDATDESDE <> "" Then
    LREQSQL(11) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
  Endif
  If PDVLDATHASTA <> "" Then
    LREQSQL(12) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
  Endif
   #Cliente
  If PBPCORDDESDE <> "" Then
    LREQSQL(13) += " AND P.BPCORD_0='" + PBPCORDDESDE + "'"
  Endif
  #transportista
  If PBTNUMDESDE <> "" Then
    LREQSQL(14) += " AND P.BPTNUM_0='" + PBTNUMDESDE + "'"
  Endif
  #Familia estadística 1, Familia superior
  If PTSICOD0 <> "" Then
    LREQSQL(15) += " AND A.TSICOD_0='" + PTSICOD0 + "'"
  Endif
  #Familia estadística 2, Familia
  If PTSICOD1 <> "" Then
    LREQSQL(16) += " AND A.TSICOD_1='" + PTSICOD1 + "'"
  Endif

  LREQSQL(17) += " GROUP By P.SOHNUM_0, P.BPCORD_0, C.BPCNAM_0, P.ORDSTA_0, ISNULL(P.BPTNUM_0,''),ISNULL(CA.BPTNAM_0,''),D.SHIDAT_0"
  LREQSQL(18) += " ORDER By C.BPCNAM_0 ASC"

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I: I=0

 I=0
  For (Char SOHNUM, Char BPCORD, Char BPCNAM, Date SHIDATMIN, Integer ORDSTA, Char BPTNUM, Char BPTNAM, Char TCTRNUM, Date SHIDAT) From '5' Sql LREQSQL(0..20) As [YAPP]
        Infbox ("ESTADO" -[F:YAPP]SOHNUM-[F:YAPP]BPCNAM)
        PSOHNUM(I)=[F:YAPP]SOHNUM
        PBPCORD(I)=[F:YAPP]BPCORD
        Read [YPBR]BPR0 = [F:YAPP]BPCORD
        If fstat = 0
          PBPCNAM(I)=[YPBR]BPRNAM(0) + [YPBR]BPRNAM(1)
        Endif
        PDLVDATMIN(I)=num$([F:YAPP]SHIDATMIN)
        PORDSTA(I)=[F:YAPP]ORDSTA
        PBPTNUM(I)=[F:YAPP]BPTNUM
        PBPTNAM(I)=[F:YAPP]BPTNAM
        PTCTRNUM(I)=[F:YAPP]TCTRNUM
        PSHIDAT(I)=num$([F:YAPP]SHIDAT)
        PRES = '200'
        PMESS = 'OK'
        I+=1
        If I>LISTMAX Then
          Break
        Endif
#      Endif

    Next

Close Local File [YPBR]
End


####################################################################
#**
#* Testea el estado de un pedido
#*
#* @param SOHNUM
#* @param ESTADO
#* ESTADO="T": TERMINADO
#* ESTADO="P": CAJA EN PROCESO
#* ESTADO="C": TODAS LA CAJAS TERMINADAS
#*!
Subprog TESTESTADOPEDIDO(PSOHNUM, PESTADO, PRES, PMESS)
  Variable Char PSOHNUM()
  Variable Char PESTADO()
  Variable Char PRES
  Variable Char PMESS


  Local Decimal CANTIDAD_ASIGNADA
  Local Decimal CANTIDAD_EN_PROCESO
  Local Decimal CANTIDAD_TERMINADA


If !clalev([YSOQ]) Then : Local File SORDERQ     [YSOQ] : Endif
If !clalev([YSTO]) Then : Local File STOCK       [YSTO] : Endif
If !clalev([YLPN]) Then : Local File LPN         [YLPN] : Endif

CANTIDAD_ASIGNADA=0
CANTIDAD_EN_PROCESO=0
CANTIDAD_TERMINADA=0

Filter [F:YSOQ] Where SOHNUM=PSOHNUM and SOQSTA <>3 and ALLQTYSTU > 0


For [F:YSOQ]
    CANTIDAD_ASIGNADA=CANTIDAD_ASIGNADA+[F:YSOQ]ALLQTY
    Filter [F:YLPN] Where ZSOHNUM=PSOHNUM
    For [F:YLPN]
      Filter[F:YSTO] Where LPNNUM= [F:YLPN]LPNNUM and STOFCY = '11' and ITMREF=[F:YSOQ]ITMREF
        For [F:YSTO]
          If !fstat Then
            If [F:YLPN]PRTFLG= 2 Then
               CANTIDAD_TERMINADA=CANTIDAD_TERMINADA+[F:YSTO]QTYPCU
            Else
               CANTIDAD_EN_PROCESO=CANTIDAD_EN_PROCESO+[F:YSTO]QTYPCU
            Endif

          Endif
       Next
  Next
Next

If CANTIDAD_TERMINADA=CANTIDAD_ASIGNADA Then
  PESTADO="T"
Else If CANTIDAD_EN_PROCESO > 0 Then
    PESTADO="P"
  Else
    PESTADO="C"
  Endif
Endif

Close Local File [YSOQ]
Close Local File [YSTO]
Close Local File [YLPN]

End


####################################################################
#**
#* APP devuelve la lista de clientes de un intervalo de pedidos filtrado por fecha
#*
#*!
Subprog GETLSCLPED(PBPCORD, PBPCNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPCORD()()
  Variable Char PBPCNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(14)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0

  If !clalev([YBPR]) Then : Local File BPARTNER [YBPR] : Endif

    Raz LREQSQL

  LREQSQL(0) = " SELECT P.BPCORD_0, C.BPCNAM_0 "
  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN  " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
  LREQSQL(3) = " LEFT JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0"
  LREQSQL(4) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 AND D.ALLQTYSTU_0 > 0 "
  #fecha envío
  If PDVLDATDESDE <> "" Then
    LREQSQL(5) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
  Endif
  If PDVLDATHASTA <> "" Then
    LREQSQL(6) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
    Endif

  LREQSQL(11) += " GROUP By P.BPCORD_0, C.BPCNAM_0 "
  LREQSQL(12) += " ORDER By C.BPCNAM_0 ASC"

  I=0
  For (Char BPCORD, Char BPCNAM) From '5' Sql LREQSQL(0..12) As [YAPP]
    PBPCORD(I)=[F:YAPP]BPCORD
    Read [YBPR]BPR0 = [F:YAPP]BPCORD
    If fstat = 0
      PBPCNAM(I) = [YBPR]BPRNAM(0) + [YBPR]BPRNAM(1)
    Endif
    PRES = '200'
    PMESS = 'OK'
    I+=1
    If I>LISTMAX Then
      Break
    Endif

  Next

Close Local File [YBPR]
End



####################################################################
#**
#* Sub que devuelve los trasportistas de la  lista de preparción en curso
#*APP devuelve la lista de tranport. de un intervalo de pedidos filtrado por fecha
#*!
Subprog GETLSTRPED(PBPTNUM, PBPTNAM, PRES, PMESS, PDVLDATDESDE, PDVLDATHASTA)

  Variable Char PBPTNUM()()
  Variable Char PBPTNAM()()
  Variable Char PRES
  Variable Char PMESS
  Variable Char PDVLDATDESDE()
  Variable Char PDVLDATHASTA()

  Local Char LREQSQL(250)(14)

  Local Integer LISTMAX : LISTMAX = 199
  Local Integer I       : I = 0
   Raz LREQSQL

  LREQSQL(0) = " SELECT P.BPTNUM_0, CA.BPTNAM_0"
  LREQSQL(1) = " From " + nomap + ".SORDER P INNER JOIN " + nomap + ".SORDERQ D ON P.SOHNUM_0=D.SOHNUM_0 INNER JOIN " + nomap + ".YITMTECNICO T ON D.ITMREF_0=T.ITMREF_0 "
  LREQSQL(2) = " INNER JOIN " + nomap + ".BPCUSTOMER C ON P.BPCORD_0=C.BPCNUM_0  INNER JOIN  " + nomap + ".ITMMASTER A ON D.ITMREF_0=A.ITMREF_0 "
  LREQSQL(3) = " INNER JOIN " + nomap + ".BPCARRIER CA ON P.BPTNUM_0=CA.BPTNUM_0"
  LREQSQL(4) = " Where T.PREPICKING_0=2 and P.ORDSTA_0=1 and P.CDTSTA_0=1 and P.HLDSTA_0=1 AND D.ALLQTYSTU_0 > 0 "
  #fecha envío
  If PDVLDATDESDE <> "" Then
    LREQSQL(5) += " AND D.SHIDAT_0>='" + (PDVLDATDESDE) + "'"
  Endif
  If PDVLDATHASTA <> "" Then
    LREQSQL(6) += " AND D.SHIDAT_0<='" + (PDVLDATHASTA) + "'"
    Endif
  LREQSQL(11) += " GROUP By P.BPTNUM_0, CA.BPTNAM_0   "
  LREQSQL(12) += " ORDER By CA.BPTNAM_0  ASC"
  I=0
  For (Char BPTNUM, Char BPTNAM) From '5' Sql LREQSQL(0..13) As [YAPP]
    If [F:YAPP]BPTNUM <>"" Then
        PBPTNUM(I)=[F:YAPP]BPTNUM
        PBPTNAM(I) = [F:YAPP]BPTNAM
        PRES = '200'
        PMESS = 'OK'
        I+=1
        If I>LISTMAX Then
          Break
        Endif
    Endif
  Next
End



################################################################################
#**
#*
#* APP Devuelve las líneas de un pedido para prepicking
#*
#* @param PSOHNUM: pedido
#* @param PSOPLIN
#* @param PITMREF
#* @param PITMDES
#* @param PLPNNUM
#* @param PQTY
#* @param PQTYLPN
#* @param PRES : resultado
#* @param PMESS
#*!
Subprog GETLSLIPED (PSOHNUM, PSHIDAT, PTSICOD0, PTSICOD1, PSOPLIN, PITMREF, PITMDES, PLPNNUM, PPRTFLG ,PQTY, PQTYLPN, PLPNNUM_USADO,PRES, PMESS  )
Value Char PSOHNUM()
Value Char PSHIDAT()
Value Char PTSICOD0()
Value Char PTSICOD1()
Variable Integer  PSOPLIN()
Variable Char  PITMREF()()
Variable Char   PITMDES()()
Variable Char   PLPNNUM()()
Variable Char   PPRTFLG()()
Variable Decimal PQTY()
Variable Decimal  PQTYLPN()
Variable Char   PLPNNUM_USADO()
Variable Char   PRES
Variable Char   PMESS()

Local Char EXISTE_LPN(1)

If !clalev([YSOH]) Then : Local File SORDER      [YSOH] : Endif
If !clalev([YSOQ]) Then : Local File SORDERQ     [YSOQ] : Endif
If !clalev([YSTO]) Then : Local File STOCK       [YSTO] : Endif
If !clalev([YLPN]) Then : Local File LPN         [YLPN] : Endif
If !clalev([YITM]) Then : Local File ITMMASTER   [YITM] : Endif
If !clalev([YITT]) Then : Local File YITMTECNICO [YITT] : Endif
If !clalev([P1])   Then : Local File STOALL      [P1]   : Endif
If !clalev([P2])   Then : Local File STOCK       [P2]   : Endif

PLPNNUM_USADO=""


Read [F:YSOH]SOH0=PSOHNUM
If !fstat Then
  If [F:YSOH]CDTSTA<>1 Then
    PRES="101"
    PMESS="No hay crédito"
    End
  Endif
  If [F:YSOH]HLDSTA<>1 Then
    PRES="102"
    PMESS="Bloqueado manualmente"
    End
  Endif
  If [F:YSOH]ORDSTA <>1 Then
    PRES="101"
    PMESS="Línea saldada"
    End
  Endif
Else
  PRES="100"
  PMESS="No existe el pedido"
    End
Endif



Local Date DDD
DDD=gdat$(val(left$(PSHIDAT,2)), val(mid$(PSHIDAT,4,2)), val(right$(PSHIDAT,7)))
Filter [F:YSOQ] Where SOHNUM=PSOHNUM and SOQSTA <>3 and ALLQTYSTU > 0 and SHIDAT= DDD
PRES="150"
PMESS="Error leyendo información"
I=0
EXISTE_LPN="N"
For [F:YSOQ]
  Read [YITT]YITT0=[F:YSOQ]ITMREF
  If !fstat Then
     If   [YITT]PREPICKING= 2 Then
       Read [F:YITM]ITM0=[F:YSOQ]ITMREF
       If !fstat Then
         #Testeamos las familias que pasamos, pasen bien
         If PTSICOD0 = "" or PTSICOD0=[F:YITM]TSICOD(0)
           If PTSICOD1 = "" or PTSICOD0=[F:YITM]TSICOD(1)
              PSOPLIN(I)=[F:YSOQ]SOPLIN
              PITMREF(I)=[F:YITM]ITMREF
              PITMDES(I)=[F:YITM]ITMDES1

              # Tenemos que obtener la cantidad que sería "preparable", que es la cantidad asignada si hay o la pendiente de preparar si no hay asignación
              If [F:YSOQ]ALLQTYSTU <> 0
                PQTY(I) = [F:YSOQ]ALLQTYSTU
                # De la cantidad que tengo 'preparable' solamente tengo en cuenta la cantidad que NO esté en cajas
                Local Integer QTY_NO_CAJAS
                Local Integer QTY_SI_CAJAS
                Filter [P1] Where [P1]VCRNUM = [F:YSOQ]SOHNUM and [P1]VCRSEQ = [F:YSOQ]SOQSEQ and [P1]VCRLIN = [F:YSOQ]SOPLIN and [P1]ALLTYP = 2
                  For [P1]
                    Read [P2]STO0 = [P1]STOFCY;[P1]STOCOU
                    If fstat = 0
                      If [P2]LPNNUM = ""
                      [L]QTY_NO_CAJAS += [P1]QTYSTU
                      Else
                      [L]QTY_SI_CAJAS += [P1]QTYSTU
                      Endif
                    Endif
                  Next
                Filter [P1]
                If [L]QTY_NO_CAJAS > 0
                  PQTY(I) = min(PQTY(I),[L]QTY_NO_CAJAS) + [L]QTY_SI_CAJAS
                Endif
              Else
                PQTY(I) = [F:YSOQ]QTYSTU - [F:YSOQ]DLVQTYSTU - [F:YSOQ]OPRQTYSTU - [F:YSOQ]ODLQTYSTU - [F:YSOQ]SHTQTYSTU
              Endif


              PLPNNUM(I)=""
              PQTYLPN(I)=0
              Filter [YLPN] Where [YLPN]ZSOHNUM = PSOHNUM and [YLPN]PRTFLG <> 2 Order By [YLPN]LPNNUM Desc
              Read [YLPN] First
              If fstat = 0
                EXISTE_LPN="S"
                PLPNNUM_USADO=[YLPN]LPNNUM
              Endif
              Filter [YLPN]

              PQTYLPN(I)= PQTYLPN(I)+[F:YSOQ]YLPNQTY
              I=I+1



           Endif #familia estadística 1
        Endif #familia estadística 0
       Endif    #YITM
     Endif # PREPICKING
   Endif # YITT
  PRES="200"
  PMESS="OK"
Next


#Si no hay caja, la creamos
Local Char LPNNUM(20)
Local Char RES(20)
Local Char MENSAJE(100)

If EXISTE_LPN="N" and rowcount([F:YSOQ]) > 0 and PRES="200" Then
      Call GETLPNNUM(LPNNUM, RES, MENSAJE)
      If RES = "200" Then
        PLPNNUM_USADO=LPNNUM
      Else
        PRES=RES
        PMESS=MENSAJE
      Endif
Endif

Close Local File [YSOQ]
Close Local File [YSTO]
Close Local File [YLPN]
Close Local File [YITM]
Close Local File [YITT]
Close Local File [P1]
Close Local File [P2]
End


################################################################################
#**
#* APP: devuelve el número suigueinte del contador del LPN
#*!
Subprog GETLPNNUM(LPNNUM, PRES, PMESS  )
Variable Char LPNNUM
Variable Char   PRES
Variable Char   PMESS()
Local Char CONTADOR
Local Integer STAT

  If !clalev([YTCTR]) Then : Local File TABCONTAINER  [YTCTR] : Endif

  Read [F:YTCTR]TCTR0="PREPICKING"
  If !fstat Then
    CONTADOR = [F:YTCTR]LPNREFCOU
    PRES="200"
    PMESS="OK"
  Else
    CONTADOR = ""
    PRES="100"
    PMESS="NO HAY CONTADOR"
  Endif

  Call NUMERO(CONTADOR,"11",date$,"",LPNNUM,STAT) From SUBANM
End LPNNUM



################################################################################
#**
#* APP: Devuelve los parámetros para el prepicking
#*
#* @param PUBICPREPICKING
#* @param PTIPOUBICPREPICKING
#* @param PALMIOPRE
#*!
Subprog GETPARPREP(PUBICPREPICKING, PTIPOUBICPREPICKING, PALMIOPRE, PCONTENEDOR, PRES, PMESS)
Variable Char    PUBICPREPICKING
Variable Char    PTIPOUBICPREPICKING
Variable Char    PALMIOPRE
Variable Char    PCONTENEDOR
Variable Char    PRES
Variable Char   PMESS

If !clalev([YTAB]) Then : Local File ATABDIV [YTAB] : Endif

 Filter [F:YTAB] Where NUMTAB = 6001
  For [F:YTAB]
    Case [F:YTAB]A1
      When "UBICPREPICKING"       :   PUBICPREPICKING=[F:YTAB]A2
      When "TIPOUBICPREPICKING"   :   PTIPOUBICPREPICKING=[F:YTAB]A2
      When "ALMIOPRE"             :   PALMIOPRE=[F:YTAB]A2
      When "CONTENEDOR"           :   PCONTENEDOR=[F:YTAB]A2
     Endcase
  Next

 Close Local File [YTAB]

PRES="200"
PMESS="OK"

End


######################################################################################
#**
#* APP: busca si existe el LPN
#*
#* @param PLPNNUM
#* @param PRES
#* @param PMESS
#*!
Subprog TESTEALPN(PLPNNUM, PRES, PMESS)
  Variable Char PLPNNUM
  Variable Char PRES
  Variable Char  PMESS

  If !clalev([F:YLPN]) Then : Local File LPN  [F:YLPN] : Endif

  Read[F:YLPN]LPN0=PLPNNUM
  If !fstat Then
    PRES="200"
    PMESS="OK"
  Else
    PRES="100"
    PMESS="No existe"
  Endif

Close Local File [F:YLPN]

End



######################################################################################
#**
#*
#* APP: Testea el código de barras del artículo y la cantidad pendiente
#*
#* @param SOHNUM
#* @param ITMREF
#* @param PCODIGOBARRAS
#* @param PLPNNUM: caja que le pasamos
#* @param PQTY: cantidad a dar de alta
#* @param PLPNNUMCAJ: caja en la que se encuentra.
#* @param PQTYSTUCAJ: cantidad para el artículo que ya está en la caja
#*
#* @param PRES :
#*  200_ ok, se da de alta
#*
#* @param PMESS
#*
#*
#*!
Subprog TESTPPCBAR(PSOHNUM, PSHIDAT, PTSICOD0, PTSICOD1, PCODIGOBARRAS, PLPNNUM, PQTY, PITMREF, PLPNNUMCAJ, PQTYSTUCAJ, PPCU, PSTU,PSTUCOE,   PVCRDES, PRES, PMESS)
 Value Char PSOHNUM()
 Value Char PSHIDAT()
 Value Char PTSICOD0()
 Value Char PTSICOD1()
 Value Char PCODIGOBARRAS()
 Value Char PLPNNUM
 Value Decimal PQTY
 Variable Char PITMREF()
 Variable Char PLPNNUMCAJ()
 Variable Decimal  PQTYSTUCAJ
 Variable Char PPCU()
 Variable Char PSTU()
 Variable Decimal PSTUCOE
 Variable Char PVCRDES()
 Variable Char  PRES()
 Variable Char   PMESS()


 Local  Integer CANTIDAD

  If !clalev([YSOQ]) Then : Local File SORDERQ          [YSOQ] : Endif
  If !clalev([YSOP]) Then : Local File SORDERP          [YSOP] : Endif
  If !clalev([YITM]) Then : Local File ITMMASTER        [YITM] : Endif
  If !clalev([YLPN]) Then : Local File LPN              [YLPN] : Endif
  If !clalev([F:YASLS]) Then : Local File YAPPSUMLPNST  [F:YASLS] : Endif

  #Leemos las líneas de producto agrupdas
    PRES="100"
    PMESS="No se encuentra"

    Local Char LREQSQL(250)(14)

    Raz LREQSQL

    LREQSQL(0) = "Select SOHNUM_0, SOPLIN_0, ITMREF_0, ALLQTYSTU_0 "
    LREQSQL(1) = " From "+nomap + ".SORDERQ "
    LREQSQL(2) = " Where SOHNUM_0='" +PSOHNUM+"'"
    LREQSQL(3) = " GROUP BY SOHNUM_0, SOPLIN_0, ITMREF_0"
    LREQSQL(4) = " ORDER BY SOPLIN_0 ASC"

  I=0
  CANTIDAD=1
  Local Date DDD
  DDD=gdat$(val(left$(PSHIDAT,2)), val(mid$(PSHIDAT,4,2)), val(right$(PSHIDAT,7)))
  Filter [F:YSOQ] Where SOHNUM=PSOHNUM and SOQSTA <>3 and ALLQTYSTU > 0 and SHIDAT= DDD
For [F:YSOQ]
    #segundo si el código EAN  existe")
    Read [YITM]ITM0=[F:YSOQ]ITMREF
    If !fstat Then
      # Si cumple el requisito de las familias, salimos
       If PTSICOD0 = "" or PTSICOD0=[F:YITM]TSICOD(0)
         If PTSICOD1 = "" or PTSICOD0=[F:YITM]TSICOD(1)
          # ean, lo encontramos
            If [F:YITM]EANCOD=PCODIGOBARRAS Then
              # Valores den SORDERQ
              Read [F:YSOP]SOP3=[F:YSOQ]SOHNUM;[F:YSOQ]SOPLIN
              If !fstat Then
               PPCU=[F:YSOP]SAU
               PSTU=[F:YSOP]STU
               PSTUCOE=[F:YSOP]SAUSTUCOE
               PVCRDES=left$([F:YSOQ]SOHNUM + ' ' +[F:YSOP]ITMDES1,80)
              Else
                PRES="110"
                PMESS="Problemas con el pedido"
                Break
              Endif
              PITMREF=[F:YITM]ITMREF
              If ([F:YSOQ]YLPNQTY+PQTY)>[F:YSOQ]ALLQTYSTU Then
                PRES="100"
                PMESS="No se puede poner más de lo que hay asignado."
                #Seguimos por si hay otro
              Else
                #en la linea de pedido, ponemos el LPN y la candidad
                If PLPNNUM<>"" Then
                  Read [F:YLPN]LPN0 =PLPNNUM
                  If !fstat Then
                    Infbox("Existe: " + PLPNNUM)
                    Trbegin [F:YSOQ]
                    [F:YSOQ]YLPNNUM=PLPNNUM
                    [F:YSOQ]YLPNQTY=PQTY+[F:YSOQ]YLPNQTY
                    Rewrite [F:YSOQ]
                    If !fstat Then
                      Commit
                      PRES="200"
                      PMESS="Grabada correctamente"
                      Break
                    Else
                      Rollback
                      PRES="120"
                      PMESS="No se puede grabar la caja"

                    Endif
                  Else
                    PRES="130"
                    PMESS="No existe la caja"
                  Endif
                Else
                    PRES="200"
                    PMESS="Correcto"
                Endif
                Break
              Endif
              Endif
         Endif #TSICOD1
       Endif  #TSICOD0
    Endif      #EXISTE artículo
Next

Close Local File [F:YITM]
Close Local File [F:YASLS]
Close Local File [YSOP]
Close Local File [YSOQ]
Close Local File [YLPN]
End



######################################################################################
#**
#*
#* APP. Imprime la etiqueta del contenedot (LPN)y pone la marca de impreso
#*
#* @param PLPNNUM
#* @param PRES
#* @param PMESS
#*!
Subprog ENDLPN(PLPNNUM,  PRES, PMESS)
  Value Char PLPNNUM()
  Variable Char PRES()
  Variable Char PMESS()


Local Char    INFNAM(30)
Local Char    PACNUM(30)
Local Char    DESTINO(30)
Local Char    TCTRNUM(30)
Local Char    TBVAL(20)(1..20)
Local Char    TBPAR(20)(1..20)
Local Integer LIMPFAC # estado impresión factura


  If !clalev([YLPN]) Then : Local File LPN      [YLPN] : Endif
  If !clalev([YTCTR]) Then : Local File TABCONTAINER      [YTCTR] : Endif
  #
  # Buscamos el contador para el nuevo bulto
  #
  Local Integer I
  I=0
  Local Integer STAT

  Read [F:YLPN]LPN0=PLPNNUM
  If !fstat Then
    Read [F:YTCTR]TCTR0=[F:YLPN]TCTRNUM
    If !fstat Then
        INFNAM=[F:YTCTR]LBEFMT
    Else
      PRES="100"
      PMESS="No está definida etiqueta"
      End
    Endif
  Else
      PRES="110"
      PMESS="No se encuentra la caja"
      End
  Endif

#imprimimos
 Raz TBPAR, TBVAL, LIMPFAC


        adxifs = ""                      #-- adxifs, separador de campo
        adxirs = chr$(13)+chr$(10)       #-- adxirs, separador de registro
        adxium = GASCII                  #-- adxium, ASCII

        TBPAR(3)  = "numedt"        : TBVAL(3)  = PLPNNUM
       # lanza el informe..
       DESTINO=""
        Call ETAT(INFNAM, DESTINO, "SPA", 0, "", TBPAR, TBVAL) From AIMP3

    Trbegin [F:YLPN]
    [F:YLPN]PRTFLG=2
    Rewrite [F:YLPN]
    If !fstat Then
      Commit
      PRES="200"
      PMESS="OK"
    Else
      Rollback
      PRES="100"
      PMESS="Problema modificando impriso en: " + PLPNNUM
      End
    Endif
  Close Local File [F:YLPN]
  Close Local File [F:YTCTR]

End



#######################################################################################
# Común a las preparación y al prepicking
######################################################################################
#**
#* Devuelve el código y la descripción de la familia que se pasa
#*
#* @param PNUMTAB, código de la familia a recoger
#* @param PCODE
#* @param PLNGDES
#* @param PRES
#* @param PMESS
#*!
Subprog GETFAMEST(PNUMTAB, PCODE, PLNGDES, PRES, PMESS)
  Value Integer PNUMTAB
  Variable Char PCODE()()
  Variable Char PLNGDES()()
  Variable Char PRES
  Variable Char PMESS


 If !clalev([F:YADI]) Then : Local File  ATABDIV     [F:YADI] : Endif
  Local Integer I
  I=0

 Filter [F:YADI] Where NUMTAB=PNUMTAB Order By CODE Asc
  For [F:YADI]
    PCODE(I)=[F:YADI]CODE
    PLNGDES(I)=func AFNC.TEXTRA("ATABDIV","LNGDES", num$(PNUMTAB),[F:YADI]CODE)
    Infbox(PCODE(I)+PLNGDES(I))
    I=I+1
  Next

PRES="200"
PMESS="Lectura correcta"
  Close Local File [YADI]

End



######################################################################################
#**
#* Asignación detallada de líneas de pedido.
#* @param PEDIDO
#* @param CONTENEDOR
#* @param LRET
#* @param LMESS
#*!
Subprog ASIGNACION_DETALLADA(PEDIDO, CONTENEDOR, LRET, LMESS)
  Value Char PEDIDO
  Value Char CONTENEDOR
  Variable Integer LRET
  Variable Char LMESS

  Local Char PLANTA(2)
  Local Integer LRET1
  Local Integer LRET2
  Local Integer LRET3

  Local Decimal CANT_RUPTURA

  # Apertura de tablas
  If !clalev([YSTO]) : Local File STOCK [YSTO] : Endif
  If !clalev([YSTA]) : Local File STOALL [YSTA] : Endif
  If !clalev([YSOQ]) : Local File SORDERQ [YSOQ] : Endif

  Filter [YSOQ] Where SOHNUM = PEDIDO and YLPNNUM = CONTENEDOR
  For [YSOQ]
    PLANTA = [YSOQ]STOFCY
    Filter [YSTO] Where LPNNUM = CONTENEDOR and ITMREF = [YSOQ]ITMREF
    Read [YSTO] First
    If fstat = 0 Then
      # Primero comprobamos si existen cantidades en ruptura
      Raz CANT_RUPTURA
      Filter [YSTA] Where VCRNUM = PEDIDO and VCRLIN = [YSOQ]SOPLIN and [YSTA]ALLTYP = 5
      For [YSTA]
        CANT_RUPTURA += [YSTA]QTYSTUACT
      Next

      # Eliminamos la asignación global
      # Necesito saber el número de secuencia de la asignación
      Filter [YSTA] Where VCRNUM = PEDIDO and VCRLIN = [YSOQ]SOPLIN and [YSTA]ALLTYP = 1
      Read [YSTA] First
      If fstat = 0 Then
        # Desasignamos sólo si tiene asignación goblal
          Call SUPALL(PLANTA, [YSOQ]ITMREF, 0.0, [YSTA]SEQ , LRET1) From STKALL
          Infbox('ASIGNACIÓN GLOBAL ELIMINADA')
        # A continuación hacemos la asignación detallada
        Call CREALL(2, PLANTA, [YSOQ]ITMREF, [YSTO]STOCOU, date$, [YSTO]QTYSTU, [YSTO]QTYSTU, 2, PEDIDO, [YSOQ]SOPLIN, [YSOQ]SOPLIN, "", date$, "", "","","","","",0.00,0.00,"","",
& "","",1,"",LRET2) From STKALL
          Infbox('FIN ASIGNACIÓN DETALLADA')

        # Por último, actualizamos la línea de pedido
        Call MAJALLORD(PEDIDO, [YSOQ]SOPLIN, [YSOQ]SOPLIN, 2, 1, [YSTO]QTYSTU, CANT_RUPTURA, LRET3) From TRTVENALL

        Filter [YSTA]
      Endif

      Filter [YSTO]
    Endif
  Next

  Filter [YSOQ]

  # Resultados
  LRET = 1
  LMESS = "Si hemos llegado hasta aquí, se supone que está bien"

  # Cierre de tablas
  Close Local File [YSTO]
  Close Local File [YSTA]
  Close Local File [YSOQ]
End

# JMF - 02.01.2024
# Subprograma para cambiar el estado WIP de un pedido en la APP
#**!
#*
#* @param PCOD_PEDIDO
#* @param PWIP
#* @param PRES
#* @param PMESS
#*!
Subprog CAMBIARWIPPEDIDO(PCOD_PEDIDO, PWIP, PRES, PMESS)
  # Entrada
  Value Char PCOD_PEDIDO
  Value Integer PWIP
  # Salida
  Variable Integer PRES
  Variable Char PMESS

  PRES = 100
  PMESS = "Error al actualizar WIP"

  If !clalev([YSOH]) : Local File SORDER [YSOH] : Endif

  Read [YSOH]SOH0 = PCOD_PEDIDO
  If !fstat Then
    Trbegin [YSOH]
    If !fstat Then
      [YSOH]YAPPWIP = PWIP
      Rewrite [YSOH]
      If !fstat Then
        Commit
        PRES = 200
        PMESS = "Actualización WIP correcta"
      Else
        Rollback
      Endif
    Endif
  Endif

  Close Local File [YSOH]
End

Subprog CONTROLWIPPEDIDO(COD_PEDIDO, ESTADO)
  # Entrada
  Value Char COD_PEDIDO
  # Salida
  Variable Integer ESTADO : ESTADO = -1

  If !clalev([YSOH]) : Local File SORDER [YSOH] : Endif

  Read [YSOH]SOH0 = COD_PEDIDO
  If !fstat Then
    ESTADO = [YSOH]YAPPWIP
  Endif

  Close Local File [YSOH]
End

Subprog MARCARPREPARACIONENTREGABLE(PPRHNUM, PRES)
  # Entrada
  Value Char PPRHNUM
  # Salida
  Variable Integer PRES

  PRES = 0

  If !clalev([YPRH]) : Local File STOPREH [YPRH] : Endif

  Read [YPRH]PRH0 = PPRHNUM
  If !fstat Then
    Trbegin [YPRH]
    If !fstat Then
      [YPRH]DLVFLG = 2
      Rewrite [YPRH]
      If !fstat Then
        Commit
        PRES = 1
      Else
        Rollback
      Endif
    Endif
  Endif

  Close Local File [YPRH]
End

Subprog CAMBIARWIPPREPARACION(PCOD_PREPARACION, PWIP, PRES, PMESS)
  # Entrada
  Value Char PCOD_PREPARACION
  Value Integer PWIP
  # Salida
  Variable Integer PRES
  Variable Char PMESS

  PRES = 100
  PMESS = "Error al actualizar WIP"

  If !clalev([SPH]) : Local File STOPREH [SPH] : Endif

  Read [SPH]PRH0 = PCOD_PREPARACION
  If !fstat Then
    Trbegin [SPH]
    If !fstat Then
      [SPH]YAPPWIP = PWIP
      Rewrite [SPH]
      If !fstat Then
        Commit
        PRES = 200
        PMESS = "Actualización WIP correcta"
      Else
        Rollback
      Endif
    Endif
  Endif

  Close Local File [SPH]
End

Subprog CONTROLWIPPREPARACION(COD_PREPARACION, ESTADO)
  # Entrada
  Value Char COD_PREPARACION
  # Salida
  Variable Integer ESTADO : ESTADO = -1

  If !clalev([SPH]) : Local File STOPREH [SPH] : Endif

  Read [SPH]PRH0 = COD_PREPARACION
  If !fstat Then
    ESTADO = [SPH]YAPPWIP
  Endif

  Close Local File [SPH]
End

Subprog MARCARBULTOCARGADO(PCOD_BULTO)
  Value Char PCOD_BULTO

  If !clalev([YSPA]) : Local File YSPACK [YSPA]: Endif

  Filter [YSPA] Where PACNUM = PCOD_BULTO
  Read [YSPA] First
  If !fstat
    Trbegin [YSPA]
    If !fstat
      [YSPA]YCARGADO = 2
      Rewrite [YSPA]
      If !fstat
        Commit
      Else
        Rollback
      Endif
    Endif
  Endif

  Filter [YSPA]

  Close Local File [YSPA]
End

##########################################################
#**
#*Estado de empaquetamiento del vale de preparación
#*
#* @param PPRHNUM
#*!
Funprog ESTADO_VALE(PPRHNUM)
Value Char    PPRHNUM

Local Integer ZEST
Local Integer CONT_TOTAL
Local Integer EN_CURSO

If !clalev([YP01]) Then : Local File YSPACK   [YP01] : Endif
If !clalev([YP02]) Then : Local File STOPRED  [YP02] : Endif

For [YP01] Where [YP01]VCRNUM = PPRHNUM
  [L]CONT_TOTAL += 1
Next

If [L]CONT_TOTAL = 0
  ZEST = 1 # Estado = En Espera
Else
  Filter [YP02] Where [YP02]PRHNUM = PPRHNUM Order By [YP02]PRELIN Asc
    For [YP02]
      If [YP02]YQTYSTU < [YP02]QTYSTU
        [L]EN_CURSO = 2
        Break
      Endif
    Next
  Filter [YP02]

  If [L]EN_CURSO = 2
    ZEST = 2 # Estado = En Curso
  Else
    ZEST = 3 # Estado = Preparado
  Endif
Endif


Close Local File [YP01]
Close Local File [YP02]
End ZEST
